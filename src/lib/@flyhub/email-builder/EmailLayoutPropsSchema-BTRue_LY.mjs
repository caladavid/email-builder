/**
 *  Copyright 2025 AntonyDev
 *  @license MIT
**/
import { defineComponent, computed, createElementBlock, openBlock, normalizeStyle, createElementVNode, toDisplayString, createBlock, resolveDynamicComponent, withCtx, createTextVNode, normalizeProps, mergeProps, guardReactiveProps, createVNode, renderSlot, createCommentVNode, Fragment, renderList, unref } from "vue";
/**
 *  Copyright 2025 AntonyDev
 *  @license MIT
**/
var util$a;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$a || (util$a = {}));
var objectUtil$a;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$a || (objectUtil$a = {}));
const ZodParsedType$a = util$a.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$a = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$a.undefined;
    case "string":
      return ZodParsedType$a.string;
    case "number":
      return isNaN(data) ? ZodParsedType$a.nan : ZodParsedType$a.number;
    case "boolean":
      return ZodParsedType$a.boolean;
    case "function":
      return ZodParsedType$a.function;
    case "bigint":
      return ZodParsedType$a.bigint;
    case "symbol":
      return ZodParsedType$a.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$a.array;
      }
      if (data === null) {
        return ZodParsedType$a.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$a.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$a.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$a.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$a.date;
      }
      return ZodParsedType$a.object;
    default:
      return ZodParsedType$a.unknown;
  }
};
const ZodIssueCode$a = util$a.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson$a = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
let ZodError$a = class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$a.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$a.create = (issues) => {
  const error = new ZodError$a(issues);
  return error;
};
const errorMap$a = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode$a.invalid_type:
      if (issue.received === ZodParsedType$a.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode$a.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$a.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$a.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$a.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode$a.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$a.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$a.joinValues(issue.options)}`;
      break;
    case ZodIssueCode$a.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$a.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode$a.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$a.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$a.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$a.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util$a.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$a.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$a.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$a.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$a.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$a.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode$a.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$a.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap$a = errorMap$a;
function setErrorMap$a(map) {
  overrideErrorMap$a = map;
}
function getErrorMap$a() {
  return overrideErrorMap$a;
}
const makeIssue$a = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH$a = [];
function addIssueToContext$a(ctx, issueData) {
  const overrideMap = getErrorMap$a();
  const issue = makeIssue$a({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$a ? void 0 : errorMap$a
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
let ParseStatus$a = class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$a;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$a;
      if (value.status === "aborted")
        return INVALID$a;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$a = Object.freeze({
  status: "aborted"
});
const DIRTY$a = (value) => ({ status: "dirty", value });
const OK$a = (value) => ({ status: "valid", value });
const isAborted$a = (x) => x.status === "aborted";
const isDirty$a = (x) => x.status === "dirty";
const isValid$a = (x) => x.status === "valid";
const isAsync$a = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet$a(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet$a(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil$a;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil$a || (errorUtil$a = {}));
var _ZodEnum_cache$a, _ZodNativeEnum_cache$a;
let ParseInputLazyPath$a = class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$a = (ctx, result) => {
  if (isValid$a(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$a(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$a(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$a = class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$a(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$a(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$a(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$a(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$a(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$a(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$a(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$a(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$a(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$a(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$a(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$a(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$a(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$a.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$a({
      schema: this,
      typeName: ZodFirstPartyTypeKind$a.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def2) {
    this.spa = this.safeParseAsync;
    this._def = def2;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$a.create(this, this._def);
  }
  nullable() {
    return ZodNullable$a.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$a.create(this);
  }
  promise() {
    return ZodPromise$a.create(this, this._def);
  }
  or(option) {
    return ZodUnion$a.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$a.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects$a({
      ...processCreateParams$a(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$a.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def2) {
    const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodDefault$a({
      ...processCreateParams$a(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$a.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$a({
      typeName: ZodFirstPartyTypeKind$a.ZodBranded,
      type: this,
      ...processCreateParams$a(this._def)
    });
  }
  catch(def2) {
    const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodCatch$a({
      ...processCreateParams$a(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$a.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$a.create(this, target);
  }
  readonly() {
    return ZodReadonly$a.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$a = /^c[^\s-]{8,}$/i;
const cuid2Regex$a = /^[0-9a-z]+$/;
const ulidRegex$a = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$a = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$a = /^[a-z0-9_-]{21}$/i;
const jwtRegex$a = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$a = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$a = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$a = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$a;
const ipv4Regex$a = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$a = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$a = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$a = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$a = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$a = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$a = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$a = new RegExp(`^${dateRegexSource$a}$`);
function timeRegexSource$a(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex$a(args) {
  return new RegExp(`^${timeRegexSource$a(args)}$`);
}
function datetimeRegex$a(args) {
  let regex = `${dateRegexSource$a}T${timeRegexSource$a(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$a(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex$a.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex$a.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$a(jwt, alg) {
  if (!jwtRegex$a.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr$a(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex$a.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex$a.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$a = class ZodString extends ZodType$a {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx2, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.string,
        received: ctx2.parsedType
      });
      return INVALID$a;
    }
    const status = new ParseStatus$a();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$a(ctx, {
              code: ZodIssueCode$a.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$a(ctx, {
              code: ZodIssueCode$a.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "email",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$a) {
          emojiRegex$a = new RegExp(_emojiRegex$a, "u");
        }
        if (!emojiRegex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "emoji",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "uuid",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "cuid",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "ulid",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "url",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "regex",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$a(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$a;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$a(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "duration",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$a(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "ip",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$a(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "jwt",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$a(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "cidr",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "base64",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$a.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            validation: "base64url",
            code: ZodIssueCode$a.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$a.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$a.invalid_string,
      ...errorUtil$a.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$a.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$a.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$a.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$a.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$a.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$a.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$a.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$a.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$a.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$a.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$a.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$a.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$a.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil$a.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil$a.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$a.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$a.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil$a.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$a.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$a.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$a.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$a.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$a.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$a.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$a.create = (params) => {
  var _a;
  return new ZodString$a({
    checks: [],
    typeName: ZodFirstPartyTypeKind$a.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$a(params)
  });
};
function floatSafeRemainder$a(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
let ZodNumber$a = class ZodNumber extends ZodType$a {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx2, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.number,
        received: ctx2.parsedType
      });
      return INVALID$a;
    }
    let ctx = void 0;
    const status = new ParseStatus$a();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$a.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$a(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$a.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$a.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$a.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$a.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$a.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$a.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$a.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$a.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$a.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$a.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$a.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$a.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$a.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$a.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$a.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$a.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$a.create = (params) => {
  return new ZodNumber$a({
    checks: [],
    typeName: ZodFirstPartyTypeKind$a.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$a(params)
  });
};
let ZodBigInt$a = class ZodBigInt extends ZodType$a {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$a();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$a.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$a(ctx, {
      code: ZodIssueCode$a.invalid_type,
      expected: ZodParsedType$a.bigint,
      received: ctx.parsedType
    });
    return INVALID$a;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$a.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$a.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$a.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$a.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$a.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$a.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$a.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$a.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$a.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$a.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$a.create = (params) => {
  var _a;
  return new ZodBigInt$a({
    checks: [],
    typeName: ZodFirstPartyTypeKind$a.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$a(params)
  });
};
let ZodBoolean$a = class ZodBoolean extends ZodType$a {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.boolean,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    return OK$a(input.data);
  }
};
ZodBoolean$a.create = (params) => {
  return new ZodBoolean$a({
    typeName: ZodFirstPartyTypeKind$a.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$a(params)
  });
};
let ZodDate$a = class ZodDate extends ZodType$a {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx2, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.date,
        received: ctx2.parsedType
      });
      return INVALID$a;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx2, {
        code: ZodIssueCode$a.invalid_date
      });
      return INVALID$a;
    }
    const status = new ParseStatus$a();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$a.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$a.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$a.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$a.create = (params) => {
  return new ZodDate$a({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$a.ZodDate,
    ...processCreateParams$a(params)
  });
};
let ZodSymbol$a = class ZodSymbol extends ZodType$a {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.symbol,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    return OK$a(input.data);
  }
};
ZodSymbol$a.create = (params) => {
  return new ZodSymbol$a({
    typeName: ZodFirstPartyTypeKind$a.ZodSymbol,
    ...processCreateParams$a(params)
  });
};
let ZodUndefined$a = class ZodUndefined extends ZodType$a {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.undefined,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    return OK$a(input.data);
  }
};
ZodUndefined$a.create = (params) => {
  return new ZodUndefined$a({
    typeName: ZodFirstPartyTypeKind$a.ZodUndefined,
    ...processCreateParams$a(params)
  });
};
let ZodNull$a = class ZodNull extends ZodType$a {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.null,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    return OK$a(input.data);
  }
};
ZodNull$a.create = (params) => {
  return new ZodNull$a({
    typeName: ZodFirstPartyTypeKind$a.ZodNull,
    ...processCreateParams$a(params)
  });
};
let ZodAny$a = class ZodAny extends ZodType$a {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$a(input.data);
  }
};
ZodAny$a.create = (params) => {
  return new ZodAny$a({
    typeName: ZodFirstPartyTypeKind$a.ZodAny,
    ...processCreateParams$a(params)
  });
};
let ZodUnknown$a = class ZodUnknown extends ZodType$a {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$a(input.data);
  }
};
ZodUnknown$a.create = (params) => {
  return new ZodUnknown$a({
    typeName: ZodFirstPartyTypeKind$a.ZodUnknown,
    ...processCreateParams$a(params)
  });
};
let ZodNever$a = class ZodNever extends ZodType$a {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$a(ctx, {
      code: ZodIssueCode$a.invalid_type,
      expected: ZodParsedType$a.never,
      received: ctx.parsedType
    });
    return INVALID$a;
  }
};
ZodNever$a.create = (params) => {
  return new ZodNever$a({
    typeName: ZodFirstPartyTypeKind$a.ZodNever,
    ...processCreateParams$a(params)
  });
};
let ZodVoid$a = class ZodVoid extends ZodType$a {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.void,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    return OK$a(input.data);
  }
};
ZodVoid$a.create = (params) => {
  return new ZodVoid$a({
    typeName: ZodFirstPartyTypeKind$a.ZodVoid,
    ...processCreateParams$a(params)
  });
};
let ZodArray$a = class ZodArray extends ZodType$a {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def2 = this._def;
    if (ctx.parsedType !== ZodParsedType$a.array) {
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.array,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    if (def2.exactLength !== null) {
      const tooBig = ctx.data.length > def2.exactLength.value;
      const tooSmall = ctx.data.length < def2.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$a(ctx, {
          code: tooBig ? ZodIssueCode$a.too_big : ZodIssueCode$a.too_small,
          minimum: tooSmall ? def2.exactLength.value : void 0,
          maximum: tooBig ? def2.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def2.exactLength.message
        });
        status.dirty();
      }
    }
    if (def2.minLength !== null) {
      if (ctx.data.length < def2.minLength.value) {
        addIssueToContext$a(ctx, {
          code: ZodIssueCode$a.too_small,
          minimum: def2.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.minLength.message
        });
        status.dirty();
      }
    }
    if (def2.maxLength !== null) {
      if (ctx.data.length > def2.maxLength.value) {
        addIssueToContext$a(ctx, {
          code: ZodIssueCode$a.too_big,
          maximum: def2.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def2.type._parseAsync(new ParseInputLazyPath$a(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$a.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def2.type._parseSync(new ParseInputLazyPath$a(ctx, item, ctx.path, i));
    });
    return ParseStatus$a.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$a.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$a.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil$a.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$a.create = (schema, params) => {
  return new ZodArray$a({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$a.ZodArray,
    ...processCreateParams$a(params)
  });
};
function deepPartialify$a(schema) {
  if (schema instanceof ZodObject$a) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$a.create(deepPartialify$a(fieldSchema));
    }
    return new ZodObject$a({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$a) {
    return new ZodArray$a({
      ...schema._def,
      type: deepPartialify$a(schema.element)
    });
  } else if (schema instanceof ZodOptional$a) {
    return ZodOptional$a.create(deepPartialify$a(schema.unwrap()));
  } else if (schema instanceof ZodNullable$a) {
    return ZodNullable$a.create(deepPartialify$a(schema.unwrap()));
  } else if (schema instanceof ZodTuple$a) {
    return ZodTuple$a.create(schema.items.map((item) => deepPartialify$a(item)));
  } else {
    return schema;
  }
}
let ZodObject$a = class ZodObject extends ZodType$a {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$a.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx2, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.object,
        received: ctx2.parsedType
      });
      return INVALID$a;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$a && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$a(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$a) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$a(ctx, {
            code: ZodIssueCode$a.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$a(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$a.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$a.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$a.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil$a.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$a.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util$a.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util$a.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$a(this);
  }
  partial(mask) {
    const newShape = {};
    util$a.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util$a.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$a) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$a(util$a.objectKeys(this.shape));
  }
};
ZodObject$a.create = (shape, params) => {
  return new ZodObject$a({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$a.create(),
    typeName: ZodFirstPartyTypeKind$a.ZodObject,
    ...processCreateParams$a(params)
  });
};
ZodObject$a.strictCreate = (shape, params) => {
  return new ZodObject$a({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$a.create(),
    typeName: ZodFirstPartyTypeKind$a.ZodObject,
    ...processCreateParams$a(params)
  });
};
ZodObject$a.lazycreate = (shape, params) => {
  return new ZodObject$a({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$a.create(),
    typeName: ZodFirstPartyTypeKind$a.ZodObject,
    ...processCreateParams$a(params)
  });
};
let ZodUnion$a = class ZodUnion extends ZodType$a {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$a(result.ctx.common.issues));
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_union,
        unionErrors
      });
      return INVALID$a;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$a(issues2));
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_union,
        unionErrors
      });
      return INVALID$a;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$a.create = (types, params) => {
  return new ZodUnion$a({
    options: types,
    typeName: ZodFirstPartyTypeKind$a.ZodUnion,
    ...processCreateParams$a(params)
  });
};
const getDiscriminator$a = (type) => {
  if (type instanceof ZodLazy$a) {
    return getDiscriminator$a(type.schema);
  } else if (type instanceof ZodEffects$a) {
    return getDiscriminator$a(type.innerType());
  } else if (type instanceof ZodLiteral$a) {
    return [type.value];
  } else if (type instanceof ZodEnum$a) {
    return type.options;
  } else if (type instanceof ZodNativeEnum$a) {
    return util$a.objectValues(type.enum);
  } else if (type instanceof ZodDefault$a) {
    return getDiscriminator$a(type._def.innerType);
  } else if (type instanceof ZodUndefined$a) {
    return [void 0];
  } else if (type instanceof ZodNull$a) {
    return [null];
  } else if (type instanceof ZodOptional$a) {
    return [void 0, ...getDiscriminator$a(type.unwrap())];
  } else if (type instanceof ZodNullable$a) {
    return [null, ...getDiscriminator$a(type.unwrap())];
  } else if (type instanceof ZodBranded$a) {
    return getDiscriminator$a(type.unwrap());
  } else if (type instanceof ZodReadonly$a) {
    return getDiscriminator$a(type.unwrap());
  } else if (type instanceof ZodCatch$a) {
    return getDiscriminator$a(type._def.innerType);
  } else {
    return [];
  }
};
let ZodDiscriminatedUnion$a = class ZodDiscriminatedUnion extends ZodType$a {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$a.object) {
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.object,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID$a;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator$a(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind$a.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams$a(params)
    });
  }
};
function mergeValues$a(a, b) {
  const aType = getParsedType$a(a);
  const bType = getParsedType$a(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$a.object && bType === ZodParsedType$a.object) {
    const bKeys = util$a.objectKeys(b);
    const sharedKeys = util$a.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$a(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$a.array && bType === ZodParsedType$a.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$a(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$a.date && bType === ZodParsedType$a.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$a = class ZodIntersection extends ZodType$a {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$a(parsedLeft) || isAborted$a(parsedRight)) {
        return INVALID$a;
      }
      const merged = mergeValues$a(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$a(ctx, {
          code: ZodIssueCode$a.invalid_intersection_types
        });
        return INVALID$a;
      }
      if (isDirty$a(parsedLeft) || isDirty$a(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$a.create = (left, right, params) => {
  return new ZodIntersection$a({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$a.ZodIntersection,
    ...processCreateParams$a(params)
  });
};
let ZodTuple$a = class ZodTuple extends ZodType$a {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$a.array) {
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.array,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$a;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$a(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$a.mergeArray(status, results);
      });
    } else {
      return ParseStatus$a.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple$a.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$a({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$a.ZodTuple,
    rest: null,
    ...processCreateParams$a(params)
  });
};
let ZodRecord$a = class ZodRecord extends ZodType$a {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$a.object) {
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.object,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath$a(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath$a(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus$a.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus$a.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType$a) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind$a.ZodRecord,
        ...processCreateParams$a(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString$a.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind$a.ZodRecord,
      ...processCreateParams$a(second)
    });
  }
};
let ZodMap$a = class ZodMap extends ZodType$a {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$a.map) {
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.map,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$a(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$a(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$a;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$a;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$a.create = (keyType, valueType, params) => {
  return new ZodMap$a({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$a.ZodMap,
    ...processCreateParams$a(params)
  });
};
let ZodSet$a = class ZodSet extends ZodType$a {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$a.set) {
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.set,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    const def2 = this._def;
    if (def2.minSize !== null) {
      if (ctx.data.size < def2.minSize.value) {
        addIssueToContext$a(ctx, {
          code: ZodIssueCode$a.too_small,
          minimum: def2.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.minSize.message
        });
        status.dirty();
      }
    }
    if (def2.maxSize !== null) {
      if (ctx.data.size > def2.maxSize.value) {
        addIssueToContext$a(ctx, {
          code: ZodIssueCode$a.too_big,
          maximum: def2.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements22) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements22) {
        if (element.status === "aborted")
          return INVALID$a;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements2 = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$a(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements2).then((elements22) => finalizeSet(elements22));
    } else {
      return finalizeSet(elements2);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$a.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$a.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$a.create = (valueType, params) => {
  return new ZodSet$a({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$a.ZodSet,
    ...processCreateParams$a(params)
  });
};
let ZodFunction$a = class ZodFunction extends ZodType$a {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$a.function) {
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.function,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    function makeArgsIssue(args, error) {
      return makeIssue$a({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$a(),
          errorMap$a
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$a.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue$a({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$a(),
          errorMap$a
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$a.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise$a) {
      const me = this;
      return OK$a(async function(...args) {
        const error = new ZodError$a([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK$a(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError$a([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError$a([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple$a.create(items).rest(ZodUnknown$a.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple$a.create([]).rest(ZodUnknown$a.create()),
      returns: returns || ZodUnknown$a.create(),
      typeName: ZodFirstPartyTypeKind$a.ZodFunction,
      ...processCreateParams$a(params)
    });
  }
};
let ZodLazy$a = class ZodLazy extends ZodType$a {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$a.create = (getter, params) => {
  return new ZodLazy$a({
    getter,
    typeName: ZodFirstPartyTypeKind$a.ZodLazy,
    ...processCreateParams$a(params)
  });
};
let ZodLiteral$a = class ZodLiteral extends ZodType$a {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx, {
        received: ctx.data,
        code: ZodIssueCode$a.invalid_literal,
        expected: this._def.value
      });
      return INVALID$a;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$a.create = (value, params) => {
  return new ZodLiteral$a({
    value,
    typeName: ZodFirstPartyTypeKind$a.ZodLiteral,
    ...processCreateParams$a(params)
  });
};
function createZodEnum$a(values, params) {
  return new ZodEnum$a({
    values,
    typeName: ZodFirstPartyTypeKind$a.ZodEnum,
    ...processCreateParams$a(params)
  });
}
let ZodEnum$a = class ZodEnum extends ZodType$a {
  constructor() {
    super(...arguments);
    _ZodEnum_cache$a.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$a(ctx, {
        expected: util$a.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$a.invalid_type
      });
      return INVALID$a;
    }
    if (!__classPrivateFieldGet$a(this, _ZodEnum_cache$a)) {
      __classPrivateFieldSet$a(this, _ZodEnum_cache$a, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet$a(this, _ZodEnum_cache$a).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$a(ctx, {
        received: ctx.data,
        code: ZodIssueCode$a.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$a;
    }
    return OK$a(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache$a = /* @__PURE__ */ new WeakMap();
ZodEnum$a.create = createZodEnum$a;
let ZodNativeEnum$a = class ZodNativeEnum extends ZodType$a {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache$a.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util$a.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$a.string && ctx.parsedType !== ZodParsedType$a.number) {
      const expectedValues = util$a.objectValues(nativeEnumValues);
      addIssueToContext$a(ctx, {
        expected: util$a.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$a.invalid_type
      });
      return INVALID$a;
    }
    if (!__classPrivateFieldGet$a(this, _ZodNativeEnum_cache$a)) {
      __classPrivateFieldSet$a(this, _ZodNativeEnum_cache$a, new Set(util$a.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet$a(this, _ZodNativeEnum_cache$a).has(input.data)) {
      const expectedValues = util$a.objectValues(nativeEnumValues);
      addIssueToContext$a(ctx, {
        received: ctx.data,
        code: ZodIssueCode$a.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$a;
    }
    return OK$a(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache$a = /* @__PURE__ */ new WeakMap();
ZodNativeEnum$a.create = (values, params) => {
  return new ZodNativeEnum$a({
    values,
    typeName: ZodFirstPartyTypeKind$a.ZodNativeEnum,
    ...processCreateParams$a(params)
  });
};
let ZodPromise$a = class ZodPromise extends ZodType$a {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$a.promise && ctx.common.async === false) {
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.promise,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    const promisified = ctx.parsedType === ZodParsedType$a.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$a(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$a.create = (schema, params) => {
  return new ZodPromise$a({
    type: schema,
    typeName: ZodFirstPartyTypeKind$a.ZodPromise,
    ...processCreateParams$a(params)
  });
};
let ZodEffects$a = class ZodEffects extends ZodType$a {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$a.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$a(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$a;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$a;
          if (result.status === "dirty")
            return DIRTY$a(result.value);
          if (status.value === "dirty")
            return DIRTY$a(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$a;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$a;
        if (result.status === "dirty")
          return DIRTY$a(result.value);
        if (status.value === "dirty")
          return DIRTY$a(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$a;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$a;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$a(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$a(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util$a.assertNever(effect);
  }
};
ZodEffects$a.create = (schema, effect, params) => {
  return new ZodEffects$a({
    schema,
    typeName: ZodFirstPartyTypeKind$a.ZodEffects,
    effect,
    ...processCreateParams$a(params)
  });
};
ZodEffects$a.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$a({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$a.ZodEffects,
    ...processCreateParams$a(params)
  });
};
let ZodOptional$a = class ZodOptional extends ZodType$a {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$a.undefined) {
      return OK$a(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$a.create = (type, params) => {
  return new ZodOptional$a({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$a.ZodOptional,
    ...processCreateParams$a(params)
  });
};
let ZodNullable$a = class ZodNullable extends ZodType$a {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$a.null) {
      return OK$a(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$a.create = (type, params) => {
  return new ZodNullable$a({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$a.ZodNullable,
    ...processCreateParams$a(params)
  });
};
let ZodDefault$a = class ZodDefault extends ZodType$a {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$a.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$a.create = (type, params) => {
  return new ZodDefault$a({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$a.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$a(params)
  });
};
let ZodCatch$a = class ZodCatch extends ZodType$a {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$a(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$a(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$a(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$a.create = (type, params) => {
  return new ZodCatch$a({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$a.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$a(params)
  });
};
let ZodNaN$a = class ZodNaN extends ZodType$a {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$a.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$a(ctx, {
        code: ZodIssueCode$a.invalid_type,
        expected: ZodParsedType$a.nan,
        received: ctx.parsedType
      });
      return INVALID$a;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$a.create = (params) => {
  return new ZodNaN$a({
    typeName: ZodFirstPartyTypeKind$a.ZodNaN,
    ...processCreateParams$a(params)
  });
};
const BRAND$a = Symbol("zod_brand");
let ZodBranded$a = class ZodBranded extends ZodType$a {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$a = class ZodPipeline extends ZodType$a {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$a;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$a(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$a;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$a.ZodPipeline
    });
  }
};
let ZodReadonly$a = class ZodReadonly extends ZodType$a {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$a(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$a(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$a.create = (type, params) => {
  return new ZodReadonly$a({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$a.ZodReadonly,
    ...processCreateParams$a(params)
  });
};
function cleanParams$a(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom$a(check, _params = {}, fatal) {
  if (check)
    return ZodAny$a.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams$a(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams$a(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny$a.create();
}
const late$a = {
  object: ZodObject$a.lazycreate
};
var ZodFirstPartyTypeKind$a;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$a || (ZodFirstPartyTypeKind$a = {}));
const instanceOfType$a = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom$a((data) => data instanceof cls, params);
const stringType$a = ZodString$a.create;
const numberType$a = ZodNumber$a.create;
const nanType$a = ZodNaN$a.create;
const bigIntType$a = ZodBigInt$a.create;
const booleanType$a = ZodBoolean$a.create;
const dateType$a = ZodDate$a.create;
const symbolType$a = ZodSymbol$a.create;
const undefinedType$a = ZodUndefined$a.create;
const nullType$a = ZodNull$a.create;
const anyType$a = ZodAny$a.create;
const unknownType$a = ZodUnknown$a.create;
const neverType$a = ZodNever$a.create;
const voidType$a = ZodVoid$a.create;
const arrayType$a = ZodArray$a.create;
const objectType$a = ZodObject$a.create;
const strictObjectType$a = ZodObject$a.strictCreate;
const unionType$a = ZodUnion$a.create;
const discriminatedUnionType$a = ZodDiscriminatedUnion$a.create;
const intersectionType$a = ZodIntersection$a.create;
const tupleType$a = ZodTuple$a.create;
const recordType$a = ZodRecord$a.create;
const mapType$a = ZodMap$a.create;
const setType$a = ZodSet$a.create;
const functionType$a = ZodFunction$a.create;
const lazyType$a = ZodLazy$a.create;
const literalType$a = ZodLiteral$a.create;
const enumType$a = ZodEnum$a.create;
const nativeEnumType$a = ZodNativeEnum$a.create;
const promiseType$a = ZodPromise$a.create;
const effectsType$a = ZodEffects$a.create;
const optionalType$a = ZodOptional$a.create;
const nullableType$a = ZodNullable$a.create;
const preprocessType$a = ZodEffects$a.createWithPreprocess;
const pipelineType$a = ZodPipeline$a.create;
const ostring$a = () => stringType$a().optional();
const onumber$a = () => numberType$a().optional();
const oboolean$a = () => booleanType$a().optional();
const coerce$a = {
  string: (arg) => ZodString$a.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber$a.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean$a.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt$a.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate$a.create({ ...arg, coerce: true })
};
const NEVER$a = INVALID$a;
var z$a = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap$a,
  setErrorMap: setErrorMap$a,
  getErrorMap: getErrorMap$a,
  makeIssue: makeIssue$a,
  EMPTY_PATH: EMPTY_PATH$a,
  addIssueToContext: addIssueToContext$a,
  ParseStatus: ParseStatus$a,
  INVALID: INVALID$a,
  DIRTY: DIRTY$a,
  OK: OK$a,
  isAborted: isAborted$a,
  isDirty: isDirty$a,
  isValid: isValid$a,
  isAsync: isAsync$a,
  get util() {
    return util$a;
  },
  get objectUtil() {
    return objectUtil$a;
  },
  ZodParsedType: ZodParsedType$a,
  getParsedType: getParsedType$a,
  ZodType: ZodType$a,
  datetimeRegex: datetimeRegex$a,
  ZodString: ZodString$a,
  ZodNumber: ZodNumber$a,
  ZodBigInt: ZodBigInt$a,
  ZodBoolean: ZodBoolean$a,
  ZodDate: ZodDate$a,
  ZodSymbol: ZodSymbol$a,
  ZodUndefined: ZodUndefined$a,
  ZodNull: ZodNull$a,
  ZodAny: ZodAny$a,
  ZodUnknown: ZodUnknown$a,
  ZodNever: ZodNever$a,
  ZodVoid: ZodVoid$a,
  ZodArray: ZodArray$a,
  ZodObject: ZodObject$a,
  ZodUnion: ZodUnion$a,
  ZodDiscriminatedUnion: ZodDiscriminatedUnion$a,
  ZodIntersection: ZodIntersection$a,
  ZodTuple: ZodTuple$a,
  ZodRecord: ZodRecord$a,
  ZodMap: ZodMap$a,
  ZodSet: ZodSet$a,
  ZodFunction: ZodFunction$a,
  ZodLazy: ZodLazy$a,
  ZodLiteral: ZodLiteral$a,
  ZodEnum: ZodEnum$a,
  ZodNativeEnum: ZodNativeEnum$a,
  ZodPromise: ZodPromise$a,
  ZodEffects: ZodEffects$a,
  ZodTransformer: ZodEffects$a,
  ZodOptional: ZodOptional$a,
  ZodNullable: ZodNullable$a,
  ZodDefault: ZodDefault$a,
  ZodCatch: ZodCatch$a,
  ZodNaN: ZodNaN$a,
  BRAND: BRAND$a,
  ZodBranded: ZodBranded$a,
  ZodPipeline: ZodPipeline$a,
  ZodReadonly: ZodReadonly$a,
  custom: custom$a,
  Schema: ZodType$a,
  ZodSchema: ZodType$a,
  late: late$a,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind$a;
  },
  coerce: coerce$a,
  any: anyType$a,
  array: arrayType$a,
  bigint: bigIntType$a,
  boolean: booleanType$a,
  date: dateType$a,
  discriminatedUnion: discriminatedUnionType$a,
  effect: effectsType$a,
  "enum": enumType$a,
  "function": functionType$a,
  "instanceof": instanceOfType$a,
  intersection: intersectionType$a,
  lazy: lazyType$a,
  literal: literalType$a,
  map: mapType$a,
  nan: nanType$a,
  nativeEnum: nativeEnumType$a,
  never: neverType$a,
  "null": nullType$a,
  nullable: nullableType$a,
  number: numberType$a,
  object: objectType$a,
  oboolean: oboolean$a,
  onumber: onumber$a,
  optional: optionalType$a,
  ostring: ostring$a,
  pipeline: pipelineType$a,
  preprocess: preprocessType$a,
  promise: promiseType$a,
  record: recordType$a,
  set: setType$a,
  strictObject: strictObjectType$a,
  string: stringType$a,
  symbol: symbolType$a,
  transformer: effectsType$a,
  tuple: tupleType$a,
  "undefined": undefinedType$a,
  union: unionType$a,
  unknown: unknownType$a,
  "void": voidType$a,
  NEVER: NEVER$a,
  ZodIssueCode: ZodIssueCode$a,
  quotelessJson: quotelessJson$a,
  ZodError: ZodError$a
});
const FONT_FAMILY_NAMES$9 = [
  "MODERN_SANS",
  "BOOK_SANS",
  "ORGANIC_SANS",
  "GEOMETRIC_SANS",
  "HEAVY_SANS",
  "ROUNDED_SANS",
  "MODERN_SERIF",
  "BOOK_SERIF",
  "MONOSPACE"
];
const PADDING_SCHEMA$8 = z$a.object({
  top: z$a.number(),
  bottom: z$a.number(),
  right: z$a.number(),
  left: z$a.number()
}).optional().nullable();
z$a.string().regex(/^#[0-9a-fA-F]{6}$/).nullable().optional();
z$a.enum(FONT_FAMILY_NAMES$9).nullable().optional();
const getPadding$8 = (padding) => padding ? `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px` : void 0;
const _hoisted_1$6 = ["alt", "src", "height", "width"];
const AvatarPropsDefaults = {
  size: 64,
  imageUrl: "",
  alt: "",
  shape: "square"
};
const AvatarPropsSchema = z$a.object({
  style: z$a.object({
    textAlign: z$a.enum(["left", "center", "right"]).optional().nullable(),
    padding: PADDING_SCHEMA$8
  }).optional().nullable(),
  props: z$a.object({
    size: z$a.number().gt(0).optional().nullable(),
    shape: z$a.enum(["circle", "square", "rounded"]).optional().nullable(),
    imageUrl: z$a.string().optional().nullable(),
    alt: z$a.string().optional().nullable()
  }).optional().nullable()
});
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    style: {},
    props: {}
  },
  setup(__props) {
    function getBorderRadius(shape2, size2) {
      switch (shape2) {
        case "rounded":
          return size2 * 0.125 + "px";
        case "circle":
          return size2 + "px";
        case "square":
        default:
          return void 0;
      }
    }
    const props = __props;
    const size = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.size) ?? AvatarPropsDefaults.size;
    });
    const imageUrl = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.imageUrl) ?? AvatarPropsDefaults.imageUrl;
    });
    const alt = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.alt) ?? AvatarPropsDefaults.alt;
    });
    const shape = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.shape) ?? AvatarPropsDefaults.shape;
    });
    const sectionStyle = computed(() => {
      var _a, _b;
      return {
        textAlign: ((_a = props.style) == null ? void 0 : _a.textAlign) ?? void 0,
        padding: getPadding$8((_b = props.style) == null ? void 0 : _b.padding)
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        style: normalizeStyle(sectionStyle.value)
      }, [
        createElementVNode("img", {
          alt: alt.value,
          src: imageUrl.value,
          height: size.value,
          width: size.value,
          style: normalizeStyle({
            outline: "none",
            border: "none",
            textDecoration: "none",
            objectFit: "cover",
            height: size.value,
            width: size.value,
            maxWidth: "100%",
            display: "inline-block",
            verticalAlign: "middle",
            textAlign: "center",
            borderRadius: getBorderRadius(shape.value, size.value)
          })
        }, null, 12, _hoisted_1$6)
      ], 4);
    };
  }
});
/**
 *  Copyright 2025 AntonyDev
 *  @license MIT
**/
var util$9;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$9 || (util$9 = {}));
var objectUtil$9;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$9 || (objectUtil$9 = {}));
const ZodParsedType$9 = util$9.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$9 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$9.undefined;
    case "string":
      return ZodParsedType$9.string;
    case "number":
      return isNaN(data) ? ZodParsedType$9.nan : ZodParsedType$9.number;
    case "boolean":
      return ZodParsedType$9.boolean;
    case "function":
      return ZodParsedType$9.function;
    case "bigint":
      return ZodParsedType$9.bigint;
    case "symbol":
      return ZodParsedType$9.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$9.array;
      }
      if (data === null) {
        return ZodParsedType$9.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$9.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$9.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$9.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$9.date;
      }
      return ZodParsedType$9.object;
    default:
      return ZodParsedType$9.unknown;
  }
};
const ZodIssueCode$9 = util$9.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson$9 = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
let ZodError$9 = class ZodError2 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError2)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$9.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$9.create = (issues) => {
  const error = new ZodError$9(issues);
  return error;
};
const errorMap$9 = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode$9.invalid_type:
      if (issue.received === ZodParsedType$9.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode$9.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$9.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$9.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$9.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode$9.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$9.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$9.joinValues(issue.options)}`;
      break;
    case ZodIssueCode$9.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$9.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode$9.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$9.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$9.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$9.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util$9.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$9.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$9.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$9.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$9.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$9.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode$9.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$9.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap$9 = errorMap$9;
function setErrorMap$9(map) {
  overrideErrorMap$9 = map;
}
function getErrorMap$9() {
  return overrideErrorMap$9;
}
const makeIssue$9 = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH$9 = [];
function addIssueToContext$9(ctx, issueData) {
  const overrideMap = getErrorMap$9();
  const issue = makeIssue$9({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$9 ? void 0 : errorMap$9
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
let ParseStatus$9 = class ParseStatus2 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$9;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus2.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$9;
      if (value.status === "aborted")
        return INVALID$9;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$9 = Object.freeze({
  status: "aborted"
});
const DIRTY$9 = (value) => ({ status: "dirty", value });
const OK$9 = (value) => ({ status: "valid", value });
const isAborted$9 = (x) => x.status === "aborted";
const isDirty$9 = (x) => x.status === "dirty";
const isValid$9 = (x) => x.status === "valid";
const isAsync$9 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet$9(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet$9(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil$9;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil$9 || (errorUtil$9 = {}));
var _ZodEnum_cache$9, _ZodNativeEnum_cache$9;
let ParseInputLazyPath$9 = class ParseInputLazyPath2 {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$9 = (ctx, result) => {
  if (isValid$9(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$9(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$9(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$9 = class ZodType2 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$9(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$9(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$9(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$9(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$9(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$9(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$9(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$9(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$9(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$9(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$9(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$9(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$9(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$9.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$9({
      schema: this,
      typeName: ZodFirstPartyTypeKind$9.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def2) {
    this.spa = this.safeParseAsync;
    this._def = def2;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$9.create(this, this._def);
  }
  nullable() {
    return ZodNullable$9.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$9.create(this);
  }
  promise() {
    return ZodPromise$9.create(this, this._def);
  }
  or(option) {
    return ZodUnion$9.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$9.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects$9({
      ...processCreateParams$9(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$9.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def2) {
    const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodDefault$9({
      ...processCreateParams$9(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$9.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$9({
      typeName: ZodFirstPartyTypeKind$9.ZodBranded,
      type: this,
      ...processCreateParams$9(this._def)
    });
  }
  catch(def2) {
    const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodCatch$9({
      ...processCreateParams$9(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$9.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$9.create(this, target);
  }
  readonly() {
    return ZodReadonly$9.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$9 = /^c[^\s-]{8,}$/i;
const cuid2Regex$9 = /^[0-9a-z]+$/;
const ulidRegex$9 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$9 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$9 = /^[a-z0-9_-]{21}$/i;
const jwtRegex$9 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$9 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$9 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$9 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$9;
const ipv4Regex$9 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$9 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$9 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$9 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$9 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$9 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$9 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$9 = new RegExp(`^${dateRegexSource$9}$`);
function timeRegexSource$9(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex$9(args) {
  return new RegExp(`^${timeRegexSource$9(args)}$`);
}
function datetimeRegex$9(args) {
  let regex = `${dateRegexSource$9}T${timeRegexSource$9(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$9(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex$9.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex$9.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$9(jwt, alg) {
  if (!jwtRegex$9.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr$9(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex$9.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex$9.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$9 = class ZodString2 extends ZodType$9 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx2, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.string,
        received: ctx2.parsedType
      });
      return INVALID$9;
    }
    const status = new ParseStatus$9();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$9(ctx, {
              code: ZodIssueCode$9.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$9(ctx, {
              code: ZodIssueCode$9.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "email",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$9) {
          emojiRegex$9 = new RegExp(_emojiRegex$9, "u");
        }
        if (!emojiRegex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "emoji",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "uuid",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "cuid",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "ulid",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "url",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "regex",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$9(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$9;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$9(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "duration",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$9(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "ip",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$9(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "jwt",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$9(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "cidr",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "base64",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$9.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            validation: "base64url",
            code: ZodIssueCode$9.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$9.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$9.invalid_string,
      ...errorUtil$9.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$9.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$9.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$9.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$9.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$9.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$9.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$9.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$9.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$9.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$9.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$9.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$9.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$9.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil$9.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil$9.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$9.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$9.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil$9.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$9.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$9.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$9.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$9.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$9.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$9.errToObj(message));
  }
  trim() {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$9.create = (params) => {
  var _a;
  return new ZodString$9({
    checks: [],
    typeName: ZodFirstPartyTypeKind$9.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$9(params)
  });
};
function floatSafeRemainder$9(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
let ZodNumber$9 = class ZodNumber2 extends ZodType$9 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx2, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.number,
        received: ctx2.parsedType
      });
      return INVALID$9;
    }
    let ctx = void 0;
    const status = new ParseStatus$9();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$9.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$9(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$9.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$9.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$9.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$9.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$9.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber2({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$9.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber2({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$9.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$9.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$9.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$9.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$9.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$9.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$9.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$9.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$9.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$9.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$9.create = (params) => {
  return new ZodNumber$9({
    checks: [],
    typeName: ZodFirstPartyTypeKind$9.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$9(params)
  });
};
let ZodBigInt$9 = class ZodBigInt2 extends ZodType$9 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$9();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$9.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$9(ctx, {
      code: ZodIssueCode$9.invalid_type,
      expected: ZodParsedType$9.bigint,
      received: ctx.parsedType
    });
    return INVALID$9;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$9.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$9.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$9.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$9.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt2({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$9.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt2({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$9.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$9.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$9.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$9.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$9.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$9.create = (params) => {
  var _a;
  return new ZodBigInt$9({
    checks: [],
    typeName: ZodFirstPartyTypeKind$9.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$9(params)
  });
};
let ZodBoolean$9 = class ZodBoolean2 extends ZodType$9 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.boolean,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    return OK$9(input.data);
  }
};
ZodBoolean$9.create = (params) => {
  return new ZodBoolean$9({
    typeName: ZodFirstPartyTypeKind$9.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$9(params)
  });
};
let ZodDate$9 = class ZodDate2 extends ZodType$9 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx2, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.date,
        received: ctx2.parsedType
      });
      return INVALID$9;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx2, {
        code: ZodIssueCode$9.invalid_date
      });
      return INVALID$9;
    }
    const status = new ParseStatus$9();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$9.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate2({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$9.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$9.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$9.create = (params) => {
  return new ZodDate$9({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$9.ZodDate,
    ...processCreateParams$9(params)
  });
};
let ZodSymbol$9 = class ZodSymbol2 extends ZodType$9 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.symbol,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    return OK$9(input.data);
  }
};
ZodSymbol$9.create = (params) => {
  return new ZodSymbol$9({
    typeName: ZodFirstPartyTypeKind$9.ZodSymbol,
    ...processCreateParams$9(params)
  });
};
let ZodUndefined$9 = class ZodUndefined2 extends ZodType$9 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.undefined,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    return OK$9(input.data);
  }
};
ZodUndefined$9.create = (params) => {
  return new ZodUndefined$9({
    typeName: ZodFirstPartyTypeKind$9.ZodUndefined,
    ...processCreateParams$9(params)
  });
};
let ZodNull$9 = class ZodNull2 extends ZodType$9 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.null,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    return OK$9(input.data);
  }
};
ZodNull$9.create = (params) => {
  return new ZodNull$9({
    typeName: ZodFirstPartyTypeKind$9.ZodNull,
    ...processCreateParams$9(params)
  });
};
let ZodAny$9 = class ZodAny2 extends ZodType$9 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$9(input.data);
  }
};
ZodAny$9.create = (params) => {
  return new ZodAny$9({
    typeName: ZodFirstPartyTypeKind$9.ZodAny,
    ...processCreateParams$9(params)
  });
};
let ZodUnknown$9 = class ZodUnknown2 extends ZodType$9 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$9(input.data);
  }
};
ZodUnknown$9.create = (params) => {
  return new ZodUnknown$9({
    typeName: ZodFirstPartyTypeKind$9.ZodUnknown,
    ...processCreateParams$9(params)
  });
};
let ZodNever$9 = class ZodNever2 extends ZodType$9 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$9(ctx, {
      code: ZodIssueCode$9.invalid_type,
      expected: ZodParsedType$9.never,
      received: ctx.parsedType
    });
    return INVALID$9;
  }
};
ZodNever$9.create = (params) => {
  return new ZodNever$9({
    typeName: ZodFirstPartyTypeKind$9.ZodNever,
    ...processCreateParams$9(params)
  });
};
let ZodVoid$9 = class ZodVoid2 extends ZodType$9 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.void,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    return OK$9(input.data);
  }
};
ZodVoid$9.create = (params) => {
  return new ZodVoid$9({
    typeName: ZodFirstPartyTypeKind$9.ZodVoid,
    ...processCreateParams$9(params)
  });
};
let ZodArray$9 = class ZodArray2 extends ZodType$9 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def2 = this._def;
    if (ctx.parsedType !== ZodParsedType$9.array) {
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.array,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    if (def2.exactLength !== null) {
      const tooBig = ctx.data.length > def2.exactLength.value;
      const tooSmall = ctx.data.length < def2.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$9(ctx, {
          code: tooBig ? ZodIssueCode$9.too_big : ZodIssueCode$9.too_small,
          minimum: tooSmall ? def2.exactLength.value : void 0,
          maximum: tooBig ? def2.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def2.exactLength.message
        });
        status.dirty();
      }
    }
    if (def2.minLength !== null) {
      if (ctx.data.length < def2.minLength.value) {
        addIssueToContext$9(ctx, {
          code: ZodIssueCode$9.too_small,
          minimum: def2.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.minLength.message
        });
        status.dirty();
      }
    }
    if (def2.maxLength !== null) {
      if (ctx.data.length > def2.maxLength.value) {
        addIssueToContext$9(ctx, {
          code: ZodIssueCode$9.too_big,
          maximum: def2.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def2.type._parseAsync(new ParseInputLazyPath$9(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$9.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def2.type._parseSync(new ParseInputLazyPath$9(ctx, item, ctx.path, i));
    });
    return ParseStatus$9.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray2({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$9.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray2({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$9.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray2({
      ...this._def,
      exactLength: { value: len, message: errorUtil$9.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$9.create = (schema, params) => {
  return new ZodArray$9({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$9.ZodArray,
    ...processCreateParams$9(params)
  });
};
function deepPartialify$9(schema) {
  if (schema instanceof ZodObject$9) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$9.create(deepPartialify$9(fieldSchema));
    }
    return new ZodObject$9({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$9) {
    return new ZodArray$9({
      ...schema._def,
      type: deepPartialify$9(schema.element)
    });
  } else if (schema instanceof ZodOptional$9) {
    return ZodOptional$9.create(deepPartialify$9(schema.unwrap()));
  } else if (schema instanceof ZodNullable$9) {
    return ZodNullable$9.create(deepPartialify$9(schema.unwrap()));
  } else if (schema instanceof ZodTuple$9) {
    return ZodTuple$9.create(schema.items.map((item) => deepPartialify$9(item)));
  } else {
    return schema;
  }
}
let ZodObject$9 = class ZodObject2 extends ZodType$9 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$9.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx2, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.object,
        received: ctx2.parsedType
      });
      return INVALID$9;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$9 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$9(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$9) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$9(ctx, {
            code: ZodIssueCode$9.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$9(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$9.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$9.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$9.errToObj;
    return new ZodObject2({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil$9.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject2({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject2({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject2({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject2({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$9.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject2({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util$9.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject2({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util$9.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject2({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$9(this);
  }
  partial(mask) {
    const newShape = {};
    util$9.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject2({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util$9.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$9) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject2({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$9(util$9.objectKeys(this.shape));
  }
};
ZodObject$9.create = (shape, params) => {
  return new ZodObject$9({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$9.create(),
    typeName: ZodFirstPartyTypeKind$9.ZodObject,
    ...processCreateParams$9(params)
  });
};
ZodObject$9.strictCreate = (shape, params) => {
  return new ZodObject$9({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$9.create(),
    typeName: ZodFirstPartyTypeKind$9.ZodObject,
    ...processCreateParams$9(params)
  });
};
ZodObject$9.lazycreate = (shape, params) => {
  return new ZodObject$9({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$9.create(),
    typeName: ZodFirstPartyTypeKind$9.ZodObject,
    ...processCreateParams$9(params)
  });
};
let ZodUnion$9 = class ZodUnion2 extends ZodType$9 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$9(result.ctx.common.issues));
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_union,
        unionErrors
      });
      return INVALID$9;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$9(issues2));
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_union,
        unionErrors
      });
      return INVALID$9;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$9.create = (types, params) => {
  return new ZodUnion$9({
    options: types,
    typeName: ZodFirstPartyTypeKind$9.ZodUnion,
    ...processCreateParams$9(params)
  });
};
const getDiscriminator$9 = (type) => {
  if (type instanceof ZodLazy$9) {
    return getDiscriminator$9(type.schema);
  } else if (type instanceof ZodEffects$9) {
    return getDiscriminator$9(type.innerType());
  } else if (type instanceof ZodLiteral$9) {
    return [type.value];
  } else if (type instanceof ZodEnum$9) {
    return type.options;
  } else if (type instanceof ZodNativeEnum$9) {
    return util$9.objectValues(type.enum);
  } else if (type instanceof ZodDefault$9) {
    return getDiscriminator$9(type._def.innerType);
  } else if (type instanceof ZodUndefined$9) {
    return [void 0];
  } else if (type instanceof ZodNull$9) {
    return [null];
  } else if (type instanceof ZodOptional$9) {
    return [void 0, ...getDiscriminator$9(type.unwrap())];
  } else if (type instanceof ZodNullable$9) {
    return [null, ...getDiscriminator$9(type.unwrap())];
  } else if (type instanceof ZodBranded$9) {
    return getDiscriminator$9(type.unwrap());
  } else if (type instanceof ZodReadonly$9) {
    return getDiscriminator$9(type.unwrap());
  } else if (type instanceof ZodCatch$9) {
    return getDiscriminator$9(type._def.innerType);
  } else {
    return [];
  }
};
let ZodDiscriminatedUnion$9 = class ZodDiscriminatedUnion2 extends ZodType$9 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$9.object) {
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.object,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID$9;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator$9(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion2({
      typeName: ZodFirstPartyTypeKind$9.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams$9(params)
    });
  }
};
function mergeValues$9(a, b) {
  const aType = getParsedType$9(a);
  const bType = getParsedType$9(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$9.object && bType === ZodParsedType$9.object) {
    const bKeys = util$9.objectKeys(b);
    const sharedKeys = util$9.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$9(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$9.array && bType === ZodParsedType$9.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$9(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$9.date && bType === ZodParsedType$9.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$9 = class ZodIntersection2 extends ZodType$9 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$9(parsedLeft) || isAborted$9(parsedRight)) {
        return INVALID$9;
      }
      const merged = mergeValues$9(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$9(ctx, {
          code: ZodIssueCode$9.invalid_intersection_types
        });
        return INVALID$9;
      }
      if (isDirty$9(parsedLeft) || isDirty$9(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$9.create = (left, right, params) => {
  return new ZodIntersection$9({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$9.ZodIntersection,
    ...processCreateParams$9(params)
  });
};
let ZodTuple$9 = class ZodTuple2 extends ZodType$9 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$9.array) {
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.array,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$9;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$9(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$9.mergeArray(status, results);
      });
    } else {
      return ParseStatus$9.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple2({
      ...this._def,
      rest
    });
  }
};
ZodTuple$9.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$9({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$9.ZodTuple,
    rest: null,
    ...processCreateParams$9(params)
  });
};
let ZodRecord$9 = class ZodRecord2 extends ZodType$9 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$9.object) {
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.object,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath$9(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath$9(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus$9.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus$9.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType$9) {
      return new ZodRecord2({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind$9.ZodRecord,
        ...processCreateParams$9(third)
      });
    }
    return new ZodRecord2({
      keyType: ZodString$9.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind$9.ZodRecord,
      ...processCreateParams$9(second)
    });
  }
};
let ZodMap$9 = class ZodMap2 extends ZodType$9 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$9.map) {
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.map,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$9(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$9(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$9;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$9;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$9.create = (keyType, valueType, params) => {
  return new ZodMap$9({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$9.ZodMap,
    ...processCreateParams$9(params)
  });
};
let ZodSet$9 = class ZodSet2 extends ZodType$9 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$9.set) {
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.set,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    const def2 = this._def;
    if (def2.minSize !== null) {
      if (ctx.data.size < def2.minSize.value) {
        addIssueToContext$9(ctx, {
          code: ZodIssueCode$9.too_small,
          minimum: def2.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.minSize.message
        });
        status.dirty();
      }
    }
    if (def2.maxSize !== null) {
      if (ctx.data.size > def2.maxSize.value) {
        addIssueToContext$9(ctx, {
          code: ZodIssueCode$9.too_big,
          maximum: def2.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements22) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements22) {
        if (element.status === "aborted")
          return INVALID$9;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements2 = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$9(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements2).then((elements22) => finalizeSet(elements22));
    } else {
      return finalizeSet(elements2);
    }
  }
  min(minSize, message) {
    return new ZodSet2({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$9.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet2({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$9.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$9.create = (valueType, params) => {
  return new ZodSet$9({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$9.ZodSet,
    ...processCreateParams$9(params)
  });
};
let ZodFunction$9 = class ZodFunction2 extends ZodType$9 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$9.function) {
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.function,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    function makeArgsIssue(args, error) {
      return makeIssue$9({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$9(),
          errorMap$9
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$9.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue$9({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$9(),
          errorMap$9
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$9.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise$9) {
      const me = this;
      return OK$9(async function(...args) {
        const error = new ZodError$9([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK$9(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError$9([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError$9([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction2({
      ...this._def,
      args: ZodTuple$9.create(items).rest(ZodUnknown$9.create())
    });
  }
  returns(returnType) {
    return new ZodFunction2({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction2({
      args: args ? args : ZodTuple$9.create([]).rest(ZodUnknown$9.create()),
      returns: returns || ZodUnknown$9.create(),
      typeName: ZodFirstPartyTypeKind$9.ZodFunction,
      ...processCreateParams$9(params)
    });
  }
};
let ZodLazy$9 = class ZodLazy2 extends ZodType$9 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$9.create = (getter, params) => {
  return new ZodLazy$9({
    getter,
    typeName: ZodFirstPartyTypeKind$9.ZodLazy,
    ...processCreateParams$9(params)
  });
};
let ZodLiteral$9 = class ZodLiteral2 extends ZodType$9 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx, {
        received: ctx.data,
        code: ZodIssueCode$9.invalid_literal,
        expected: this._def.value
      });
      return INVALID$9;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$9.create = (value, params) => {
  return new ZodLiteral$9({
    value,
    typeName: ZodFirstPartyTypeKind$9.ZodLiteral,
    ...processCreateParams$9(params)
  });
};
function createZodEnum$9(values, params) {
  return new ZodEnum$9({
    values,
    typeName: ZodFirstPartyTypeKind$9.ZodEnum,
    ...processCreateParams$9(params)
  });
}
let ZodEnum$9 = class ZodEnum2 extends ZodType$9 {
  constructor() {
    super(...arguments);
    _ZodEnum_cache$9.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$9(ctx, {
        expected: util$9.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$9.invalid_type
      });
      return INVALID$9;
    }
    if (!__classPrivateFieldGet$9(this, _ZodEnum_cache$9)) {
      __classPrivateFieldSet$9(this, _ZodEnum_cache$9, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet$9(this, _ZodEnum_cache$9).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$9(ctx, {
        received: ctx.data,
        code: ZodIssueCode$9.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$9;
    }
    return OK$9(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum2.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum2.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache$9 = /* @__PURE__ */ new WeakMap();
ZodEnum$9.create = createZodEnum$9;
let ZodNativeEnum$9 = class ZodNativeEnum2 extends ZodType$9 {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache$9.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util$9.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$9.string && ctx.parsedType !== ZodParsedType$9.number) {
      const expectedValues = util$9.objectValues(nativeEnumValues);
      addIssueToContext$9(ctx, {
        expected: util$9.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$9.invalid_type
      });
      return INVALID$9;
    }
    if (!__classPrivateFieldGet$9(this, _ZodNativeEnum_cache$9)) {
      __classPrivateFieldSet$9(this, _ZodNativeEnum_cache$9, new Set(util$9.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet$9(this, _ZodNativeEnum_cache$9).has(input.data)) {
      const expectedValues = util$9.objectValues(nativeEnumValues);
      addIssueToContext$9(ctx, {
        received: ctx.data,
        code: ZodIssueCode$9.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$9;
    }
    return OK$9(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache$9 = /* @__PURE__ */ new WeakMap();
ZodNativeEnum$9.create = (values, params) => {
  return new ZodNativeEnum$9({
    values,
    typeName: ZodFirstPartyTypeKind$9.ZodNativeEnum,
    ...processCreateParams$9(params)
  });
};
let ZodPromise$9 = class ZodPromise2 extends ZodType$9 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$9.promise && ctx.common.async === false) {
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.promise,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    const promisified = ctx.parsedType === ZodParsedType$9.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$9(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$9.create = (schema, params) => {
  return new ZodPromise$9({
    type: schema,
    typeName: ZodFirstPartyTypeKind$9.ZodPromise,
    ...processCreateParams$9(params)
  });
};
let ZodEffects$9 = class ZodEffects2 extends ZodType$9 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$9.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$9(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$9;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$9;
          if (result.status === "dirty")
            return DIRTY$9(result.value);
          if (status.value === "dirty")
            return DIRTY$9(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$9;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$9;
        if (result.status === "dirty")
          return DIRTY$9(result.value);
        if (status.value === "dirty")
          return DIRTY$9(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$9;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$9;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$9(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$9(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util$9.assertNever(effect);
  }
};
ZodEffects$9.create = (schema, effect, params) => {
  return new ZodEffects$9({
    schema,
    typeName: ZodFirstPartyTypeKind$9.ZodEffects,
    effect,
    ...processCreateParams$9(params)
  });
};
ZodEffects$9.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$9({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$9.ZodEffects,
    ...processCreateParams$9(params)
  });
};
let ZodOptional$9 = class ZodOptional2 extends ZodType$9 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$9.undefined) {
      return OK$9(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$9.create = (type, params) => {
  return new ZodOptional$9({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$9.ZodOptional,
    ...processCreateParams$9(params)
  });
};
let ZodNullable$9 = class ZodNullable2 extends ZodType$9 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$9.null) {
      return OK$9(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$9.create = (type, params) => {
  return new ZodNullable$9({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$9.ZodNullable,
    ...processCreateParams$9(params)
  });
};
let ZodDefault$9 = class ZodDefault2 extends ZodType$9 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$9.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$9.create = (type, params) => {
  return new ZodDefault$9({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$9.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$9(params)
  });
};
let ZodCatch$9 = class ZodCatch2 extends ZodType$9 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$9(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$9(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$9(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$9.create = (type, params) => {
  return new ZodCatch$9({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$9.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$9(params)
  });
};
let ZodNaN$9 = class ZodNaN2 extends ZodType$9 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$9.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$9(ctx, {
        code: ZodIssueCode$9.invalid_type,
        expected: ZodParsedType$9.nan,
        received: ctx.parsedType
      });
      return INVALID$9;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$9.create = (params) => {
  return new ZodNaN$9({
    typeName: ZodFirstPartyTypeKind$9.ZodNaN,
    ...processCreateParams$9(params)
  });
};
const BRAND$9 = Symbol("zod_brand");
let ZodBranded$9 = class ZodBranded2 extends ZodType$9 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$9 = class ZodPipeline2 extends ZodType$9 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$9;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$9(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$9;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline2({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$9.ZodPipeline
    });
  }
};
let ZodReadonly$9 = class ZodReadonly2 extends ZodType$9 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$9(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$9(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$9.create = (type, params) => {
  return new ZodReadonly$9({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$9.ZodReadonly,
    ...processCreateParams$9(params)
  });
};
function cleanParams$9(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom$9(check, _params = {}, fatal) {
  if (check)
    return ZodAny$9.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams$9(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams$9(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny$9.create();
}
const late$9 = {
  object: ZodObject$9.lazycreate
};
var ZodFirstPartyTypeKind$9;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$9 || (ZodFirstPartyTypeKind$9 = {}));
const instanceOfType$9 = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom$9((data) => data instanceof cls, params);
const stringType$9 = ZodString$9.create;
const numberType$9 = ZodNumber$9.create;
const nanType$9 = ZodNaN$9.create;
const bigIntType$9 = ZodBigInt$9.create;
const booleanType$9 = ZodBoolean$9.create;
const dateType$9 = ZodDate$9.create;
const symbolType$9 = ZodSymbol$9.create;
const undefinedType$9 = ZodUndefined$9.create;
const nullType$9 = ZodNull$9.create;
const anyType$9 = ZodAny$9.create;
const unknownType$9 = ZodUnknown$9.create;
const neverType$9 = ZodNever$9.create;
const voidType$9 = ZodVoid$9.create;
const arrayType$9 = ZodArray$9.create;
const objectType$9 = ZodObject$9.create;
const strictObjectType$9 = ZodObject$9.strictCreate;
const unionType$9 = ZodUnion$9.create;
const discriminatedUnionType$9 = ZodDiscriminatedUnion$9.create;
const intersectionType$9 = ZodIntersection$9.create;
const tupleType$9 = ZodTuple$9.create;
const recordType$9 = ZodRecord$9.create;
const mapType$9 = ZodMap$9.create;
const setType$9 = ZodSet$9.create;
const functionType$9 = ZodFunction$9.create;
const lazyType$9 = ZodLazy$9.create;
const literalType$9 = ZodLiteral$9.create;
const enumType$9 = ZodEnum$9.create;
const nativeEnumType$9 = ZodNativeEnum$9.create;
const promiseType$9 = ZodPromise$9.create;
const effectsType$9 = ZodEffects$9.create;
const optionalType$9 = ZodOptional$9.create;
const nullableType$9 = ZodNullable$9.create;
const preprocessType$9 = ZodEffects$9.createWithPreprocess;
const pipelineType$9 = ZodPipeline$9.create;
const ostring$9 = () => stringType$9().optional();
const onumber$9 = () => numberType$9().optional();
const oboolean$9 = () => booleanType$9().optional();
const coerce$9 = {
  string: (arg) => ZodString$9.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber$9.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean$9.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt$9.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate$9.create({ ...arg, coerce: true })
};
const NEVER$9 = INVALID$9;
var z$9 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap$9,
  setErrorMap: setErrorMap$9,
  getErrorMap: getErrorMap$9,
  makeIssue: makeIssue$9,
  EMPTY_PATH: EMPTY_PATH$9,
  addIssueToContext: addIssueToContext$9,
  ParseStatus: ParseStatus$9,
  INVALID: INVALID$9,
  DIRTY: DIRTY$9,
  OK: OK$9,
  isAborted: isAborted$9,
  isDirty: isDirty$9,
  isValid: isValid$9,
  isAsync: isAsync$9,
  get util() {
    return util$9;
  },
  get objectUtil() {
    return objectUtil$9;
  },
  ZodParsedType: ZodParsedType$9,
  getParsedType: getParsedType$9,
  ZodType: ZodType$9,
  datetimeRegex: datetimeRegex$9,
  ZodString: ZodString$9,
  ZodNumber: ZodNumber$9,
  ZodBigInt: ZodBigInt$9,
  ZodBoolean: ZodBoolean$9,
  ZodDate: ZodDate$9,
  ZodSymbol: ZodSymbol$9,
  ZodUndefined: ZodUndefined$9,
  ZodNull: ZodNull$9,
  ZodAny: ZodAny$9,
  ZodUnknown: ZodUnknown$9,
  ZodNever: ZodNever$9,
  ZodVoid: ZodVoid$9,
  ZodArray: ZodArray$9,
  ZodObject: ZodObject$9,
  ZodUnion: ZodUnion$9,
  ZodDiscriminatedUnion: ZodDiscriminatedUnion$9,
  ZodIntersection: ZodIntersection$9,
  ZodTuple: ZodTuple$9,
  ZodRecord: ZodRecord$9,
  ZodMap: ZodMap$9,
  ZodSet: ZodSet$9,
  ZodFunction: ZodFunction$9,
  ZodLazy: ZodLazy$9,
  ZodLiteral: ZodLiteral$9,
  ZodEnum: ZodEnum$9,
  ZodNativeEnum: ZodNativeEnum$9,
  ZodPromise: ZodPromise$9,
  ZodEffects: ZodEffects$9,
  ZodTransformer: ZodEffects$9,
  ZodOptional: ZodOptional$9,
  ZodNullable: ZodNullable$9,
  ZodDefault: ZodDefault$9,
  ZodCatch: ZodCatch$9,
  ZodNaN: ZodNaN$9,
  BRAND: BRAND$9,
  ZodBranded: ZodBranded$9,
  ZodPipeline: ZodPipeline$9,
  ZodReadonly: ZodReadonly$9,
  custom: custom$9,
  Schema: ZodType$9,
  ZodSchema: ZodType$9,
  late: late$9,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind$9;
  },
  coerce: coerce$9,
  any: anyType$9,
  array: arrayType$9,
  bigint: bigIntType$9,
  boolean: booleanType$9,
  date: dateType$9,
  discriminatedUnion: discriminatedUnionType$9,
  effect: effectsType$9,
  "enum": enumType$9,
  "function": functionType$9,
  "instanceof": instanceOfType$9,
  intersection: intersectionType$9,
  lazy: lazyType$9,
  literal: literalType$9,
  map: mapType$9,
  nan: nanType$9,
  nativeEnum: nativeEnumType$9,
  never: neverType$9,
  "null": nullType$9,
  nullable: nullableType$9,
  number: numberType$9,
  object: objectType$9,
  oboolean: oboolean$9,
  onumber: onumber$9,
  optional: optionalType$9,
  ostring: ostring$9,
  pipeline: pipelineType$9,
  preprocess: preprocessType$9,
  promise: promiseType$9,
  record: recordType$9,
  set: setType$9,
  strictObject: strictObjectType$9,
  string: stringType$9,
  symbol: symbolType$9,
  transformer: effectsType$9,
  tuple: tupleType$9,
  "undefined": undefinedType$9,
  union: unionType$9,
  unknown: unknownType$9,
  "void": voidType$9,
  NEVER: NEVER$9,
  ZodIssueCode: ZodIssueCode$9,
  quotelessJson: quotelessJson$9,
  ZodError: ZodError$9
});
const FONT_FAMILIES$3 = [
  {
    key: "MODERN_SANS",
    label: "Modern sans",
    value: '"Helvetica Neue", "Arial Nova", "Nimbus Sans", Arial, sans-serif'
  },
  {
    key: "BOOK_SANS",
    label: "Book sans",
    value: 'Optima, Candara, "Noto Sans", source-sans-pro, sans-serif'
  },
  {
    key: "ORGANIC_SANS",
    label: "Organic sans",
    value: 'Seravek, "Gill Sans Nova", Ubuntu, Calibri, "DejaVu Sans", source-sans-pro, sans-serif'
  },
  {
    key: "GEOMETRIC_SANS",
    label: "Geometric sans",
    value: 'Avenir, "Avenir Next LT Pro", Montserrat, Corbel, "URW Gothic", source-sans-pro, sans-serif'
  },
  {
    key: "HEAVY_SANS",
    label: "Heavy sans",
    value: 'Bahnschrift, "DIN Alternate", "Franklin Gothic Medium", "Nimbus Sans Narrow", sans-serif-condensed, sans-serif'
  },
  {
    key: "ROUNDED_SANS",
    label: "Rounded sans",
    value: 'ui-rounded, "Hiragino Maru Gothic ProN", Quicksand, Comfortaa, Manjari, "Arial Rounded MT Bold", Calibri, source-sans-pro, sans-serif'
  },
  {
    key: "MODERN_SERIF",
    label: "Modern serif",
    value: 'Charter, "Bitstream Charter", "Sitka Text", Cambria, serif'
  },
  {
    key: "BOOK_SERIF",
    label: "Book serif",
    value: '"Iowan Old Style", "Palatino Linotype", "URW Palladio L", P052, serif'
  },
  {
    key: "MONOSPACE",
    label: "Monospace",
    value: '"Nimbus Mono PS", "Courier New", "Cutive Mono", monospace'
  }
];
const FONT_FAMILY_NAMES$8 = [
  "MODERN_SANS",
  "BOOK_SANS",
  "ORGANIC_SANS",
  "GEOMETRIC_SANS",
  "HEAVY_SANS",
  "ROUNDED_SANS",
  "MODERN_SERIF",
  "BOOK_SERIF",
  "MONOSPACE"
];
const PADDING_SCHEMA$7 = z$9.object({
  top: z$9.number(),
  bottom: z$9.number(),
  right: z$9.number(),
  left: z$9.number()
}).optional().nullable();
const COLOR_SCHEMA$7 = z$9.string().regex(/^#[0-9a-fA-F]{6}$/).nullable().optional();
const FONT_FAMILY_SCHEMA$4 = z$9.enum(FONT_FAMILY_NAMES$8).nullable().optional();
function getFontFamily$3(fontFamily) {
  var _a;
  return (_a = FONT_FAMILIES$3.find((f) => f.key === fontFamily)) == null ? void 0 : _a.value;
}
const getPadding$7 = (padding) => padding ? `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px` : void 0;
const _hoisted_1$5 = ["href"];
const _hoisted_2$1 = ["innerHTML"];
const _hoisted_3$1 = ["innerHTML"];
const ButtonPropsDefaults = {
  text: "",
  url: "",
  fullWidth: false,
  size: "medium",
  buttonStyle: "rounded",
  buttonTextColor: "#FFFFFF",
  buttonBackgroundColor: "#999999"
};
const ButtonPropsSchema = z$9.object({
  style: z$9.object({
    backgroundColor: COLOR_SCHEMA$7,
    fontSize: z$9.number().min(0).optional().nullable(),
    fontFamily: FONT_FAMILY_SCHEMA$4,
    fontWeight: z$9.enum(["bold", "normal"]).optional().nullable(),
    textAlign: z$9.enum(["left", "center", "right"]).optional().nullable(),
    padding: PADDING_SCHEMA$7
  }).optional().nullable(),
  props: z$9.object({
    buttonBackgroundColor: COLOR_SCHEMA$7,
    buttonStyle: z$9.enum(["rectangle", "pill", "rounded"]).optional().nullable(),
    buttonTextColor: COLOR_SCHEMA$7,
    fullWidth: z$9.boolean().optional().nullable(),
    size: z$9.enum(["x-small", "small", "large", "medium"]).optional().nullable(),
    text: z$9.string().optional().nullable(),
    url: z$9.string().optional().nullable()
  }).optional().nullable()
});
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    style: {},
    props: {}
  },
  setup(__props) {
    const props = __props;
    const text = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.text) ?? ButtonPropsDefaults.text;
    });
    const url = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.url) ?? ButtonPropsDefaults.url;
    });
    const fullWidth = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.fullWidth) ?? ButtonPropsDefaults.fullWidth;
    });
    const buttonTextColor = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.buttonTextColor) ?? ButtonPropsDefaults.buttonTextColor;
    });
    const buttonBackgroundColor = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.buttonBackgroundColor) ?? ButtonPropsDefaults.buttonBackgroundColor;
    });
    const padding = computed(() => getButtonSizePadding(props.props));
    const textRaise = computed(() => padding.value[1] * 2 * 3 / 4);
    const firstSpan = computed(() => `<!--[if mso]><i style="letter-spacing: ${padding.value[1]}px;mso-font-width:-100%;mso-text-raise:${textRaise.value}" hidden>&nbsp;</i><![endif]-->`);
    const lastSpan = computed(() => `<!--[if mso]><i style="letter-spacing: ${padding.value[1]}px;mso-font-width:-100%" hidden>&nbsp;</i><![endif]-->`);
    const wrapperStyle = computed(() => {
      var _a, _b, _c;
      return {
        backgroundColor: ((_a = props.style) == null ? void 0 : _a.backgroundColor) ?? void 0,
        textAlign: ((_b = props.style) == null ? void 0 : _b.textAlign) ?? void 0,
        padding: getPadding$7((_c = props.style) == null ? void 0 : _c.padding)
      };
    });
    const linkStyle = computed(() => {
      var _a, _b, _c;
      return {
        color: buttonTextColor.value,
        fontSize: (((_a = props.style) == null ? void 0 : _a.fontSize) ?? 16) + "px",
        // FIXME: type
        fontFamily: getFontFamily$3((_b = props.style) == null ? void 0 : _b.fontFamily),
        fontWeight: ((_c = props.style) == null ? void 0 : _c.fontWeight) ?? "bold",
        backgroundColor: buttonBackgroundColor.value,
        borderRadius: getRoundedCorners(props.props),
        display: fullWidth.value ? "block" : "inline-block",
        padding: `${padding.value[0]}px ${padding.value[1]}px`,
        textDecoration: "none"
      };
    });
    function getRoundedCorners(props2) {
      const buttonStyle = (props2 == null ? void 0 : props2.buttonStyle) ?? ButtonPropsDefaults.buttonStyle;
      switch (buttonStyle) {
        case "rectangle":
          return void 0;
        case "pill":
          return "64px";
        case "rounded":
        default:
          return "4px";
      }
    }
    function getButtonSizePadding(props2) {
      const size = (props2 == null ? void 0 : props2.size) ?? ButtonPropsDefaults.size;
      switch (size) {
        case "x-small":
          return [4, 8];
        case "small":
          return [8, 12];
        case "large":
          return [16, 32];
        case "medium":
        default:
          return [12, 20];
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        style: normalizeStyle(wrapperStyle.value)
      }, [
        createElementVNode("a", {
          href: url.value,
          style: normalizeStyle(linkStyle.value),
          target: "_blank"
        }, [
          createElementVNode("span", { innerHTML: firstSpan.value }, null, 8, _hoisted_2$1),
          createElementVNode("span", null, toDisplayString(text.value), 1),
          createElementVNode("span", { innerHTML: lastSpan.value }, null, 8, _hoisted_3$1)
        ], 12, _hoisted_1$5)
      ], 4);
    };
  }
});
/**
 *  Copyright 2025 AntonyDev
 *  @license MIT
**/
var util$8;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$8 || (util$8 = {}));
var objectUtil$8;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$8 || (objectUtil$8 = {}));
const ZodParsedType$8 = util$8.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$8 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$8.undefined;
    case "string":
      return ZodParsedType$8.string;
    case "number":
      return isNaN(data) ? ZodParsedType$8.nan : ZodParsedType$8.number;
    case "boolean":
      return ZodParsedType$8.boolean;
    case "function":
      return ZodParsedType$8.function;
    case "bigint":
      return ZodParsedType$8.bigint;
    case "symbol":
      return ZodParsedType$8.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$8.array;
      }
      if (data === null) {
        return ZodParsedType$8.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$8.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$8.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$8.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$8.date;
      }
      return ZodParsedType$8.object;
    default:
      return ZodParsedType$8.unknown;
  }
};
const ZodIssueCode$8 = util$8.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson$8 = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
let ZodError$8 = class ZodError3 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError3)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$8.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$8.create = (issues) => {
  const error = new ZodError$8(issues);
  return error;
};
const errorMap$8 = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode$8.invalid_type:
      if (issue.received === ZodParsedType$8.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode$8.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$8.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$8.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$8.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode$8.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$8.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$8.joinValues(issue.options)}`;
      break;
    case ZodIssueCode$8.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$8.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode$8.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$8.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$8.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$8.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util$8.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$8.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$8.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$8.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$8.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$8.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode$8.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$8.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap$8 = errorMap$8;
function setErrorMap$8(map) {
  overrideErrorMap$8 = map;
}
function getErrorMap$8() {
  return overrideErrorMap$8;
}
const makeIssue$8 = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH$8 = [];
function addIssueToContext$8(ctx, issueData) {
  const overrideMap = getErrorMap$8();
  const issue = makeIssue$8({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$8 ? void 0 : errorMap$8
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
let ParseStatus$8 = class ParseStatus3 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$8;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus3.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$8;
      if (value.status === "aborted")
        return INVALID$8;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$8 = Object.freeze({
  status: "aborted"
});
const DIRTY$8 = (value) => ({ status: "dirty", value });
const OK$8 = (value) => ({ status: "valid", value });
const isAborted$8 = (x) => x.status === "aborted";
const isDirty$8 = (x) => x.status === "dirty";
const isValid$8 = (x) => x.status === "valid";
const isAsync$8 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet$8(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet$8(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil$8;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil$8 || (errorUtil$8 = {}));
var _ZodEnum_cache$8, _ZodNativeEnum_cache$8;
let ParseInputLazyPath$8 = class ParseInputLazyPath3 {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$8 = (ctx, result) => {
  if (isValid$8(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$8(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$8(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$8 = class ZodType3 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$8(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$8(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$8(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$8(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$8(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$8(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$8(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$8(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$8(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$8(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$8(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$8(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$8(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$8.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$8({
      schema: this,
      typeName: ZodFirstPartyTypeKind$8.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def2) {
    this.spa = this.safeParseAsync;
    this._def = def2;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$8.create(this, this._def);
  }
  nullable() {
    return ZodNullable$8.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$8.create(this);
  }
  promise() {
    return ZodPromise$8.create(this, this._def);
  }
  or(option) {
    return ZodUnion$8.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$8.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects$8({
      ...processCreateParams$8(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$8.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def2) {
    const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodDefault$8({
      ...processCreateParams$8(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$8.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$8({
      typeName: ZodFirstPartyTypeKind$8.ZodBranded,
      type: this,
      ...processCreateParams$8(this._def)
    });
  }
  catch(def2) {
    const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodCatch$8({
      ...processCreateParams$8(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$8.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$8.create(this, target);
  }
  readonly() {
    return ZodReadonly$8.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$8 = /^c[^\s-]{8,}$/i;
const cuid2Regex$8 = /^[0-9a-z]+$/;
const ulidRegex$8 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$8 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$8 = /^[a-z0-9_-]{21}$/i;
const jwtRegex$8 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$8 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$8 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$8 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$8;
const ipv4Regex$8 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$8 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$8 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$8 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$8 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$8 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$8 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$8 = new RegExp(`^${dateRegexSource$8}$`);
function timeRegexSource$8(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex$8(args) {
  return new RegExp(`^${timeRegexSource$8(args)}$`);
}
function datetimeRegex$8(args) {
  let regex = `${dateRegexSource$8}T${timeRegexSource$8(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$8(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex$8.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex$8.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$8(jwt, alg) {
  if (!jwtRegex$8.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr$8(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex$8.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex$8.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$8 = class ZodString3 extends ZodType$8 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx2, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.string,
        received: ctx2.parsedType
      });
      return INVALID$8;
    }
    const status = new ParseStatus$8();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$8(ctx, {
              code: ZodIssueCode$8.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$8(ctx, {
              code: ZodIssueCode$8.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "email",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$8) {
          emojiRegex$8 = new RegExp(_emojiRegex$8, "u");
        }
        if (!emojiRegex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "emoji",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "uuid",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "cuid",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "ulid",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "url",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "regex",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$8(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$8;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$8(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "duration",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$8(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "ip",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$8(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "jwt",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$8(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "cidr",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "base64",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$8.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            validation: "base64url",
            code: ZodIssueCode$8.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$8.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$8.invalid_string,
      ...errorUtil$8.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString3({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$8.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$8.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$8.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$8.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$8.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$8.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$8.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$8.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$8.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$8.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$8.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$8.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$8.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil$8.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil$8.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$8.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$8.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil$8.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$8.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$8.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$8.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$8.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$8.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$8.errToObj(message));
  }
  trim() {
    return new ZodString3({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString3({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString3({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$8.create = (params) => {
  var _a;
  return new ZodString$8({
    checks: [],
    typeName: ZodFirstPartyTypeKind$8.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$8(params)
  });
};
function floatSafeRemainder$8(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
let ZodNumber$8 = class ZodNumber3 extends ZodType$8 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx2, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.number,
        received: ctx2.parsedType
      });
      return INVALID$8;
    }
    let ctx = void 0;
    const status = new ParseStatus$8();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$8.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$8(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$8.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$8.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$8.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$8.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$8.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber3({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$8.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber3({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$8.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$8.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$8.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$8.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$8.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$8.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$8.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$8.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$8.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$8.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$8.create = (params) => {
  return new ZodNumber$8({
    checks: [],
    typeName: ZodFirstPartyTypeKind$8.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$8(params)
  });
};
let ZodBigInt$8 = class ZodBigInt3 extends ZodType$8 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$8();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$8.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$8(ctx, {
      code: ZodIssueCode$8.invalid_type,
      expected: ZodParsedType$8.bigint,
      received: ctx.parsedType
    });
    return INVALID$8;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$8.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$8.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$8.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$8.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt3({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$8.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt3({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$8.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$8.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$8.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$8.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$8.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$8.create = (params) => {
  var _a;
  return new ZodBigInt$8({
    checks: [],
    typeName: ZodFirstPartyTypeKind$8.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$8(params)
  });
};
let ZodBoolean$8 = class ZodBoolean3 extends ZodType$8 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.boolean,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    return OK$8(input.data);
  }
};
ZodBoolean$8.create = (params) => {
  return new ZodBoolean$8({
    typeName: ZodFirstPartyTypeKind$8.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$8(params)
  });
};
let ZodDate$8 = class ZodDate3 extends ZodType$8 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx2, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.date,
        received: ctx2.parsedType
      });
      return INVALID$8;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx2, {
        code: ZodIssueCode$8.invalid_date
      });
      return INVALID$8;
    }
    const status = new ParseStatus$8();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$8.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate3({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$8.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$8.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$8.create = (params) => {
  return new ZodDate$8({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$8.ZodDate,
    ...processCreateParams$8(params)
  });
};
let ZodSymbol$8 = class ZodSymbol3 extends ZodType$8 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.symbol,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    return OK$8(input.data);
  }
};
ZodSymbol$8.create = (params) => {
  return new ZodSymbol$8({
    typeName: ZodFirstPartyTypeKind$8.ZodSymbol,
    ...processCreateParams$8(params)
  });
};
let ZodUndefined$8 = class ZodUndefined3 extends ZodType$8 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.undefined,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    return OK$8(input.data);
  }
};
ZodUndefined$8.create = (params) => {
  return new ZodUndefined$8({
    typeName: ZodFirstPartyTypeKind$8.ZodUndefined,
    ...processCreateParams$8(params)
  });
};
let ZodNull$8 = class ZodNull3 extends ZodType$8 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.null,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    return OK$8(input.data);
  }
};
ZodNull$8.create = (params) => {
  return new ZodNull$8({
    typeName: ZodFirstPartyTypeKind$8.ZodNull,
    ...processCreateParams$8(params)
  });
};
let ZodAny$8 = class ZodAny3 extends ZodType$8 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$8(input.data);
  }
};
ZodAny$8.create = (params) => {
  return new ZodAny$8({
    typeName: ZodFirstPartyTypeKind$8.ZodAny,
    ...processCreateParams$8(params)
  });
};
let ZodUnknown$8 = class ZodUnknown3 extends ZodType$8 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$8(input.data);
  }
};
ZodUnknown$8.create = (params) => {
  return new ZodUnknown$8({
    typeName: ZodFirstPartyTypeKind$8.ZodUnknown,
    ...processCreateParams$8(params)
  });
};
let ZodNever$8 = class ZodNever3 extends ZodType$8 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$8(ctx, {
      code: ZodIssueCode$8.invalid_type,
      expected: ZodParsedType$8.never,
      received: ctx.parsedType
    });
    return INVALID$8;
  }
};
ZodNever$8.create = (params) => {
  return new ZodNever$8({
    typeName: ZodFirstPartyTypeKind$8.ZodNever,
    ...processCreateParams$8(params)
  });
};
let ZodVoid$8 = class ZodVoid3 extends ZodType$8 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.void,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    return OK$8(input.data);
  }
};
ZodVoid$8.create = (params) => {
  return new ZodVoid$8({
    typeName: ZodFirstPartyTypeKind$8.ZodVoid,
    ...processCreateParams$8(params)
  });
};
let ZodArray$8 = class ZodArray3 extends ZodType$8 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def2 = this._def;
    if (ctx.parsedType !== ZodParsedType$8.array) {
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.array,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    if (def2.exactLength !== null) {
      const tooBig = ctx.data.length > def2.exactLength.value;
      const tooSmall = ctx.data.length < def2.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$8(ctx, {
          code: tooBig ? ZodIssueCode$8.too_big : ZodIssueCode$8.too_small,
          minimum: tooSmall ? def2.exactLength.value : void 0,
          maximum: tooBig ? def2.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def2.exactLength.message
        });
        status.dirty();
      }
    }
    if (def2.minLength !== null) {
      if (ctx.data.length < def2.minLength.value) {
        addIssueToContext$8(ctx, {
          code: ZodIssueCode$8.too_small,
          minimum: def2.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.minLength.message
        });
        status.dirty();
      }
    }
    if (def2.maxLength !== null) {
      if (ctx.data.length > def2.maxLength.value) {
        addIssueToContext$8(ctx, {
          code: ZodIssueCode$8.too_big,
          maximum: def2.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def2.type._parseAsync(new ParseInputLazyPath$8(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$8.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def2.type._parseSync(new ParseInputLazyPath$8(ctx, item, ctx.path, i));
    });
    return ParseStatus$8.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray3({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$8.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray3({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$8.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray3({
      ...this._def,
      exactLength: { value: len, message: errorUtil$8.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$8.create = (schema, params) => {
  return new ZodArray$8({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$8.ZodArray,
    ...processCreateParams$8(params)
  });
};
function deepPartialify$8(schema) {
  if (schema instanceof ZodObject$8) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$8.create(deepPartialify$8(fieldSchema));
    }
    return new ZodObject$8({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$8) {
    return new ZodArray$8({
      ...schema._def,
      type: deepPartialify$8(schema.element)
    });
  } else if (schema instanceof ZodOptional$8) {
    return ZodOptional$8.create(deepPartialify$8(schema.unwrap()));
  } else if (schema instanceof ZodNullable$8) {
    return ZodNullable$8.create(deepPartialify$8(schema.unwrap()));
  } else if (schema instanceof ZodTuple$8) {
    return ZodTuple$8.create(schema.items.map((item) => deepPartialify$8(item)));
  } else {
    return schema;
  }
}
let ZodObject$8 = class ZodObject3 extends ZodType$8 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$8.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx2, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.object,
        received: ctx2.parsedType
      });
      return INVALID$8;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$8 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$8(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$8) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$8(ctx, {
            code: ZodIssueCode$8.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$8(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$8.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$8.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$8.errToObj;
    return new ZodObject3({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil$8.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject3({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject3({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject3({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject3({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$8.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject3({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util$8.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject3({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util$8.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject3({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$8(this);
  }
  partial(mask) {
    const newShape = {};
    util$8.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject3({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util$8.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$8) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject3({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$8(util$8.objectKeys(this.shape));
  }
};
ZodObject$8.create = (shape, params) => {
  return new ZodObject$8({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$8.create(),
    typeName: ZodFirstPartyTypeKind$8.ZodObject,
    ...processCreateParams$8(params)
  });
};
ZodObject$8.strictCreate = (shape, params) => {
  return new ZodObject$8({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$8.create(),
    typeName: ZodFirstPartyTypeKind$8.ZodObject,
    ...processCreateParams$8(params)
  });
};
ZodObject$8.lazycreate = (shape, params) => {
  return new ZodObject$8({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$8.create(),
    typeName: ZodFirstPartyTypeKind$8.ZodObject,
    ...processCreateParams$8(params)
  });
};
let ZodUnion$8 = class ZodUnion3 extends ZodType$8 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$8(result.ctx.common.issues));
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_union,
        unionErrors
      });
      return INVALID$8;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$8(issues2));
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_union,
        unionErrors
      });
      return INVALID$8;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$8.create = (types, params) => {
  return new ZodUnion$8({
    options: types,
    typeName: ZodFirstPartyTypeKind$8.ZodUnion,
    ...processCreateParams$8(params)
  });
};
const getDiscriminator$8 = (type) => {
  if (type instanceof ZodLazy$8) {
    return getDiscriminator$8(type.schema);
  } else if (type instanceof ZodEffects$8) {
    return getDiscriminator$8(type.innerType());
  } else if (type instanceof ZodLiteral$8) {
    return [type.value];
  } else if (type instanceof ZodEnum$8) {
    return type.options;
  } else if (type instanceof ZodNativeEnum$8) {
    return util$8.objectValues(type.enum);
  } else if (type instanceof ZodDefault$8) {
    return getDiscriminator$8(type._def.innerType);
  } else if (type instanceof ZodUndefined$8) {
    return [void 0];
  } else if (type instanceof ZodNull$8) {
    return [null];
  } else if (type instanceof ZodOptional$8) {
    return [void 0, ...getDiscriminator$8(type.unwrap())];
  } else if (type instanceof ZodNullable$8) {
    return [null, ...getDiscriminator$8(type.unwrap())];
  } else if (type instanceof ZodBranded$8) {
    return getDiscriminator$8(type.unwrap());
  } else if (type instanceof ZodReadonly$8) {
    return getDiscriminator$8(type.unwrap());
  } else if (type instanceof ZodCatch$8) {
    return getDiscriminator$8(type._def.innerType);
  } else {
    return [];
  }
};
let ZodDiscriminatedUnion$8 = class ZodDiscriminatedUnion3 extends ZodType$8 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$8.object) {
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.object,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID$8;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator$8(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion3({
      typeName: ZodFirstPartyTypeKind$8.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams$8(params)
    });
  }
};
function mergeValues$8(a, b) {
  const aType = getParsedType$8(a);
  const bType = getParsedType$8(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$8.object && bType === ZodParsedType$8.object) {
    const bKeys = util$8.objectKeys(b);
    const sharedKeys = util$8.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$8(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$8.array && bType === ZodParsedType$8.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$8(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$8.date && bType === ZodParsedType$8.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$8 = class ZodIntersection3 extends ZodType$8 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$8(parsedLeft) || isAborted$8(parsedRight)) {
        return INVALID$8;
      }
      const merged = mergeValues$8(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$8(ctx, {
          code: ZodIssueCode$8.invalid_intersection_types
        });
        return INVALID$8;
      }
      if (isDirty$8(parsedLeft) || isDirty$8(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$8.create = (left, right, params) => {
  return new ZodIntersection$8({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$8.ZodIntersection,
    ...processCreateParams$8(params)
  });
};
let ZodTuple$8 = class ZodTuple3 extends ZodType$8 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$8.array) {
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.array,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$8;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$8(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$8.mergeArray(status, results);
      });
    } else {
      return ParseStatus$8.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple3({
      ...this._def,
      rest
    });
  }
};
ZodTuple$8.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$8({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$8.ZodTuple,
    rest: null,
    ...processCreateParams$8(params)
  });
};
let ZodRecord$8 = class ZodRecord3 extends ZodType$8 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$8.object) {
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.object,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath$8(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath$8(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus$8.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus$8.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType$8) {
      return new ZodRecord3({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind$8.ZodRecord,
        ...processCreateParams$8(third)
      });
    }
    return new ZodRecord3({
      keyType: ZodString$8.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind$8.ZodRecord,
      ...processCreateParams$8(second)
    });
  }
};
let ZodMap$8 = class ZodMap3 extends ZodType$8 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$8.map) {
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.map,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$8(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$8(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$8;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$8;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$8.create = (keyType, valueType, params) => {
  return new ZodMap$8({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$8.ZodMap,
    ...processCreateParams$8(params)
  });
};
let ZodSet$8 = class ZodSet3 extends ZodType$8 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$8.set) {
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.set,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    const def2 = this._def;
    if (def2.minSize !== null) {
      if (ctx.data.size < def2.minSize.value) {
        addIssueToContext$8(ctx, {
          code: ZodIssueCode$8.too_small,
          minimum: def2.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.minSize.message
        });
        status.dirty();
      }
    }
    if (def2.maxSize !== null) {
      if (ctx.data.size > def2.maxSize.value) {
        addIssueToContext$8(ctx, {
          code: ZodIssueCode$8.too_big,
          maximum: def2.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements22) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements22) {
        if (element.status === "aborted")
          return INVALID$8;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements2 = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$8(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements2).then((elements22) => finalizeSet(elements22));
    } else {
      return finalizeSet(elements2);
    }
  }
  min(minSize, message) {
    return new ZodSet3({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$8.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet3({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$8.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$8.create = (valueType, params) => {
  return new ZodSet$8({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$8.ZodSet,
    ...processCreateParams$8(params)
  });
};
let ZodFunction$8 = class ZodFunction3 extends ZodType$8 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$8.function) {
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.function,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    function makeArgsIssue(args, error) {
      return makeIssue$8({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$8(),
          errorMap$8
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$8.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue$8({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$8(),
          errorMap$8
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$8.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise$8) {
      const me = this;
      return OK$8(async function(...args) {
        const error = new ZodError$8([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK$8(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError$8([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError$8([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction3({
      ...this._def,
      args: ZodTuple$8.create(items).rest(ZodUnknown$8.create())
    });
  }
  returns(returnType) {
    return new ZodFunction3({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction3({
      args: args ? args : ZodTuple$8.create([]).rest(ZodUnknown$8.create()),
      returns: returns || ZodUnknown$8.create(),
      typeName: ZodFirstPartyTypeKind$8.ZodFunction,
      ...processCreateParams$8(params)
    });
  }
};
let ZodLazy$8 = class ZodLazy3 extends ZodType$8 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$8.create = (getter, params) => {
  return new ZodLazy$8({
    getter,
    typeName: ZodFirstPartyTypeKind$8.ZodLazy,
    ...processCreateParams$8(params)
  });
};
let ZodLiteral$8 = class ZodLiteral3 extends ZodType$8 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx, {
        received: ctx.data,
        code: ZodIssueCode$8.invalid_literal,
        expected: this._def.value
      });
      return INVALID$8;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$8.create = (value, params) => {
  return new ZodLiteral$8({
    value,
    typeName: ZodFirstPartyTypeKind$8.ZodLiteral,
    ...processCreateParams$8(params)
  });
};
function createZodEnum$8(values, params) {
  return new ZodEnum$8({
    values,
    typeName: ZodFirstPartyTypeKind$8.ZodEnum,
    ...processCreateParams$8(params)
  });
}
let ZodEnum$8 = class ZodEnum3 extends ZodType$8 {
  constructor() {
    super(...arguments);
    _ZodEnum_cache$8.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$8(ctx, {
        expected: util$8.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$8.invalid_type
      });
      return INVALID$8;
    }
    if (!__classPrivateFieldGet$8(this, _ZodEnum_cache$8)) {
      __classPrivateFieldSet$8(this, _ZodEnum_cache$8, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet$8(this, _ZodEnum_cache$8).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$8(ctx, {
        received: ctx.data,
        code: ZodIssueCode$8.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$8;
    }
    return OK$8(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum3.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum3.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache$8 = /* @__PURE__ */ new WeakMap();
ZodEnum$8.create = createZodEnum$8;
let ZodNativeEnum$8 = class ZodNativeEnum3 extends ZodType$8 {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache$8.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util$8.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$8.string && ctx.parsedType !== ZodParsedType$8.number) {
      const expectedValues = util$8.objectValues(nativeEnumValues);
      addIssueToContext$8(ctx, {
        expected: util$8.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$8.invalid_type
      });
      return INVALID$8;
    }
    if (!__classPrivateFieldGet$8(this, _ZodNativeEnum_cache$8)) {
      __classPrivateFieldSet$8(this, _ZodNativeEnum_cache$8, new Set(util$8.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet$8(this, _ZodNativeEnum_cache$8).has(input.data)) {
      const expectedValues = util$8.objectValues(nativeEnumValues);
      addIssueToContext$8(ctx, {
        received: ctx.data,
        code: ZodIssueCode$8.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$8;
    }
    return OK$8(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache$8 = /* @__PURE__ */ new WeakMap();
ZodNativeEnum$8.create = (values, params) => {
  return new ZodNativeEnum$8({
    values,
    typeName: ZodFirstPartyTypeKind$8.ZodNativeEnum,
    ...processCreateParams$8(params)
  });
};
let ZodPromise$8 = class ZodPromise3 extends ZodType$8 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$8.promise && ctx.common.async === false) {
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.promise,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    const promisified = ctx.parsedType === ZodParsedType$8.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$8(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$8.create = (schema, params) => {
  return new ZodPromise$8({
    type: schema,
    typeName: ZodFirstPartyTypeKind$8.ZodPromise,
    ...processCreateParams$8(params)
  });
};
let ZodEffects$8 = class ZodEffects3 extends ZodType$8 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$8.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$8(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$8;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$8;
          if (result.status === "dirty")
            return DIRTY$8(result.value);
          if (status.value === "dirty")
            return DIRTY$8(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$8;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$8;
        if (result.status === "dirty")
          return DIRTY$8(result.value);
        if (status.value === "dirty")
          return DIRTY$8(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$8;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$8;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$8(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$8(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util$8.assertNever(effect);
  }
};
ZodEffects$8.create = (schema, effect, params) => {
  return new ZodEffects$8({
    schema,
    typeName: ZodFirstPartyTypeKind$8.ZodEffects,
    effect,
    ...processCreateParams$8(params)
  });
};
ZodEffects$8.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$8({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$8.ZodEffects,
    ...processCreateParams$8(params)
  });
};
let ZodOptional$8 = class ZodOptional3 extends ZodType$8 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$8.undefined) {
      return OK$8(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$8.create = (type, params) => {
  return new ZodOptional$8({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$8.ZodOptional,
    ...processCreateParams$8(params)
  });
};
let ZodNullable$8 = class ZodNullable3 extends ZodType$8 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$8.null) {
      return OK$8(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$8.create = (type, params) => {
  return new ZodNullable$8({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$8.ZodNullable,
    ...processCreateParams$8(params)
  });
};
let ZodDefault$8 = class ZodDefault3 extends ZodType$8 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$8.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$8.create = (type, params) => {
  return new ZodDefault$8({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$8.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$8(params)
  });
};
let ZodCatch$8 = class ZodCatch3 extends ZodType$8 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$8(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$8(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$8(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$8.create = (type, params) => {
  return new ZodCatch$8({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$8.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$8(params)
  });
};
let ZodNaN$8 = class ZodNaN3 extends ZodType$8 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$8.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$8(ctx, {
        code: ZodIssueCode$8.invalid_type,
        expected: ZodParsedType$8.nan,
        received: ctx.parsedType
      });
      return INVALID$8;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$8.create = (params) => {
  return new ZodNaN$8({
    typeName: ZodFirstPartyTypeKind$8.ZodNaN,
    ...processCreateParams$8(params)
  });
};
const BRAND$8 = Symbol("zod_brand");
let ZodBranded$8 = class ZodBranded3 extends ZodType$8 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$8 = class ZodPipeline3 extends ZodType$8 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$8;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$8(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$8;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline3({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$8.ZodPipeline
    });
  }
};
let ZodReadonly$8 = class ZodReadonly3 extends ZodType$8 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$8(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$8(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$8.create = (type, params) => {
  return new ZodReadonly$8({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$8.ZodReadonly,
    ...processCreateParams$8(params)
  });
};
function cleanParams$8(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom$8(check, _params = {}, fatal) {
  if (check)
    return ZodAny$8.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams$8(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams$8(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny$8.create();
}
const late$8 = {
  object: ZodObject$8.lazycreate
};
var ZodFirstPartyTypeKind$8;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$8 || (ZodFirstPartyTypeKind$8 = {}));
const instanceOfType$8 = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom$8((data) => data instanceof cls, params);
const stringType$8 = ZodString$8.create;
const numberType$8 = ZodNumber$8.create;
const nanType$8 = ZodNaN$8.create;
const bigIntType$8 = ZodBigInt$8.create;
const booleanType$8 = ZodBoolean$8.create;
const dateType$8 = ZodDate$8.create;
const symbolType$8 = ZodSymbol$8.create;
const undefinedType$8 = ZodUndefined$8.create;
const nullType$8 = ZodNull$8.create;
const anyType$8 = ZodAny$8.create;
const unknownType$8 = ZodUnknown$8.create;
const neverType$8 = ZodNever$8.create;
const voidType$8 = ZodVoid$8.create;
const arrayType$8 = ZodArray$8.create;
const objectType$8 = ZodObject$8.create;
const strictObjectType$8 = ZodObject$8.strictCreate;
const unionType$8 = ZodUnion$8.create;
const discriminatedUnionType$8 = ZodDiscriminatedUnion$8.create;
const intersectionType$8 = ZodIntersection$8.create;
const tupleType$8 = ZodTuple$8.create;
const recordType$8 = ZodRecord$8.create;
const mapType$8 = ZodMap$8.create;
const setType$8 = ZodSet$8.create;
const functionType$8 = ZodFunction$8.create;
const lazyType$8 = ZodLazy$8.create;
const literalType$8 = ZodLiteral$8.create;
const enumType$8 = ZodEnum$8.create;
const nativeEnumType$8 = ZodNativeEnum$8.create;
const promiseType$8 = ZodPromise$8.create;
const effectsType$8 = ZodEffects$8.create;
const optionalType$8 = ZodOptional$8.create;
const nullableType$8 = ZodNullable$8.create;
const preprocessType$8 = ZodEffects$8.createWithPreprocess;
const pipelineType$8 = ZodPipeline$8.create;
const ostring$8 = () => stringType$8().optional();
const onumber$8 = () => numberType$8().optional();
const oboolean$8 = () => booleanType$8().optional();
const coerce$8 = {
  string: (arg) => ZodString$8.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber$8.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean$8.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt$8.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate$8.create({ ...arg, coerce: true })
};
const NEVER$8 = INVALID$8;
var z$8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap$8,
  setErrorMap: setErrorMap$8,
  getErrorMap: getErrorMap$8,
  makeIssue: makeIssue$8,
  EMPTY_PATH: EMPTY_PATH$8,
  addIssueToContext: addIssueToContext$8,
  ParseStatus: ParseStatus$8,
  INVALID: INVALID$8,
  DIRTY: DIRTY$8,
  OK: OK$8,
  isAborted: isAborted$8,
  isDirty: isDirty$8,
  isValid: isValid$8,
  isAsync: isAsync$8,
  get util() {
    return util$8;
  },
  get objectUtil() {
    return objectUtil$8;
  },
  ZodParsedType: ZodParsedType$8,
  getParsedType: getParsedType$8,
  ZodType: ZodType$8,
  datetimeRegex: datetimeRegex$8,
  ZodString: ZodString$8,
  ZodNumber: ZodNumber$8,
  ZodBigInt: ZodBigInt$8,
  ZodBoolean: ZodBoolean$8,
  ZodDate: ZodDate$8,
  ZodSymbol: ZodSymbol$8,
  ZodUndefined: ZodUndefined$8,
  ZodNull: ZodNull$8,
  ZodAny: ZodAny$8,
  ZodUnknown: ZodUnknown$8,
  ZodNever: ZodNever$8,
  ZodVoid: ZodVoid$8,
  ZodArray: ZodArray$8,
  ZodObject: ZodObject$8,
  ZodUnion: ZodUnion$8,
  ZodDiscriminatedUnion: ZodDiscriminatedUnion$8,
  ZodIntersection: ZodIntersection$8,
  ZodTuple: ZodTuple$8,
  ZodRecord: ZodRecord$8,
  ZodMap: ZodMap$8,
  ZodSet: ZodSet$8,
  ZodFunction: ZodFunction$8,
  ZodLazy: ZodLazy$8,
  ZodLiteral: ZodLiteral$8,
  ZodEnum: ZodEnum$8,
  ZodNativeEnum: ZodNativeEnum$8,
  ZodPromise: ZodPromise$8,
  ZodEffects: ZodEffects$8,
  ZodTransformer: ZodEffects$8,
  ZodOptional: ZodOptional$8,
  ZodNullable: ZodNullable$8,
  ZodDefault: ZodDefault$8,
  ZodCatch: ZodCatch$8,
  ZodNaN: ZodNaN$8,
  BRAND: BRAND$8,
  ZodBranded: ZodBranded$8,
  ZodPipeline: ZodPipeline$8,
  ZodReadonly: ZodReadonly$8,
  custom: custom$8,
  Schema: ZodType$8,
  ZodSchema: ZodType$8,
  late: late$8,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind$8;
  },
  coerce: coerce$8,
  any: anyType$8,
  array: arrayType$8,
  bigint: bigIntType$8,
  boolean: booleanType$8,
  date: dateType$8,
  discriminatedUnion: discriminatedUnionType$8,
  effect: effectsType$8,
  "enum": enumType$8,
  "function": functionType$8,
  "instanceof": instanceOfType$8,
  intersection: intersectionType$8,
  lazy: lazyType$8,
  literal: literalType$8,
  map: mapType$8,
  nan: nanType$8,
  nativeEnum: nativeEnumType$8,
  never: neverType$8,
  "null": nullType$8,
  nullable: nullableType$8,
  number: numberType$8,
  object: objectType$8,
  oboolean: oboolean$8,
  onumber: onumber$8,
  optional: optionalType$8,
  ostring: ostring$8,
  pipeline: pipelineType$8,
  preprocess: preprocessType$8,
  promise: promiseType$8,
  record: recordType$8,
  set: setType$8,
  strictObject: strictObjectType$8,
  string: stringType$8,
  symbol: symbolType$8,
  transformer: effectsType$8,
  tuple: tupleType$8,
  "undefined": undefinedType$8,
  union: unionType$8,
  unknown: unknownType$8,
  "void": voidType$8,
  NEVER: NEVER$8,
  ZodIssueCode: ZodIssueCode$8,
  quotelessJson: quotelessJson$8,
  ZodError: ZodError$8
});
const FONT_FAMILY_NAMES$7 = [
  "MODERN_SANS",
  "BOOK_SANS",
  "ORGANIC_SANS",
  "GEOMETRIC_SANS",
  "HEAVY_SANS",
  "ROUNDED_SANS",
  "MODERN_SERIF",
  "BOOK_SERIF",
  "MONOSPACE"
];
const PADDING_SCHEMA$6 = z$8.object({
  top: z$8.number(),
  bottom: z$8.number(),
  right: z$8.number(),
  left: z$8.number()
}).optional().nullable();
const COLOR_SCHEMA$6 = z$8.string().regex(/^#[0-9a-fA-F]{6}$/).nullable().optional();
z$8.enum(FONT_FAMILY_NAMES$7).nullable().optional();
const getPadding$6 = (padding) => padding ? `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px` : void 0;
const DividerPropsSchema = z$8.object({
  style: z$8.object({
    backgroundColor: COLOR_SCHEMA$6,
    padding: PADDING_SCHEMA$6
  }).optional().nullable(),
  props: z$8.object({
    lineColor: COLOR_SCHEMA$6,
    lineHeight: z$8.number().optional().nullable()
  }).optional().nullable()
});
const DividerPropsDefaults = {
  lineHeight: 1,
  lineColor: "#333333"
};
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    style: {},
    props: {}
  },
  setup(__props) {
    const props = __props;
    const borderTopWidth = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.lineHeight) ?? DividerPropsDefaults.lineHeight;
    });
    const borderTopColor = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.lineColor) ?? DividerPropsDefaults.lineColor;
    });
    const st = computed(() => {
      var _a, _b;
      return {
        padding: getPadding$6((_a = props.style) == null ? void 0 : _a.padding),
        backgroundColor: ((_b = props.style) == null ? void 0 : _b.backgroundColor) ?? void 0
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        style: normalizeStyle(st.value)
      }, [
        createElementVNode("hr", {
          style: normalizeStyle({
            width: "100%",
            border: "none",
            borderTop: `${borderTopWidth.value}px solid ${borderTopColor.value}`,
            margin: "0"
          })
        }, null, 4)
      ], 4);
    };
  }
});
/**
 *  Copyright 2025 AntonyDev
 *  @license MIT
**/
var util$7;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$7 || (util$7 = {}));
var objectUtil$7;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$7 || (objectUtil$7 = {}));
const ZodParsedType$7 = util$7.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$7 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$7.undefined;
    case "string":
      return ZodParsedType$7.string;
    case "number":
      return isNaN(data) ? ZodParsedType$7.nan : ZodParsedType$7.number;
    case "boolean":
      return ZodParsedType$7.boolean;
    case "function":
      return ZodParsedType$7.function;
    case "bigint":
      return ZodParsedType$7.bigint;
    case "symbol":
      return ZodParsedType$7.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$7.array;
      }
      if (data === null) {
        return ZodParsedType$7.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$7.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$7.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$7.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$7.date;
      }
      return ZodParsedType$7.object;
    default:
      return ZodParsedType$7.unknown;
  }
};
const ZodIssueCode$7 = util$7.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson$7 = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
let ZodError$7 = class ZodError4 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError4)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$7.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$7.create = (issues) => {
  const error = new ZodError$7(issues);
  return error;
};
const errorMap$7 = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode$7.invalid_type:
      if (issue.received === ZodParsedType$7.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode$7.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$7.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$7.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$7.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode$7.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$7.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$7.joinValues(issue.options)}`;
      break;
    case ZodIssueCode$7.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$7.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode$7.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$7.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$7.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$7.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util$7.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$7.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$7.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$7.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$7.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$7.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode$7.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$7.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap$7 = errorMap$7;
function setErrorMap$7(map) {
  overrideErrorMap$7 = map;
}
function getErrorMap$7() {
  return overrideErrorMap$7;
}
const makeIssue$7 = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH$7 = [];
function addIssueToContext$7(ctx, issueData) {
  const overrideMap = getErrorMap$7();
  const issue = makeIssue$7({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$7 ? void 0 : errorMap$7
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
let ParseStatus$7 = class ParseStatus4 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$7;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus4.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$7;
      if (value.status === "aborted")
        return INVALID$7;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$7 = Object.freeze({
  status: "aborted"
});
const DIRTY$7 = (value) => ({ status: "dirty", value });
const OK$7 = (value) => ({ status: "valid", value });
const isAborted$7 = (x) => x.status === "aborted";
const isDirty$7 = (x) => x.status === "dirty";
const isValid$7 = (x) => x.status === "valid";
const isAsync$7 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet$7(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet$7(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil$7;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil$7 || (errorUtil$7 = {}));
var _ZodEnum_cache$7, _ZodNativeEnum_cache$7;
let ParseInputLazyPath$7 = class ParseInputLazyPath4 {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$7 = (ctx, result) => {
  if (isValid$7(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$7(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$7(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$7 = class ZodType4 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$7(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$7(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$7(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$7(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$7(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$7(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$7(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$7(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$7(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$7(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$7(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$7(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$7(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$7.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$7({
      schema: this,
      typeName: ZodFirstPartyTypeKind$7.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def2) {
    this.spa = this.safeParseAsync;
    this._def = def2;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$7.create(this, this._def);
  }
  nullable() {
    return ZodNullable$7.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$7.create(this);
  }
  promise() {
    return ZodPromise$7.create(this, this._def);
  }
  or(option) {
    return ZodUnion$7.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$7.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects$7({
      ...processCreateParams$7(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$7.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def2) {
    const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodDefault$7({
      ...processCreateParams$7(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$7.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$7({
      typeName: ZodFirstPartyTypeKind$7.ZodBranded,
      type: this,
      ...processCreateParams$7(this._def)
    });
  }
  catch(def2) {
    const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodCatch$7({
      ...processCreateParams$7(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$7.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$7.create(this, target);
  }
  readonly() {
    return ZodReadonly$7.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$7 = /^c[^\s-]{8,}$/i;
const cuid2Regex$7 = /^[0-9a-z]+$/;
const ulidRegex$7 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$7 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$7 = /^[a-z0-9_-]{21}$/i;
const jwtRegex$7 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$7 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$7 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$7 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$7;
const ipv4Regex$7 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$7 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$7 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$7 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$7 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$7 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$7 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$7 = new RegExp(`^${dateRegexSource$7}$`);
function timeRegexSource$7(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex$7(args) {
  return new RegExp(`^${timeRegexSource$7(args)}$`);
}
function datetimeRegex$7(args) {
  let regex = `${dateRegexSource$7}T${timeRegexSource$7(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$7(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex$7.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex$7.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$7(jwt, alg) {
  if (!jwtRegex$7.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr$7(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex$7.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex$7.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$7 = class ZodString4 extends ZodType$7 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx2, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.string,
        received: ctx2.parsedType
      });
      return INVALID$7;
    }
    const status = new ParseStatus$7();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$7(ctx, {
              code: ZodIssueCode$7.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$7(ctx, {
              code: ZodIssueCode$7.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "email",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$7) {
          emojiRegex$7 = new RegExp(_emojiRegex$7, "u");
        }
        if (!emojiRegex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "emoji",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "uuid",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "cuid",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "ulid",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "url",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "regex",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$7(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$7;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$7(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "duration",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$7(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "ip",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$7(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "jwt",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$7(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "cidr",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "base64",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$7.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            validation: "base64url",
            code: ZodIssueCode$7.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$7.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$7.invalid_string,
      ...errorUtil$7.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString4({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$7.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$7.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$7.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$7.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$7.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$7.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$7.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$7.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$7.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$7.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$7.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$7.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$7.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil$7.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil$7.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$7.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$7.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil$7.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$7.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$7.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$7.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$7.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$7.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$7.errToObj(message));
  }
  trim() {
    return new ZodString4({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString4({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString4({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$7.create = (params) => {
  var _a;
  return new ZodString$7({
    checks: [],
    typeName: ZodFirstPartyTypeKind$7.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$7(params)
  });
};
function floatSafeRemainder$7(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
let ZodNumber$7 = class ZodNumber4 extends ZodType$7 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx2, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.number,
        received: ctx2.parsedType
      });
      return INVALID$7;
    }
    let ctx = void 0;
    const status = new ParseStatus$7();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$7.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$7(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$7.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$7.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$7.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$7.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$7.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber4({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$7.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber4({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$7.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$7.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$7.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$7.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$7.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$7.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$7.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$7.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$7.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$7.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$7.create = (params) => {
  return new ZodNumber$7({
    checks: [],
    typeName: ZodFirstPartyTypeKind$7.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$7(params)
  });
};
let ZodBigInt$7 = class ZodBigInt4 extends ZodType$7 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$7();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$7.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$7(ctx, {
      code: ZodIssueCode$7.invalid_type,
      expected: ZodParsedType$7.bigint,
      received: ctx.parsedType
    });
    return INVALID$7;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$7.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$7.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$7.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$7.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt4({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$7.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt4({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$7.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$7.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$7.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$7.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$7.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$7.create = (params) => {
  var _a;
  return new ZodBigInt$7({
    checks: [],
    typeName: ZodFirstPartyTypeKind$7.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$7(params)
  });
};
let ZodBoolean$7 = class ZodBoolean4 extends ZodType$7 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.boolean,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    return OK$7(input.data);
  }
};
ZodBoolean$7.create = (params) => {
  return new ZodBoolean$7({
    typeName: ZodFirstPartyTypeKind$7.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$7(params)
  });
};
let ZodDate$7 = class ZodDate4 extends ZodType$7 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx2, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.date,
        received: ctx2.parsedType
      });
      return INVALID$7;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx2, {
        code: ZodIssueCode$7.invalid_date
      });
      return INVALID$7;
    }
    const status = new ParseStatus$7();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$7.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate4({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$7.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$7.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$7.create = (params) => {
  return new ZodDate$7({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$7.ZodDate,
    ...processCreateParams$7(params)
  });
};
let ZodSymbol$7 = class ZodSymbol4 extends ZodType$7 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.symbol,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    return OK$7(input.data);
  }
};
ZodSymbol$7.create = (params) => {
  return new ZodSymbol$7({
    typeName: ZodFirstPartyTypeKind$7.ZodSymbol,
    ...processCreateParams$7(params)
  });
};
let ZodUndefined$7 = class ZodUndefined4 extends ZodType$7 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.undefined,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    return OK$7(input.data);
  }
};
ZodUndefined$7.create = (params) => {
  return new ZodUndefined$7({
    typeName: ZodFirstPartyTypeKind$7.ZodUndefined,
    ...processCreateParams$7(params)
  });
};
let ZodNull$7 = class ZodNull4 extends ZodType$7 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.null,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    return OK$7(input.data);
  }
};
ZodNull$7.create = (params) => {
  return new ZodNull$7({
    typeName: ZodFirstPartyTypeKind$7.ZodNull,
    ...processCreateParams$7(params)
  });
};
let ZodAny$7 = class ZodAny4 extends ZodType$7 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$7(input.data);
  }
};
ZodAny$7.create = (params) => {
  return new ZodAny$7({
    typeName: ZodFirstPartyTypeKind$7.ZodAny,
    ...processCreateParams$7(params)
  });
};
let ZodUnknown$7 = class ZodUnknown4 extends ZodType$7 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$7(input.data);
  }
};
ZodUnknown$7.create = (params) => {
  return new ZodUnknown$7({
    typeName: ZodFirstPartyTypeKind$7.ZodUnknown,
    ...processCreateParams$7(params)
  });
};
let ZodNever$7 = class ZodNever4 extends ZodType$7 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$7(ctx, {
      code: ZodIssueCode$7.invalid_type,
      expected: ZodParsedType$7.never,
      received: ctx.parsedType
    });
    return INVALID$7;
  }
};
ZodNever$7.create = (params) => {
  return new ZodNever$7({
    typeName: ZodFirstPartyTypeKind$7.ZodNever,
    ...processCreateParams$7(params)
  });
};
let ZodVoid$7 = class ZodVoid4 extends ZodType$7 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.void,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    return OK$7(input.data);
  }
};
ZodVoid$7.create = (params) => {
  return new ZodVoid$7({
    typeName: ZodFirstPartyTypeKind$7.ZodVoid,
    ...processCreateParams$7(params)
  });
};
let ZodArray$7 = class ZodArray4 extends ZodType$7 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def2 = this._def;
    if (ctx.parsedType !== ZodParsedType$7.array) {
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.array,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    if (def2.exactLength !== null) {
      const tooBig = ctx.data.length > def2.exactLength.value;
      const tooSmall = ctx.data.length < def2.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$7(ctx, {
          code: tooBig ? ZodIssueCode$7.too_big : ZodIssueCode$7.too_small,
          minimum: tooSmall ? def2.exactLength.value : void 0,
          maximum: tooBig ? def2.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def2.exactLength.message
        });
        status.dirty();
      }
    }
    if (def2.minLength !== null) {
      if (ctx.data.length < def2.minLength.value) {
        addIssueToContext$7(ctx, {
          code: ZodIssueCode$7.too_small,
          minimum: def2.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.minLength.message
        });
        status.dirty();
      }
    }
    if (def2.maxLength !== null) {
      if (ctx.data.length > def2.maxLength.value) {
        addIssueToContext$7(ctx, {
          code: ZodIssueCode$7.too_big,
          maximum: def2.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def2.type._parseAsync(new ParseInputLazyPath$7(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$7.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def2.type._parseSync(new ParseInputLazyPath$7(ctx, item, ctx.path, i));
    });
    return ParseStatus$7.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray4({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$7.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray4({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$7.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray4({
      ...this._def,
      exactLength: { value: len, message: errorUtil$7.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$7.create = (schema, params) => {
  return new ZodArray$7({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$7.ZodArray,
    ...processCreateParams$7(params)
  });
};
function deepPartialify$7(schema) {
  if (schema instanceof ZodObject$7) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$7.create(deepPartialify$7(fieldSchema));
    }
    return new ZodObject$7({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$7) {
    return new ZodArray$7({
      ...schema._def,
      type: deepPartialify$7(schema.element)
    });
  } else if (schema instanceof ZodOptional$7) {
    return ZodOptional$7.create(deepPartialify$7(schema.unwrap()));
  } else if (schema instanceof ZodNullable$7) {
    return ZodNullable$7.create(deepPartialify$7(schema.unwrap()));
  } else if (schema instanceof ZodTuple$7) {
    return ZodTuple$7.create(schema.items.map((item) => deepPartialify$7(item)));
  } else {
    return schema;
  }
}
let ZodObject$7 = class ZodObject4 extends ZodType$7 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$7.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx2, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.object,
        received: ctx2.parsedType
      });
      return INVALID$7;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$7 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$7(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$7) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$7(ctx, {
            code: ZodIssueCode$7.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$7(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$7.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$7.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$7.errToObj;
    return new ZodObject4({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil$7.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject4({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject4({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject4({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject4({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$7.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject4({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util$7.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject4({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util$7.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject4({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$7(this);
  }
  partial(mask) {
    const newShape = {};
    util$7.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject4({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util$7.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$7) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject4({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$7(util$7.objectKeys(this.shape));
  }
};
ZodObject$7.create = (shape, params) => {
  return new ZodObject$7({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$7.create(),
    typeName: ZodFirstPartyTypeKind$7.ZodObject,
    ...processCreateParams$7(params)
  });
};
ZodObject$7.strictCreate = (shape, params) => {
  return new ZodObject$7({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$7.create(),
    typeName: ZodFirstPartyTypeKind$7.ZodObject,
    ...processCreateParams$7(params)
  });
};
ZodObject$7.lazycreate = (shape, params) => {
  return new ZodObject$7({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$7.create(),
    typeName: ZodFirstPartyTypeKind$7.ZodObject,
    ...processCreateParams$7(params)
  });
};
let ZodUnion$7 = class ZodUnion4 extends ZodType$7 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$7(result.ctx.common.issues));
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_union,
        unionErrors
      });
      return INVALID$7;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$7(issues2));
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_union,
        unionErrors
      });
      return INVALID$7;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$7.create = (types, params) => {
  return new ZodUnion$7({
    options: types,
    typeName: ZodFirstPartyTypeKind$7.ZodUnion,
    ...processCreateParams$7(params)
  });
};
const getDiscriminator$7 = (type) => {
  if (type instanceof ZodLazy$7) {
    return getDiscriminator$7(type.schema);
  } else if (type instanceof ZodEffects$7) {
    return getDiscriminator$7(type.innerType());
  } else if (type instanceof ZodLiteral$7) {
    return [type.value];
  } else if (type instanceof ZodEnum$7) {
    return type.options;
  } else if (type instanceof ZodNativeEnum$7) {
    return util$7.objectValues(type.enum);
  } else if (type instanceof ZodDefault$7) {
    return getDiscriminator$7(type._def.innerType);
  } else if (type instanceof ZodUndefined$7) {
    return [void 0];
  } else if (type instanceof ZodNull$7) {
    return [null];
  } else if (type instanceof ZodOptional$7) {
    return [void 0, ...getDiscriminator$7(type.unwrap())];
  } else if (type instanceof ZodNullable$7) {
    return [null, ...getDiscriminator$7(type.unwrap())];
  } else if (type instanceof ZodBranded$7) {
    return getDiscriminator$7(type.unwrap());
  } else if (type instanceof ZodReadonly$7) {
    return getDiscriminator$7(type.unwrap());
  } else if (type instanceof ZodCatch$7) {
    return getDiscriminator$7(type._def.innerType);
  } else {
    return [];
  }
};
let ZodDiscriminatedUnion$7 = class ZodDiscriminatedUnion4 extends ZodType$7 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$7.object) {
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.object,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID$7;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator$7(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion4({
      typeName: ZodFirstPartyTypeKind$7.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams$7(params)
    });
  }
};
function mergeValues$7(a, b) {
  const aType = getParsedType$7(a);
  const bType = getParsedType$7(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$7.object && bType === ZodParsedType$7.object) {
    const bKeys = util$7.objectKeys(b);
    const sharedKeys = util$7.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$7(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$7.array && bType === ZodParsedType$7.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$7(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$7.date && bType === ZodParsedType$7.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$7 = class ZodIntersection4 extends ZodType$7 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$7(parsedLeft) || isAborted$7(parsedRight)) {
        return INVALID$7;
      }
      const merged = mergeValues$7(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$7(ctx, {
          code: ZodIssueCode$7.invalid_intersection_types
        });
        return INVALID$7;
      }
      if (isDirty$7(parsedLeft) || isDirty$7(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$7.create = (left, right, params) => {
  return new ZodIntersection$7({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$7.ZodIntersection,
    ...processCreateParams$7(params)
  });
};
let ZodTuple$7 = class ZodTuple4 extends ZodType$7 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$7.array) {
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.array,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$7;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$7(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$7.mergeArray(status, results);
      });
    } else {
      return ParseStatus$7.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple4({
      ...this._def,
      rest
    });
  }
};
ZodTuple$7.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$7({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$7.ZodTuple,
    rest: null,
    ...processCreateParams$7(params)
  });
};
let ZodRecord$7 = class ZodRecord4 extends ZodType$7 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$7.object) {
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.object,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath$7(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath$7(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus$7.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus$7.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType$7) {
      return new ZodRecord4({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind$7.ZodRecord,
        ...processCreateParams$7(third)
      });
    }
    return new ZodRecord4({
      keyType: ZodString$7.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind$7.ZodRecord,
      ...processCreateParams$7(second)
    });
  }
};
let ZodMap$7 = class ZodMap4 extends ZodType$7 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$7.map) {
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.map,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$7(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$7(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$7;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$7;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$7.create = (keyType, valueType, params) => {
  return new ZodMap$7({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$7.ZodMap,
    ...processCreateParams$7(params)
  });
};
let ZodSet$7 = class ZodSet4 extends ZodType$7 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$7.set) {
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.set,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    const def2 = this._def;
    if (def2.minSize !== null) {
      if (ctx.data.size < def2.minSize.value) {
        addIssueToContext$7(ctx, {
          code: ZodIssueCode$7.too_small,
          minimum: def2.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.minSize.message
        });
        status.dirty();
      }
    }
    if (def2.maxSize !== null) {
      if (ctx.data.size > def2.maxSize.value) {
        addIssueToContext$7(ctx, {
          code: ZodIssueCode$7.too_big,
          maximum: def2.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements22) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements22) {
        if (element.status === "aborted")
          return INVALID$7;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements2 = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$7(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements2).then((elements22) => finalizeSet(elements22));
    } else {
      return finalizeSet(elements2);
    }
  }
  min(minSize, message) {
    return new ZodSet4({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$7.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet4({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$7.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$7.create = (valueType, params) => {
  return new ZodSet$7({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$7.ZodSet,
    ...processCreateParams$7(params)
  });
};
let ZodFunction$7 = class ZodFunction4 extends ZodType$7 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$7.function) {
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.function,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    function makeArgsIssue(args, error) {
      return makeIssue$7({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$7(),
          errorMap$7
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$7.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue$7({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$7(),
          errorMap$7
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$7.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise$7) {
      const me = this;
      return OK$7(async function(...args) {
        const error = new ZodError$7([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK$7(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError$7([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError$7([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction4({
      ...this._def,
      args: ZodTuple$7.create(items).rest(ZodUnknown$7.create())
    });
  }
  returns(returnType) {
    return new ZodFunction4({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction4({
      args: args ? args : ZodTuple$7.create([]).rest(ZodUnknown$7.create()),
      returns: returns || ZodUnknown$7.create(),
      typeName: ZodFirstPartyTypeKind$7.ZodFunction,
      ...processCreateParams$7(params)
    });
  }
};
let ZodLazy$7 = class ZodLazy4 extends ZodType$7 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$7.create = (getter, params) => {
  return new ZodLazy$7({
    getter,
    typeName: ZodFirstPartyTypeKind$7.ZodLazy,
    ...processCreateParams$7(params)
  });
};
let ZodLiteral$7 = class ZodLiteral4 extends ZodType$7 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx, {
        received: ctx.data,
        code: ZodIssueCode$7.invalid_literal,
        expected: this._def.value
      });
      return INVALID$7;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$7.create = (value, params) => {
  return new ZodLiteral$7({
    value,
    typeName: ZodFirstPartyTypeKind$7.ZodLiteral,
    ...processCreateParams$7(params)
  });
};
function createZodEnum$7(values, params) {
  return new ZodEnum$7({
    values,
    typeName: ZodFirstPartyTypeKind$7.ZodEnum,
    ...processCreateParams$7(params)
  });
}
let ZodEnum$7 = class ZodEnum4 extends ZodType$7 {
  constructor() {
    super(...arguments);
    _ZodEnum_cache$7.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$7(ctx, {
        expected: util$7.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$7.invalid_type
      });
      return INVALID$7;
    }
    if (!__classPrivateFieldGet$7(this, _ZodEnum_cache$7)) {
      __classPrivateFieldSet$7(this, _ZodEnum_cache$7, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet$7(this, _ZodEnum_cache$7).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$7(ctx, {
        received: ctx.data,
        code: ZodIssueCode$7.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$7;
    }
    return OK$7(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum4.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum4.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache$7 = /* @__PURE__ */ new WeakMap();
ZodEnum$7.create = createZodEnum$7;
let ZodNativeEnum$7 = class ZodNativeEnum4 extends ZodType$7 {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache$7.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util$7.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$7.string && ctx.parsedType !== ZodParsedType$7.number) {
      const expectedValues = util$7.objectValues(nativeEnumValues);
      addIssueToContext$7(ctx, {
        expected: util$7.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$7.invalid_type
      });
      return INVALID$7;
    }
    if (!__classPrivateFieldGet$7(this, _ZodNativeEnum_cache$7)) {
      __classPrivateFieldSet$7(this, _ZodNativeEnum_cache$7, new Set(util$7.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet$7(this, _ZodNativeEnum_cache$7).has(input.data)) {
      const expectedValues = util$7.objectValues(nativeEnumValues);
      addIssueToContext$7(ctx, {
        received: ctx.data,
        code: ZodIssueCode$7.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$7;
    }
    return OK$7(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache$7 = /* @__PURE__ */ new WeakMap();
ZodNativeEnum$7.create = (values, params) => {
  return new ZodNativeEnum$7({
    values,
    typeName: ZodFirstPartyTypeKind$7.ZodNativeEnum,
    ...processCreateParams$7(params)
  });
};
let ZodPromise$7 = class ZodPromise4 extends ZodType$7 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$7.promise && ctx.common.async === false) {
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.promise,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    const promisified = ctx.parsedType === ZodParsedType$7.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$7(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$7.create = (schema, params) => {
  return new ZodPromise$7({
    type: schema,
    typeName: ZodFirstPartyTypeKind$7.ZodPromise,
    ...processCreateParams$7(params)
  });
};
let ZodEffects$7 = class ZodEffects4 extends ZodType$7 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$7.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$7(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$7;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$7;
          if (result.status === "dirty")
            return DIRTY$7(result.value);
          if (status.value === "dirty")
            return DIRTY$7(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$7;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$7;
        if (result.status === "dirty")
          return DIRTY$7(result.value);
        if (status.value === "dirty")
          return DIRTY$7(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$7;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$7;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$7(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$7(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util$7.assertNever(effect);
  }
};
ZodEffects$7.create = (schema, effect, params) => {
  return new ZodEffects$7({
    schema,
    typeName: ZodFirstPartyTypeKind$7.ZodEffects,
    effect,
    ...processCreateParams$7(params)
  });
};
ZodEffects$7.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$7({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$7.ZodEffects,
    ...processCreateParams$7(params)
  });
};
let ZodOptional$7 = class ZodOptional4 extends ZodType$7 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$7.undefined) {
      return OK$7(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$7.create = (type, params) => {
  return new ZodOptional$7({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$7.ZodOptional,
    ...processCreateParams$7(params)
  });
};
let ZodNullable$7 = class ZodNullable4 extends ZodType$7 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$7.null) {
      return OK$7(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$7.create = (type, params) => {
  return new ZodNullable$7({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$7.ZodNullable,
    ...processCreateParams$7(params)
  });
};
let ZodDefault$7 = class ZodDefault4 extends ZodType$7 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$7.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$7.create = (type, params) => {
  return new ZodDefault$7({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$7.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$7(params)
  });
};
let ZodCatch$7 = class ZodCatch4 extends ZodType$7 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$7(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$7(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$7(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$7.create = (type, params) => {
  return new ZodCatch$7({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$7.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$7(params)
  });
};
let ZodNaN$7 = class ZodNaN4 extends ZodType$7 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$7.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$7(ctx, {
        code: ZodIssueCode$7.invalid_type,
        expected: ZodParsedType$7.nan,
        received: ctx.parsedType
      });
      return INVALID$7;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$7.create = (params) => {
  return new ZodNaN$7({
    typeName: ZodFirstPartyTypeKind$7.ZodNaN,
    ...processCreateParams$7(params)
  });
};
const BRAND$7 = Symbol("zod_brand");
let ZodBranded$7 = class ZodBranded4 extends ZodType$7 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$7 = class ZodPipeline4 extends ZodType$7 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$7;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$7(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$7;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline4({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$7.ZodPipeline
    });
  }
};
let ZodReadonly$7 = class ZodReadonly4 extends ZodType$7 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$7(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$7(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$7.create = (type, params) => {
  return new ZodReadonly$7({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$7.ZodReadonly,
    ...processCreateParams$7(params)
  });
};
function cleanParams$7(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom$7(check, _params = {}, fatal) {
  if (check)
    return ZodAny$7.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams$7(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams$7(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny$7.create();
}
const late$7 = {
  object: ZodObject$7.lazycreate
};
var ZodFirstPartyTypeKind$7;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$7 || (ZodFirstPartyTypeKind$7 = {}));
const instanceOfType$7 = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom$7((data) => data instanceof cls, params);
const stringType$7 = ZodString$7.create;
const numberType$7 = ZodNumber$7.create;
const nanType$7 = ZodNaN$7.create;
const bigIntType$7 = ZodBigInt$7.create;
const booleanType$7 = ZodBoolean$7.create;
const dateType$7 = ZodDate$7.create;
const symbolType$7 = ZodSymbol$7.create;
const undefinedType$7 = ZodUndefined$7.create;
const nullType$7 = ZodNull$7.create;
const anyType$7 = ZodAny$7.create;
const unknownType$7 = ZodUnknown$7.create;
const neverType$7 = ZodNever$7.create;
const voidType$7 = ZodVoid$7.create;
const arrayType$7 = ZodArray$7.create;
const objectType$7 = ZodObject$7.create;
const strictObjectType$7 = ZodObject$7.strictCreate;
const unionType$7 = ZodUnion$7.create;
const discriminatedUnionType$7 = ZodDiscriminatedUnion$7.create;
const intersectionType$7 = ZodIntersection$7.create;
const tupleType$7 = ZodTuple$7.create;
const recordType$7 = ZodRecord$7.create;
const mapType$7 = ZodMap$7.create;
const setType$7 = ZodSet$7.create;
const functionType$7 = ZodFunction$7.create;
const lazyType$7 = ZodLazy$7.create;
const literalType$7 = ZodLiteral$7.create;
const enumType$7 = ZodEnum$7.create;
const nativeEnumType$7 = ZodNativeEnum$7.create;
const promiseType$7 = ZodPromise$7.create;
const effectsType$7 = ZodEffects$7.create;
const optionalType$7 = ZodOptional$7.create;
const nullableType$7 = ZodNullable$7.create;
const preprocessType$7 = ZodEffects$7.createWithPreprocess;
const pipelineType$7 = ZodPipeline$7.create;
const ostring$7 = () => stringType$7().optional();
const onumber$7 = () => numberType$7().optional();
const oboolean$7 = () => booleanType$7().optional();
const coerce$7 = {
  string: (arg) => ZodString$7.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber$7.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean$7.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt$7.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate$7.create({ ...arg, coerce: true })
};
const NEVER$7 = INVALID$7;
var z$7 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap$7,
  setErrorMap: setErrorMap$7,
  getErrorMap: getErrorMap$7,
  makeIssue: makeIssue$7,
  EMPTY_PATH: EMPTY_PATH$7,
  addIssueToContext: addIssueToContext$7,
  ParseStatus: ParseStatus$7,
  INVALID: INVALID$7,
  DIRTY: DIRTY$7,
  OK: OK$7,
  isAborted: isAborted$7,
  isDirty: isDirty$7,
  isValid: isValid$7,
  isAsync: isAsync$7,
  get util() {
    return util$7;
  },
  get objectUtil() {
    return objectUtil$7;
  },
  ZodParsedType: ZodParsedType$7,
  getParsedType: getParsedType$7,
  ZodType: ZodType$7,
  datetimeRegex: datetimeRegex$7,
  ZodString: ZodString$7,
  ZodNumber: ZodNumber$7,
  ZodBigInt: ZodBigInt$7,
  ZodBoolean: ZodBoolean$7,
  ZodDate: ZodDate$7,
  ZodSymbol: ZodSymbol$7,
  ZodUndefined: ZodUndefined$7,
  ZodNull: ZodNull$7,
  ZodAny: ZodAny$7,
  ZodUnknown: ZodUnknown$7,
  ZodNever: ZodNever$7,
  ZodVoid: ZodVoid$7,
  ZodArray: ZodArray$7,
  ZodObject: ZodObject$7,
  ZodUnion: ZodUnion$7,
  ZodDiscriminatedUnion: ZodDiscriminatedUnion$7,
  ZodIntersection: ZodIntersection$7,
  ZodTuple: ZodTuple$7,
  ZodRecord: ZodRecord$7,
  ZodMap: ZodMap$7,
  ZodSet: ZodSet$7,
  ZodFunction: ZodFunction$7,
  ZodLazy: ZodLazy$7,
  ZodLiteral: ZodLiteral$7,
  ZodEnum: ZodEnum$7,
  ZodNativeEnum: ZodNativeEnum$7,
  ZodPromise: ZodPromise$7,
  ZodEffects: ZodEffects$7,
  ZodTransformer: ZodEffects$7,
  ZodOptional: ZodOptional$7,
  ZodNullable: ZodNullable$7,
  ZodDefault: ZodDefault$7,
  ZodCatch: ZodCatch$7,
  ZodNaN: ZodNaN$7,
  BRAND: BRAND$7,
  ZodBranded: ZodBranded$7,
  ZodPipeline: ZodPipeline$7,
  ZodReadonly: ZodReadonly$7,
  custom: custom$7,
  Schema: ZodType$7,
  ZodSchema: ZodType$7,
  late: late$7,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind$7;
  },
  coerce: coerce$7,
  any: anyType$7,
  array: arrayType$7,
  bigint: bigIntType$7,
  boolean: booleanType$7,
  date: dateType$7,
  discriminatedUnion: discriminatedUnionType$7,
  effect: effectsType$7,
  "enum": enumType$7,
  "function": functionType$7,
  "instanceof": instanceOfType$7,
  intersection: intersectionType$7,
  lazy: lazyType$7,
  literal: literalType$7,
  map: mapType$7,
  nan: nanType$7,
  nativeEnum: nativeEnumType$7,
  never: neverType$7,
  "null": nullType$7,
  nullable: nullableType$7,
  number: numberType$7,
  object: objectType$7,
  oboolean: oboolean$7,
  onumber: onumber$7,
  optional: optionalType$7,
  ostring: ostring$7,
  pipeline: pipelineType$7,
  preprocess: preprocessType$7,
  promise: promiseType$7,
  record: recordType$7,
  set: setType$7,
  strictObject: strictObjectType$7,
  string: stringType$7,
  symbol: symbolType$7,
  transformer: effectsType$7,
  tuple: tupleType$7,
  "undefined": undefinedType$7,
  union: unionType$7,
  unknown: unknownType$7,
  "void": voidType$7,
  NEVER: NEVER$7,
  ZodIssueCode: ZodIssueCode$7,
  quotelessJson: quotelessJson$7,
  ZodError: ZodError$7
});
const FONT_FAMILIES$2 = [
  {
    key: "MODERN_SANS",
    label: "Modern sans",
    value: '"Helvetica Neue", "Arial Nova", "Nimbus Sans", Arial, sans-serif'
  },
  {
    key: "BOOK_SANS",
    label: "Book sans",
    value: 'Optima, Candara, "Noto Sans", source-sans-pro, sans-serif'
  },
  {
    key: "ORGANIC_SANS",
    label: "Organic sans",
    value: 'Seravek, "Gill Sans Nova", Ubuntu, Calibri, "DejaVu Sans", source-sans-pro, sans-serif'
  },
  {
    key: "GEOMETRIC_SANS",
    label: "Geometric sans",
    value: 'Avenir, "Avenir Next LT Pro", Montserrat, Corbel, "URW Gothic", source-sans-pro, sans-serif'
  },
  {
    key: "HEAVY_SANS",
    label: "Heavy sans",
    value: 'Bahnschrift, "DIN Alternate", "Franklin Gothic Medium", "Nimbus Sans Narrow", sans-serif-condensed, sans-serif'
  },
  {
    key: "ROUNDED_SANS",
    label: "Rounded sans",
    value: 'ui-rounded, "Hiragino Maru Gothic ProN", Quicksand, Comfortaa, Manjari, "Arial Rounded MT Bold", Calibri, source-sans-pro, sans-serif'
  },
  {
    key: "MODERN_SERIF",
    label: "Modern serif",
    value: 'Charter, "Bitstream Charter", "Sitka Text", Cambria, serif'
  },
  {
    key: "BOOK_SERIF",
    label: "Book serif",
    value: '"Iowan Old Style", "Palatino Linotype", "URW Palladio L", P052, serif'
  },
  {
    key: "MONOSPACE",
    label: "Monospace",
    value: '"Nimbus Mono PS", "Courier New", "Cutive Mono", monospace'
  }
];
const FONT_FAMILY_NAMES$6 = [
  "MODERN_SANS",
  "BOOK_SANS",
  "ORGANIC_SANS",
  "GEOMETRIC_SANS",
  "HEAVY_SANS",
  "ROUNDED_SANS",
  "MODERN_SERIF",
  "BOOK_SERIF",
  "MONOSPACE"
];
const PADDING_SCHEMA$5 = z$7.object({
  top: z$7.number(),
  bottom: z$7.number(),
  right: z$7.number(),
  left: z$7.number()
}).optional().nullable();
const COLOR_SCHEMA$5 = z$7.string().regex(/^#[0-9a-fA-F]{6}$/).nullable().optional();
const FONT_FAMILY_SCHEMA$3 = z$7.enum(FONT_FAMILY_NAMES$6).nullable().optional();
function getFontFamily$2(fontFamily) {
  var _a;
  return (_a = FONT_FAMILIES$2.find((f) => f.key === fontFamily)) == null ? void 0 : _a.value;
}
const getPadding$5 = (padding) => padding ? `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px` : void 0;
function getFontSize(level) {
  switch (level) {
    case "h1":
      return "32px";
    case "h2":
      return "24px";
    case "h3":
      return "20px";
  }
}
const HeadingPropsSchema = z$7.object({
  props: z$7.object({
    text: z$7.string().optional().nullable(),
    level: z$7.enum(["h1", "h2", "h3"]).optional().nullable()
  }).optional().nullable(),
  style: z$7.object({
    color: COLOR_SCHEMA$5,
    backgroundColor: COLOR_SCHEMA$5,
    fontFamily: FONT_FAMILY_SCHEMA$3,
    fontWeight: z$7.enum(["bold", "normal"]).optional().nullable(),
    textAlign: z$7.enum(["left", "center", "right"]).optional().nullable(),
    padding: PADDING_SCHEMA$5
  }).optional().nullable()
});
const HeadingPropsDefaults = {
  level: "h2",
  text: ""
};
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    props: {},
    style: {}
  },
  setup(__props) {
    const props = __props;
    const level = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.level) ?? HeadingPropsDefaults.level;
    });
    const text = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.text) ?? HeadingPropsDefaults.text;
    });
    const style = computed(() => {
      var _a, _b, _c, _d, _e, _f;
      return {
        color: ((_a = props.style) == null ? void 0 : _a.color) ?? void 0,
        backgroundColor: ((_b = props.style) == null ? void 0 : _b.backgroundColor) ?? void 0,
        fontWeight: ((_c = props.style) == null ? void 0 : _c.fontWeight) ?? "bold",
        textAlign: ((_d = props.style) == null ? void 0 : _d.textAlign) ?? void 0,
        margin: 0,
        fontFamily: getFontFamily$2((_e = props.style) == null ? void 0 : _e.fontFamily),
        fontSize: getFontSize(level.value),
        padding: getPadding$5((_f = props.style) == null ? void 0 : _f.padding)
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(level.value), {
        style: normalizeStyle(style.value)
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(text.value), 1)
        ]),
        _: 1
      }, 8, ["style"]);
    };
  }
});
/**
 *  Copyright 2025 AntonyDev
 *  @license MIT
**/
var util$6;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$6 || (util$6 = {}));
var objectUtil$6;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$6 || (objectUtil$6 = {}));
const ZodParsedType$6 = util$6.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$6 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$6.undefined;
    case "string":
      return ZodParsedType$6.string;
    case "number":
      return isNaN(data) ? ZodParsedType$6.nan : ZodParsedType$6.number;
    case "boolean":
      return ZodParsedType$6.boolean;
    case "function":
      return ZodParsedType$6.function;
    case "bigint":
      return ZodParsedType$6.bigint;
    case "symbol":
      return ZodParsedType$6.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$6.array;
      }
      if (data === null) {
        return ZodParsedType$6.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$6.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$6.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$6.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$6.date;
      }
      return ZodParsedType$6.object;
    default:
      return ZodParsedType$6.unknown;
  }
};
const ZodIssueCode$6 = util$6.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson$6 = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
let ZodError$6 = class ZodError5 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError5)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$6.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$6.create = (issues) => {
  const error = new ZodError$6(issues);
  return error;
};
const errorMap$6 = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode$6.invalid_type:
      if (issue.received === ZodParsedType$6.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode$6.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$6.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$6.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$6.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode$6.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$6.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$6.joinValues(issue.options)}`;
      break;
    case ZodIssueCode$6.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$6.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode$6.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$6.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$6.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$6.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util$6.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$6.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$6.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$6.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$6.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$6.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode$6.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$6.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap$6 = errorMap$6;
function setErrorMap$6(map) {
  overrideErrorMap$6 = map;
}
function getErrorMap$6() {
  return overrideErrorMap$6;
}
const makeIssue$6 = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH$6 = [];
function addIssueToContext$6(ctx, issueData) {
  const overrideMap = getErrorMap$6();
  const issue = makeIssue$6({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$6 ? void 0 : errorMap$6
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
let ParseStatus$6 = class ParseStatus5 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$6;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus5.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$6;
      if (value.status === "aborted")
        return INVALID$6;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$6 = Object.freeze({
  status: "aborted"
});
const DIRTY$6 = (value) => ({ status: "dirty", value });
const OK$6 = (value) => ({ status: "valid", value });
const isAborted$6 = (x) => x.status === "aborted";
const isDirty$6 = (x) => x.status === "dirty";
const isValid$6 = (x) => x.status === "valid";
const isAsync$6 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet$6(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet$6(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil$6;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil$6 || (errorUtil$6 = {}));
var _ZodEnum_cache$6, _ZodNativeEnum_cache$6;
let ParseInputLazyPath$6 = class ParseInputLazyPath5 {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$6 = (ctx, result) => {
  if (isValid$6(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$6(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$6(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$6 = class ZodType5 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$6(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$6(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$6(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$6(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$6(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$6(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$6(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$6(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$6(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$6(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$6(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$6(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$6(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$6.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$6({
      schema: this,
      typeName: ZodFirstPartyTypeKind$6.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def2) {
    this.spa = this.safeParseAsync;
    this._def = def2;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$6.create(this, this._def);
  }
  nullable() {
    return ZodNullable$6.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$6.create(this);
  }
  promise() {
    return ZodPromise$6.create(this, this._def);
  }
  or(option) {
    return ZodUnion$6.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$6.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects$6({
      ...processCreateParams$6(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$6.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def2) {
    const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodDefault$6({
      ...processCreateParams$6(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$6.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$6({
      typeName: ZodFirstPartyTypeKind$6.ZodBranded,
      type: this,
      ...processCreateParams$6(this._def)
    });
  }
  catch(def2) {
    const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodCatch$6({
      ...processCreateParams$6(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$6.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$6.create(this, target);
  }
  readonly() {
    return ZodReadonly$6.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$6 = /^c[^\s-]{8,}$/i;
const cuid2Regex$6 = /^[0-9a-z]+$/;
const ulidRegex$6 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$6 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$6 = /^[a-z0-9_-]{21}$/i;
const jwtRegex$6 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$6 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$6 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$6 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$6;
const ipv4Regex$6 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$6 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$6 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$6 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$6 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$6 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$6 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$6 = new RegExp(`^${dateRegexSource$6}$`);
function timeRegexSource$6(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex$6(args) {
  return new RegExp(`^${timeRegexSource$6(args)}$`);
}
function datetimeRegex$6(args) {
  let regex = `${dateRegexSource$6}T${timeRegexSource$6(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$6(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex$6.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex$6.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$6(jwt, alg) {
  if (!jwtRegex$6.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr$6(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex$6.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex$6.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$6 = class ZodString5 extends ZodType$6 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx2, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.string,
        received: ctx2.parsedType
      });
      return INVALID$6;
    }
    const status = new ParseStatus$6();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$6(ctx, {
              code: ZodIssueCode$6.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$6(ctx, {
              code: ZodIssueCode$6.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "email",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$6) {
          emojiRegex$6 = new RegExp(_emojiRegex$6, "u");
        }
        if (!emojiRegex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "emoji",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "uuid",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "cuid",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "ulid",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "url",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "regex",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$6(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$6;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$6(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "duration",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$6(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "ip",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$6(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "jwt",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$6(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "cidr",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "base64",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$6.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            validation: "base64url",
            code: ZodIssueCode$6.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$6.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$6.invalid_string,
      ...errorUtil$6.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString5({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$6.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$6.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$6.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$6.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$6.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$6.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$6.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$6.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$6.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$6.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$6.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$6.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$6.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil$6.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil$6.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$6.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$6.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil$6.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$6.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$6.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$6.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$6.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$6.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$6.errToObj(message));
  }
  trim() {
    return new ZodString5({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString5({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString5({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$6.create = (params) => {
  var _a;
  return new ZodString$6({
    checks: [],
    typeName: ZodFirstPartyTypeKind$6.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$6(params)
  });
};
function floatSafeRemainder$6(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
let ZodNumber$6 = class ZodNumber5 extends ZodType$6 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx2, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.number,
        received: ctx2.parsedType
      });
      return INVALID$6;
    }
    let ctx = void 0;
    const status = new ParseStatus$6();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$6.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$6(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$6.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$6.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$6.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$6.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$6.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber5({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$6.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber5({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$6.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$6.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$6.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$6.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$6.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$6.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$6.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$6.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$6.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$6.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$6.create = (params) => {
  return new ZodNumber$6({
    checks: [],
    typeName: ZodFirstPartyTypeKind$6.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$6(params)
  });
};
let ZodBigInt$6 = class ZodBigInt5 extends ZodType$6 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$6();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$6.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$6(ctx, {
      code: ZodIssueCode$6.invalid_type,
      expected: ZodParsedType$6.bigint,
      received: ctx.parsedType
    });
    return INVALID$6;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$6.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$6.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$6.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$6.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt5({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$6.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt5({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$6.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$6.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$6.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$6.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$6.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$6.create = (params) => {
  var _a;
  return new ZodBigInt$6({
    checks: [],
    typeName: ZodFirstPartyTypeKind$6.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$6(params)
  });
};
let ZodBoolean$6 = class ZodBoolean5 extends ZodType$6 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.boolean,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    return OK$6(input.data);
  }
};
ZodBoolean$6.create = (params) => {
  return new ZodBoolean$6({
    typeName: ZodFirstPartyTypeKind$6.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$6(params)
  });
};
let ZodDate$6 = class ZodDate5 extends ZodType$6 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx2, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.date,
        received: ctx2.parsedType
      });
      return INVALID$6;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx2, {
        code: ZodIssueCode$6.invalid_date
      });
      return INVALID$6;
    }
    const status = new ParseStatus$6();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$6.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate5({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$6.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$6.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$6.create = (params) => {
  return new ZodDate$6({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$6.ZodDate,
    ...processCreateParams$6(params)
  });
};
let ZodSymbol$6 = class ZodSymbol5 extends ZodType$6 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.symbol,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    return OK$6(input.data);
  }
};
ZodSymbol$6.create = (params) => {
  return new ZodSymbol$6({
    typeName: ZodFirstPartyTypeKind$6.ZodSymbol,
    ...processCreateParams$6(params)
  });
};
let ZodUndefined$6 = class ZodUndefined5 extends ZodType$6 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.undefined,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    return OK$6(input.data);
  }
};
ZodUndefined$6.create = (params) => {
  return new ZodUndefined$6({
    typeName: ZodFirstPartyTypeKind$6.ZodUndefined,
    ...processCreateParams$6(params)
  });
};
let ZodNull$6 = class ZodNull5 extends ZodType$6 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.null,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    return OK$6(input.data);
  }
};
ZodNull$6.create = (params) => {
  return new ZodNull$6({
    typeName: ZodFirstPartyTypeKind$6.ZodNull,
    ...processCreateParams$6(params)
  });
};
let ZodAny$6 = class ZodAny5 extends ZodType$6 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$6(input.data);
  }
};
ZodAny$6.create = (params) => {
  return new ZodAny$6({
    typeName: ZodFirstPartyTypeKind$6.ZodAny,
    ...processCreateParams$6(params)
  });
};
let ZodUnknown$6 = class ZodUnknown5 extends ZodType$6 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$6(input.data);
  }
};
ZodUnknown$6.create = (params) => {
  return new ZodUnknown$6({
    typeName: ZodFirstPartyTypeKind$6.ZodUnknown,
    ...processCreateParams$6(params)
  });
};
let ZodNever$6 = class ZodNever5 extends ZodType$6 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$6(ctx, {
      code: ZodIssueCode$6.invalid_type,
      expected: ZodParsedType$6.never,
      received: ctx.parsedType
    });
    return INVALID$6;
  }
};
ZodNever$6.create = (params) => {
  return new ZodNever$6({
    typeName: ZodFirstPartyTypeKind$6.ZodNever,
    ...processCreateParams$6(params)
  });
};
let ZodVoid$6 = class ZodVoid5 extends ZodType$6 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.void,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    return OK$6(input.data);
  }
};
ZodVoid$6.create = (params) => {
  return new ZodVoid$6({
    typeName: ZodFirstPartyTypeKind$6.ZodVoid,
    ...processCreateParams$6(params)
  });
};
let ZodArray$6 = class ZodArray5 extends ZodType$6 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def2 = this._def;
    if (ctx.parsedType !== ZodParsedType$6.array) {
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.array,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    if (def2.exactLength !== null) {
      const tooBig = ctx.data.length > def2.exactLength.value;
      const tooSmall = ctx.data.length < def2.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$6(ctx, {
          code: tooBig ? ZodIssueCode$6.too_big : ZodIssueCode$6.too_small,
          minimum: tooSmall ? def2.exactLength.value : void 0,
          maximum: tooBig ? def2.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def2.exactLength.message
        });
        status.dirty();
      }
    }
    if (def2.minLength !== null) {
      if (ctx.data.length < def2.minLength.value) {
        addIssueToContext$6(ctx, {
          code: ZodIssueCode$6.too_small,
          minimum: def2.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.minLength.message
        });
        status.dirty();
      }
    }
    if (def2.maxLength !== null) {
      if (ctx.data.length > def2.maxLength.value) {
        addIssueToContext$6(ctx, {
          code: ZodIssueCode$6.too_big,
          maximum: def2.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def2.type._parseAsync(new ParseInputLazyPath$6(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$6.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def2.type._parseSync(new ParseInputLazyPath$6(ctx, item, ctx.path, i));
    });
    return ParseStatus$6.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray5({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$6.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray5({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$6.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray5({
      ...this._def,
      exactLength: { value: len, message: errorUtil$6.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$6.create = (schema, params) => {
  return new ZodArray$6({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$6.ZodArray,
    ...processCreateParams$6(params)
  });
};
function deepPartialify$6(schema) {
  if (schema instanceof ZodObject$6) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$6.create(deepPartialify$6(fieldSchema));
    }
    return new ZodObject$6({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$6) {
    return new ZodArray$6({
      ...schema._def,
      type: deepPartialify$6(schema.element)
    });
  } else if (schema instanceof ZodOptional$6) {
    return ZodOptional$6.create(deepPartialify$6(schema.unwrap()));
  } else if (schema instanceof ZodNullable$6) {
    return ZodNullable$6.create(deepPartialify$6(schema.unwrap()));
  } else if (schema instanceof ZodTuple$6) {
    return ZodTuple$6.create(schema.items.map((item) => deepPartialify$6(item)));
  } else {
    return schema;
  }
}
let ZodObject$6 = class ZodObject5 extends ZodType$6 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$6.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx2, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.object,
        received: ctx2.parsedType
      });
      return INVALID$6;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$6 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$6(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$6) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$6(ctx, {
            code: ZodIssueCode$6.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$6(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$6.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$6.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$6.errToObj;
    return new ZodObject5({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil$6.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject5({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject5({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject5({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject5({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$6.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject5({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util$6.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject5({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util$6.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject5({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$6(this);
  }
  partial(mask) {
    const newShape = {};
    util$6.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject5({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util$6.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$6) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject5({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$6(util$6.objectKeys(this.shape));
  }
};
ZodObject$6.create = (shape, params) => {
  return new ZodObject$6({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$6.create(),
    typeName: ZodFirstPartyTypeKind$6.ZodObject,
    ...processCreateParams$6(params)
  });
};
ZodObject$6.strictCreate = (shape, params) => {
  return new ZodObject$6({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$6.create(),
    typeName: ZodFirstPartyTypeKind$6.ZodObject,
    ...processCreateParams$6(params)
  });
};
ZodObject$6.lazycreate = (shape, params) => {
  return new ZodObject$6({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$6.create(),
    typeName: ZodFirstPartyTypeKind$6.ZodObject,
    ...processCreateParams$6(params)
  });
};
let ZodUnion$6 = class ZodUnion5 extends ZodType$6 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$6(result.ctx.common.issues));
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_union,
        unionErrors
      });
      return INVALID$6;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$6(issues2));
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_union,
        unionErrors
      });
      return INVALID$6;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$6.create = (types, params) => {
  return new ZodUnion$6({
    options: types,
    typeName: ZodFirstPartyTypeKind$6.ZodUnion,
    ...processCreateParams$6(params)
  });
};
const getDiscriminator$6 = (type) => {
  if (type instanceof ZodLazy$6) {
    return getDiscriminator$6(type.schema);
  } else if (type instanceof ZodEffects$6) {
    return getDiscriminator$6(type.innerType());
  } else if (type instanceof ZodLiteral$6) {
    return [type.value];
  } else if (type instanceof ZodEnum$6) {
    return type.options;
  } else if (type instanceof ZodNativeEnum$6) {
    return util$6.objectValues(type.enum);
  } else if (type instanceof ZodDefault$6) {
    return getDiscriminator$6(type._def.innerType);
  } else if (type instanceof ZodUndefined$6) {
    return [void 0];
  } else if (type instanceof ZodNull$6) {
    return [null];
  } else if (type instanceof ZodOptional$6) {
    return [void 0, ...getDiscriminator$6(type.unwrap())];
  } else if (type instanceof ZodNullable$6) {
    return [null, ...getDiscriminator$6(type.unwrap())];
  } else if (type instanceof ZodBranded$6) {
    return getDiscriminator$6(type.unwrap());
  } else if (type instanceof ZodReadonly$6) {
    return getDiscriminator$6(type.unwrap());
  } else if (type instanceof ZodCatch$6) {
    return getDiscriminator$6(type._def.innerType);
  } else {
    return [];
  }
};
let ZodDiscriminatedUnion$6 = class ZodDiscriminatedUnion5 extends ZodType$6 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$6.object) {
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.object,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID$6;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator$6(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion5({
      typeName: ZodFirstPartyTypeKind$6.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams$6(params)
    });
  }
};
function mergeValues$6(a, b) {
  const aType = getParsedType$6(a);
  const bType = getParsedType$6(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$6.object && bType === ZodParsedType$6.object) {
    const bKeys = util$6.objectKeys(b);
    const sharedKeys = util$6.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$6(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$6.array && bType === ZodParsedType$6.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$6(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$6.date && bType === ZodParsedType$6.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$6 = class ZodIntersection5 extends ZodType$6 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$6(parsedLeft) || isAborted$6(parsedRight)) {
        return INVALID$6;
      }
      const merged = mergeValues$6(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$6(ctx, {
          code: ZodIssueCode$6.invalid_intersection_types
        });
        return INVALID$6;
      }
      if (isDirty$6(parsedLeft) || isDirty$6(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$6.create = (left, right, params) => {
  return new ZodIntersection$6({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$6.ZodIntersection,
    ...processCreateParams$6(params)
  });
};
let ZodTuple$6 = class ZodTuple5 extends ZodType$6 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$6.array) {
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.array,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$6;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$6(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$6.mergeArray(status, results);
      });
    } else {
      return ParseStatus$6.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple5({
      ...this._def,
      rest
    });
  }
};
ZodTuple$6.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$6({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$6.ZodTuple,
    rest: null,
    ...processCreateParams$6(params)
  });
};
let ZodRecord$6 = class ZodRecord5 extends ZodType$6 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$6.object) {
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.object,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath$6(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath$6(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus$6.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus$6.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType$6) {
      return new ZodRecord5({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind$6.ZodRecord,
        ...processCreateParams$6(third)
      });
    }
    return new ZodRecord5({
      keyType: ZodString$6.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind$6.ZodRecord,
      ...processCreateParams$6(second)
    });
  }
};
let ZodMap$6 = class ZodMap5 extends ZodType$6 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$6.map) {
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.map,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$6(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$6(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$6;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$6;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$6.create = (keyType, valueType, params) => {
  return new ZodMap$6({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$6.ZodMap,
    ...processCreateParams$6(params)
  });
};
let ZodSet$6 = class ZodSet5 extends ZodType$6 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$6.set) {
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.set,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    const def2 = this._def;
    if (def2.minSize !== null) {
      if (ctx.data.size < def2.minSize.value) {
        addIssueToContext$6(ctx, {
          code: ZodIssueCode$6.too_small,
          minimum: def2.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.minSize.message
        });
        status.dirty();
      }
    }
    if (def2.maxSize !== null) {
      if (ctx.data.size > def2.maxSize.value) {
        addIssueToContext$6(ctx, {
          code: ZodIssueCode$6.too_big,
          maximum: def2.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements22) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements22) {
        if (element.status === "aborted")
          return INVALID$6;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements2 = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$6(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements2).then((elements22) => finalizeSet(elements22));
    } else {
      return finalizeSet(elements2);
    }
  }
  min(minSize, message) {
    return new ZodSet5({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$6.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet5({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$6.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$6.create = (valueType, params) => {
  return new ZodSet$6({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$6.ZodSet,
    ...processCreateParams$6(params)
  });
};
let ZodFunction$6 = class ZodFunction5 extends ZodType$6 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$6.function) {
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.function,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    function makeArgsIssue(args, error) {
      return makeIssue$6({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$6(),
          errorMap$6
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$6.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue$6({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$6(),
          errorMap$6
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$6.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise$6) {
      const me = this;
      return OK$6(async function(...args) {
        const error = new ZodError$6([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK$6(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError$6([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError$6([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction5({
      ...this._def,
      args: ZodTuple$6.create(items).rest(ZodUnknown$6.create())
    });
  }
  returns(returnType) {
    return new ZodFunction5({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction5({
      args: args ? args : ZodTuple$6.create([]).rest(ZodUnknown$6.create()),
      returns: returns || ZodUnknown$6.create(),
      typeName: ZodFirstPartyTypeKind$6.ZodFunction,
      ...processCreateParams$6(params)
    });
  }
};
let ZodLazy$6 = class ZodLazy5 extends ZodType$6 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$6.create = (getter, params) => {
  return new ZodLazy$6({
    getter,
    typeName: ZodFirstPartyTypeKind$6.ZodLazy,
    ...processCreateParams$6(params)
  });
};
let ZodLiteral$6 = class ZodLiteral5 extends ZodType$6 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx, {
        received: ctx.data,
        code: ZodIssueCode$6.invalid_literal,
        expected: this._def.value
      });
      return INVALID$6;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$6.create = (value, params) => {
  return new ZodLiteral$6({
    value,
    typeName: ZodFirstPartyTypeKind$6.ZodLiteral,
    ...processCreateParams$6(params)
  });
};
function createZodEnum$6(values, params) {
  return new ZodEnum$6({
    values,
    typeName: ZodFirstPartyTypeKind$6.ZodEnum,
    ...processCreateParams$6(params)
  });
}
let ZodEnum$6 = class ZodEnum5 extends ZodType$6 {
  constructor() {
    super(...arguments);
    _ZodEnum_cache$6.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$6(ctx, {
        expected: util$6.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$6.invalid_type
      });
      return INVALID$6;
    }
    if (!__classPrivateFieldGet$6(this, _ZodEnum_cache$6)) {
      __classPrivateFieldSet$6(this, _ZodEnum_cache$6, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet$6(this, _ZodEnum_cache$6).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$6(ctx, {
        received: ctx.data,
        code: ZodIssueCode$6.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$6;
    }
    return OK$6(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum5.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum5.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache$6 = /* @__PURE__ */ new WeakMap();
ZodEnum$6.create = createZodEnum$6;
let ZodNativeEnum$6 = class ZodNativeEnum5 extends ZodType$6 {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache$6.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util$6.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$6.string && ctx.parsedType !== ZodParsedType$6.number) {
      const expectedValues = util$6.objectValues(nativeEnumValues);
      addIssueToContext$6(ctx, {
        expected: util$6.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$6.invalid_type
      });
      return INVALID$6;
    }
    if (!__classPrivateFieldGet$6(this, _ZodNativeEnum_cache$6)) {
      __classPrivateFieldSet$6(this, _ZodNativeEnum_cache$6, new Set(util$6.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet$6(this, _ZodNativeEnum_cache$6).has(input.data)) {
      const expectedValues = util$6.objectValues(nativeEnumValues);
      addIssueToContext$6(ctx, {
        received: ctx.data,
        code: ZodIssueCode$6.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$6;
    }
    return OK$6(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache$6 = /* @__PURE__ */ new WeakMap();
ZodNativeEnum$6.create = (values, params) => {
  return new ZodNativeEnum$6({
    values,
    typeName: ZodFirstPartyTypeKind$6.ZodNativeEnum,
    ...processCreateParams$6(params)
  });
};
let ZodPromise$6 = class ZodPromise5 extends ZodType$6 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$6.promise && ctx.common.async === false) {
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.promise,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    const promisified = ctx.parsedType === ZodParsedType$6.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$6(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$6.create = (schema, params) => {
  return new ZodPromise$6({
    type: schema,
    typeName: ZodFirstPartyTypeKind$6.ZodPromise,
    ...processCreateParams$6(params)
  });
};
let ZodEffects$6 = class ZodEffects5 extends ZodType$6 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$6.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$6(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$6;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$6;
          if (result.status === "dirty")
            return DIRTY$6(result.value);
          if (status.value === "dirty")
            return DIRTY$6(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$6;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$6;
        if (result.status === "dirty")
          return DIRTY$6(result.value);
        if (status.value === "dirty")
          return DIRTY$6(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$6;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$6;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$6(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$6(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util$6.assertNever(effect);
  }
};
ZodEffects$6.create = (schema, effect, params) => {
  return new ZodEffects$6({
    schema,
    typeName: ZodFirstPartyTypeKind$6.ZodEffects,
    effect,
    ...processCreateParams$6(params)
  });
};
ZodEffects$6.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$6({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$6.ZodEffects,
    ...processCreateParams$6(params)
  });
};
let ZodOptional$6 = class ZodOptional5 extends ZodType$6 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$6.undefined) {
      return OK$6(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$6.create = (type, params) => {
  return new ZodOptional$6({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$6.ZodOptional,
    ...processCreateParams$6(params)
  });
};
let ZodNullable$6 = class ZodNullable5 extends ZodType$6 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$6.null) {
      return OK$6(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$6.create = (type, params) => {
  return new ZodNullable$6({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$6.ZodNullable,
    ...processCreateParams$6(params)
  });
};
let ZodDefault$6 = class ZodDefault5 extends ZodType$6 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$6.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$6.create = (type, params) => {
  return new ZodDefault$6({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$6.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$6(params)
  });
};
let ZodCatch$6 = class ZodCatch5 extends ZodType$6 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$6(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$6(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$6(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$6.create = (type, params) => {
  return new ZodCatch$6({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$6.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$6(params)
  });
};
let ZodNaN$6 = class ZodNaN5 extends ZodType$6 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$6.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$6(ctx, {
        code: ZodIssueCode$6.invalid_type,
        expected: ZodParsedType$6.nan,
        received: ctx.parsedType
      });
      return INVALID$6;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$6.create = (params) => {
  return new ZodNaN$6({
    typeName: ZodFirstPartyTypeKind$6.ZodNaN,
    ...processCreateParams$6(params)
  });
};
const BRAND$6 = Symbol("zod_brand");
let ZodBranded$6 = class ZodBranded5 extends ZodType$6 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$6 = class ZodPipeline5 extends ZodType$6 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$6;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$6(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$6;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline5({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$6.ZodPipeline
    });
  }
};
let ZodReadonly$6 = class ZodReadonly5 extends ZodType$6 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$6(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$6(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$6.create = (type, params) => {
  return new ZodReadonly$6({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$6.ZodReadonly,
    ...processCreateParams$6(params)
  });
};
function cleanParams$6(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom$6(check, _params = {}, fatal) {
  if (check)
    return ZodAny$6.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams$6(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams$6(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny$6.create();
}
const late$6 = {
  object: ZodObject$6.lazycreate
};
var ZodFirstPartyTypeKind$6;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$6 || (ZodFirstPartyTypeKind$6 = {}));
const instanceOfType$6 = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom$6((data) => data instanceof cls, params);
const stringType$6 = ZodString$6.create;
const numberType$6 = ZodNumber$6.create;
const nanType$6 = ZodNaN$6.create;
const bigIntType$6 = ZodBigInt$6.create;
const booleanType$6 = ZodBoolean$6.create;
const dateType$6 = ZodDate$6.create;
const symbolType$6 = ZodSymbol$6.create;
const undefinedType$6 = ZodUndefined$6.create;
const nullType$6 = ZodNull$6.create;
const anyType$6 = ZodAny$6.create;
const unknownType$6 = ZodUnknown$6.create;
const neverType$6 = ZodNever$6.create;
const voidType$6 = ZodVoid$6.create;
const arrayType$6 = ZodArray$6.create;
const objectType$6 = ZodObject$6.create;
const strictObjectType$6 = ZodObject$6.strictCreate;
const unionType$6 = ZodUnion$6.create;
const discriminatedUnionType$6 = ZodDiscriminatedUnion$6.create;
const intersectionType$6 = ZodIntersection$6.create;
const tupleType$6 = ZodTuple$6.create;
const recordType$6 = ZodRecord$6.create;
const mapType$6 = ZodMap$6.create;
const setType$6 = ZodSet$6.create;
const functionType$6 = ZodFunction$6.create;
const lazyType$6 = ZodLazy$6.create;
const literalType$6 = ZodLiteral$6.create;
const enumType$6 = ZodEnum$6.create;
const nativeEnumType$6 = ZodNativeEnum$6.create;
const promiseType$6 = ZodPromise$6.create;
const effectsType$6 = ZodEffects$6.create;
const optionalType$6 = ZodOptional$6.create;
const nullableType$6 = ZodNullable$6.create;
const preprocessType$6 = ZodEffects$6.createWithPreprocess;
const pipelineType$6 = ZodPipeline$6.create;
const ostring$6 = () => stringType$6().optional();
const onumber$6 = () => numberType$6().optional();
const oboolean$6 = () => booleanType$6().optional();
const coerce$6 = {
  string: (arg) => ZodString$6.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber$6.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean$6.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt$6.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate$6.create({ ...arg, coerce: true })
};
const NEVER$6 = INVALID$6;
var z$6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap$6,
  setErrorMap: setErrorMap$6,
  getErrorMap: getErrorMap$6,
  makeIssue: makeIssue$6,
  EMPTY_PATH: EMPTY_PATH$6,
  addIssueToContext: addIssueToContext$6,
  ParseStatus: ParseStatus$6,
  INVALID: INVALID$6,
  DIRTY: DIRTY$6,
  OK: OK$6,
  isAborted: isAborted$6,
  isDirty: isDirty$6,
  isValid: isValid$6,
  isAsync: isAsync$6,
  get util() {
    return util$6;
  },
  get objectUtil() {
    return objectUtil$6;
  },
  ZodParsedType: ZodParsedType$6,
  getParsedType: getParsedType$6,
  ZodType: ZodType$6,
  datetimeRegex: datetimeRegex$6,
  ZodString: ZodString$6,
  ZodNumber: ZodNumber$6,
  ZodBigInt: ZodBigInt$6,
  ZodBoolean: ZodBoolean$6,
  ZodDate: ZodDate$6,
  ZodSymbol: ZodSymbol$6,
  ZodUndefined: ZodUndefined$6,
  ZodNull: ZodNull$6,
  ZodAny: ZodAny$6,
  ZodUnknown: ZodUnknown$6,
  ZodNever: ZodNever$6,
  ZodVoid: ZodVoid$6,
  ZodArray: ZodArray$6,
  ZodObject: ZodObject$6,
  ZodUnion: ZodUnion$6,
  ZodDiscriminatedUnion: ZodDiscriminatedUnion$6,
  ZodIntersection: ZodIntersection$6,
  ZodTuple: ZodTuple$6,
  ZodRecord: ZodRecord$6,
  ZodMap: ZodMap$6,
  ZodSet: ZodSet$6,
  ZodFunction: ZodFunction$6,
  ZodLazy: ZodLazy$6,
  ZodLiteral: ZodLiteral$6,
  ZodEnum: ZodEnum$6,
  ZodNativeEnum: ZodNativeEnum$6,
  ZodPromise: ZodPromise$6,
  ZodEffects: ZodEffects$6,
  ZodTransformer: ZodEffects$6,
  ZodOptional: ZodOptional$6,
  ZodNullable: ZodNullable$6,
  ZodDefault: ZodDefault$6,
  ZodCatch: ZodCatch$6,
  ZodNaN: ZodNaN$6,
  BRAND: BRAND$6,
  ZodBranded: ZodBranded$6,
  ZodPipeline: ZodPipeline$6,
  ZodReadonly: ZodReadonly$6,
  custom: custom$6,
  Schema: ZodType$6,
  ZodSchema: ZodType$6,
  late: late$6,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind$6;
  },
  coerce: coerce$6,
  any: anyType$6,
  array: arrayType$6,
  bigint: bigIntType$6,
  boolean: booleanType$6,
  date: dateType$6,
  discriminatedUnion: discriminatedUnionType$6,
  effect: effectsType$6,
  "enum": enumType$6,
  "function": functionType$6,
  "instanceof": instanceOfType$6,
  intersection: intersectionType$6,
  lazy: lazyType$6,
  literal: literalType$6,
  map: mapType$6,
  nan: nanType$6,
  nativeEnum: nativeEnumType$6,
  never: neverType$6,
  "null": nullType$6,
  nullable: nullableType$6,
  number: numberType$6,
  object: objectType$6,
  oboolean: oboolean$6,
  onumber: onumber$6,
  optional: optionalType$6,
  ostring: ostring$6,
  pipeline: pipelineType$6,
  preprocess: preprocessType$6,
  promise: promiseType$6,
  record: recordType$6,
  set: setType$6,
  strictObject: strictObjectType$6,
  string: stringType$6,
  symbol: symbolType$6,
  transformer: effectsType$6,
  tuple: tupleType$6,
  "undefined": undefinedType$6,
  union: unionType$6,
  unknown: unknownType$6,
  "void": voidType$6,
  NEVER: NEVER$6,
  ZodIssueCode: ZodIssueCode$6,
  quotelessJson: quotelessJson$6,
  ZodError: ZodError$6
});
const FONT_FAMILIES$1 = [
  {
    key: "MODERN_SANS",
    label: "Modern sans",
    value: '"Helvetica Neue", "Arial Nova", "Nimbus Sans", Arial, sans-serif'
  },
  {
    key: "BOOK_SANS",
    label: "Book sans",
    value: 'Optima, Candara, "Noto Sans", source-sans-pro, sans-serif'
  },
  {
    key: "ORGANIC_SANS",
    label: "Organic sans",
    value: 'Seravek, "Gill Sans Nova", Ubuntu, Calibri, "DejaVu Sans", source-sans-pro, sans-serif'
  },
  {
    key: "GEOMETRIC_SANS",
    label: "Geometric sans",
    value: 'Avenir, "Avenir Next LT Pro", Montserrat, Corbel, "URW Gothic", source-sans-pro, sans-serif'
  },
  {
    key: "HEAVY_SANS",
    label: "Heavy sans",
    value: 'Bahnschrift, "DIN Alternate", "Franklin Gothic Medium", "Nimbus Sans Narrow", sans-serif-condensed, sans-serif'
  },
  {
    key: "ROUNDED_SANS",
    label: "Rounded sans",
    value: 'ui-rounded, "Hiragino Maru Gothic ProN", Quicksand, Comfortaa, Manjari, "Arial Rounded MT Bold", Calibri, source-sans-pro, sans-serif'
  },
  {
    key: "MODERN_SERIF",
    label: "Modern serif",
    value: 'Charter, "Bitstream Charter", "Sitka Text", Cambria, serif'
  },
  {
    key: "BOOK_SERIF",
    label: "Book serif",
    value: '"Iowan Old Style", "Palatino Linotype", "URW Palladio L", P052, serif'
  },
  {
    key: "MONOSPACE",
    label: "Monospace",
    value: '"Nimbus Mono PS", "Courier New", "Cutive Mono", monospace'
  }
];
const FONT_FAMILY_NAMES$5 = [
  "MODERN_SANS",
  "BOOK_SANS",
  "ORGANIC_SANS",
  "GEOMETRIC_SANS",
  "HEAVY_SANS",
  "ROUNDED_SANS",
  "MODERN_SERIF",
  "BOOK_SERIF",
  "MONOSPACE"
];
const PADDING_SCHEMA$4 = z$6.object({
  top: z$6.number(),
  bottom: z$6.number(),
  right: z$6.number(),
  left: z$6.number()
}).optional().nullable();
const COLOR_SCHEMA$4 = z$6.string().regex(/^#[0-9a-fA-F]{6}$/).nullable().optional();
const FONT_FAMILY_SCHEMA$2 = z$6.enum(FONT_FAMILY_NAMES$5).nullable().optional();
function getFontFamily$1(fontFamily) {
  var _a;
  return (_a = FONT_FAMILIES$1.find((f) => f.key === fontFamily)) == null ? void 0 : _a.value;
}
const getPadding$4 = (padding) => padding ? `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px` : void 0;
const _hoisted_1$4 = ["innerHTML"];
const HtmlPropsSchema = z$6.object({
  style: z$6.object({
    color: COLOR_SCHEMA$4,
    backgroundColor: COLOR_SCHEMA$4,
    fontFamily: FONT_FAMILY_SCHEMA$2,
    fontSize: z$6.number().min(0).optional().nullable(),
    textAlign: z$6.enum(["left", "right", "center"]).optional().nullable(),
    padding: PADDING_SCHEMA$4
  }).optional().nullable(),
  props: z$6.object({
    contents: z$6.string().optional().nullable()
  }).optional().nullable()
});
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    style: {},
    props: {}
  },
  setup(__props) {
    const props = __props;
    const cssStyle = computed(() => {
      var _a, _b, _c, _d, _e, _f, _g;
      return {
        color: ((_a = props.style) == null ? void 0 : _a.color) ?? void 0,
        backgroundColor: ((_b = props.style) == null ? void 0 : _b.backgroundColor) ?? void 0,
        fontFamily: getFontFamily$1((_c = props.style) == null ? void 0 : _c.fontFamily),
        fontSize: ((_d = props.style) == null ? void 0 : _d.fontSize) ? ((_e = props.style) == null ? void 0 : _e.fontSize) + "px" : void 0,
        textAlign: ((_f = props.style) == null ? void 0 : _f.textAlign) ?? void 0,
        padding: getPadding$4((_g = props.style) == null ? void 0 : _g.padding)
      };
    });
    return (_ctx, _cache) => {
      var _a;
      return !((_a = props.props) == null ? void 0 : _a.contents) ? (openBlock(), createElementBlock("div", {
        key: 0,
        style: normalizeStyle(cssStyle.value)
      }, null, 4)) : (openBlock(), createElementBlock("div", {
        key: 1,
        innerHTML: props.props.contents,
        style: normalizeStyle(cssStyle.value),
        class: "revert-browser-styles"
      }, null, 12, _hoisted_1$4));
    };
  }
});
/**
 *  Copyright 2025 AntonyDev
 *  @license MIT
**/
var util$5;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$5 || (util$5 = {}));
var objectUtil$5;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$5 || (objectUtil$5 = {}));
const ZodParsedType$5 = util$5.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$5 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$5.undefined;
    case "string":
      return ZodParsedType$5.string;
    case "number":
      return isNaN(data) ? ZodParsedType$5.nan : ZodParsedType$5.number;
    case "boolean":
      return ZodParsedType$5.boolean;
    case "function":
      return ZodParsedType$5.function;
    case "bigint":
      return ZodParsedType$5.bigint;
    case "symbol":
      return ZodParsedType$5.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$5.array;
      }
      if (data === null) {
        return ZodParsedType$5.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$5.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$5.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$5.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$5.date;
      }
      return ZodParsedType$5.object;
    default:
      return ZodParsedType$5.unknown;
  }
};
const ZodIssueCode$5 = util$5.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson$5 = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
let ZodError$5 = class ZodError6 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError6)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$5.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$5.create = (issues) => {
  const error = new ZodError$5(issues);
  return error;
};
const errorMap$5 = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode$5.invalid_type:
      if (issue.received === ZodParsedType$5.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode$5.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$5.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$5.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$5.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode$5.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$5.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$5.joinValues(issue.options)}`;
      break;
    case ZodIssueCode$5.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$5.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode$5.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$5.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$5.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$5.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util$5.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$5.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$5.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$5.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$5.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$5.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode$5.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$5.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap$5 = errorMap$5;
function setErrorMap$5(map) {
  overrideErrorMap$5 = map;
}
function getErrorMap$5() {
  return overrideErrorMap$5;
}
const makeIssue$5 = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH$5 = [];
function addIssueToContext$5(ctx, issueData) {
  const overrideMap = getErrorMap$5();
  const issue = makeIssue$5({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$5 ? void 0 : errorMap$5
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
let ParseStatus$5 = class ParseStatus6 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$5;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus6.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$5;
      if (value.status === "aborted")
        return INVALID$5;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$5 = Object.freeze({
  status: "aborted"
});
const DIRTY$5 = (value) => ({ status: "dirty", value });
const OK$5 = (value) => ({ status: "valid", value });
const isAborted$5 = (x) => x.status === "aborted";
const isDirty$5 = (x) => x.status === "dirty";
const isValid$5 = (x) => x.status === "valid";
const isAsync$5 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet$5(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet$5(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil$5;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil$5 || (errorUtil$5 = {}));
var _ZodEnum_cache$5, _ZodNativeEnum_cache$5;
let ParseInputLazyPath$5 = class ParseInputLazyPath6 {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$5 = (ctx, result) => {
  if (isValid$5(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$5(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$5(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$5 = class ZodType6 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$5(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$5(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$5(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$5(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$5(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$5(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$5(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$5(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$5(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$5(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$5(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$5(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$5(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$5.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$5({
      schema: this,
      typeName: ZodFirstPartyTypeKind$5.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def2) {
    this.spa = this.safeParseAsync;
    this._def = def2;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$5.create(this, this._def);
  }
  nullable() {
    return ZodNullable$5.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$5.create(this);
  }
  promise() {
    return ZodPromise$5.create(this, this._def);
  }
  or(option) {
    return ZodUnion$5.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$5.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects$5({
      ...processCreateParams$5(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$5.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def2) {
    const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodDefault$5({
      ...processCreateParams$5(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$5.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$5({
      typeName: ZodFirstPartyTypeKind$5.ZodBranded,
      type: this,
      ...processCreateParams$5(this._def)
    });
  }
  catch(def2) {
    const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodCatch$5({
      ...processCreateParams$5(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$5.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$5.create(this, target);
  }
  readonly() {
    return ZodReadonly$5.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$5 = /^c[^\s-]{8,}$/i;
const cuid2Regex$5 = /^[0-9a-z]+$/;
const ulidRegex$5 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$5 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$5 = /^[a-z0-9_-]{21}$/i;
const jwtRegex$5 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$5 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$5 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$5 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$5;
const ipv4Regex$5 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$5 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$5 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$5 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$5 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$5 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$5 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$5 = new RegExp(`^${dateRegexSource$5}$`);
function timeRegexSource$5(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex$5(args) {
  return new RegExp(`^${timeRegexSource$5(args)}$`);
}
function datetimeRegex$5(args) {
  let regex = `${dateRegexSource$5}T${timeRegexSource$5(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$5(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex$5.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex$5.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$5(jwt, alg) {
  if (!jwtRegex$5.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr$5(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex$5.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex$5.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$5 = class ZodString6 extends ZodType$5 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx2, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.string,
        received: ctx2.parsedType
      });
      return INVALID$5;
    }
    const status = new ParseStatus$5();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$5(ctx, {
              code: ZodIssueCode$5.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$5(ctx, {
              code: ZodIssueCode$5.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "email",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$5) {
          emojiRegex$5 = new RegExp(_emojiRegex$5, "u");
        }
        if (!emojiRegex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "emoji",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "uuid",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "cuid",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "ulid",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "url",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "regex",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$5(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$5;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$5(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "duration",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$5(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "ip",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$5(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "jwt",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$5(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "cidr",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "base64",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$5.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            validation: "base64url",
            code: ZodIssueCode$5.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$5.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$5.invalid_string,
      ...errorUtil$5.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString6({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$5.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$5.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$5.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$5.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$5.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$5.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$5.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$5.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$5.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$5.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$5.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$5.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$5.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil$5.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil$5.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$5.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$5.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil$5.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$5.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$5.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$5.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$5.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$5.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$5.errToObj(message));
  }
  trim() {
    return new ZodString6({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString6({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString6({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$5.create = (params) => {
  var _a;
  return new ZodString$5({
    checks: [],
    typeName: ZodFirstPartyTypeKind$5.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$5(params)
  });
};
function floatSafeRemainder$5(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
let ZodNumber$5 = class ZodNumber6 extends ZodType$5 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx2, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.number,
        received: ctx2.parsedType
      });
      return INVALID$5;
    }
    let ctx = void 0;
    const status = new ParseStatus$5();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$5.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$5(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$5.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$5.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$5.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$5.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$5.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber6({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$5.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber6({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$5.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$5.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$5.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$5.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$5.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$5.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$5.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$5.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$5.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$5.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$5.create = (params) => {
  return new ZodNumber$5({
    checks: [],
    typeName: ZodFirstPartyTypeKind$5.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$5(params)
  });
};
let ZodBigInt$5 = class ZodBigInt6 extends ZodType$5 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$5();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$5.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$5(ctx, {
      code: ZodIssueCode$5.invalid_type,
      expected: ZodParsedType$5.bigint,
      received: ctx.parsedType
    });
    return INVALID$5;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$5.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$5.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$5.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$5.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt6({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$5.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt6({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$5.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$5.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$5.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$5.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$5.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$5.create = (params) => {
  var _a;
  return new ZodBigInt$5({
    checks: [],
    typeName: ZodFirstPartyTypeKind$5.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$5(params)
  });
};
let ZodBoolean$5 = class ZodBoolean6 extends ZodType$5 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.boolean,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    return OK$5(input.data);
  }
};
ZodBoolean$5.create = (params) => {
  return new ZodBoolean$5({
    typeName: ZodFirstPartyTypeKind$5.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$5(params)
  });
};
let ZodDate$5 = class ZodDate6 extends ZodType$5 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx2, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.date,
        received: ctx2.parsedType
      });
      return INVALID$5;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx2, {
        code: ZodIssueCode$5.invalid_date
      });
      return INVALID$5;
    }
    const status = new ParseStatus$5();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$5.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate6({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$5.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$5.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$5.create = (params) => {
  return new ZodDate$5({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$5.ZodDate,
    ...processCreateParams$5(params)
  });
};
let ZodSymbol$5 = class ZodSymbol6 extends ZodType$5 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.symbol,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    return OK$5(input.data);
  }
};
ZodSymbol$5.create = (params) => {
  return new ZodSymbol$5({
    typeName: ZodFirstPartyTypeKind$5.ZodSymbol,
    ...processCreateParams$5(params)
  });
};
let ZodUndefined$5 = class ZodUndefined6 extends ZodType$5 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.undefined,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    return OK$5(input.data);
  }
};
ZodUndefined$5.create = (params) => {
  return new ZodUndefined$5({
    typeName: ZodFirstPartyTypeKind$5.ZodUndefined,
    ...processCreateParams$5(params)
  });
};
let ZodNull$5 = class ZodNull6 extends ZodType$5 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.null,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    return OK$5(input.data);
  }
};
ZodNull$5.create = (params) => {
  return new ZodNull$5({
    typeName: ZodFirstPartyTypeKind$5.ZodNull,
    ...processCreateParams$5(params)
  });
};
let ZodAny$5 = class ZodAny6 extends ZodType$5 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$5(input.data);
  }
};
ZodAny$5.create = (params) => {
  return new ZodAny$5({
    typeName: ZodFirstPartyTypeKind$5.ZodAny,
    ...processCreateParams$5(params)
  });
};
let ZodUnknown$5 = class ZodUnknown6 extends ZodType$5 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$5(input.data);
  }
};
ZodUnknown$5.create = (params) => {
  return new ZodUnknown$5({
    typeName: ZodFirstPartyTypeKind$5.ZodUnknown,
    ...processCreateParams$5(params)
  });
};
let ZodNever$5 = class ZodNever6 extends ZodType$5 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$5(ctx, {
      code: ZodIssueCode$5.invalid_type,
      expected: ZodParsedType$5.never,
      received: ctx.parsedType
    });
    return INVALID$5;
  }
};
ZodNever$5.create = (params) => {
  return new ZodNever$5({
    typeName: ZodFirstPartyTypeKind$5.ZodNever,
    ...processCreateParams$5(params)
  });
};
let ZodVoid$5 = class ZodVoid6 extends ZodType$5 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.void,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    return OK$5(input.data);
  }
};
ZodVoid$5.create = (params) => {
  return new ZodVoid$5({
    typeName: ZodFirstPartyTypeKind$5.ZodVoid,
    ...processCreateParams$5(params)
  });
};
let ZodArray$5 = class ZodArray6 extends ZodType$5 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def2 = this._def;
    if (ctx.parsedType !== ZodParsedType$5.array) {
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.array,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    if (def2.exactLength !== null) {
      const tooBig = ctx.data.length > def2.exactLength.value;
      const tooSmall = ctx.data.length < def2.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$5(ctx, {
          code: tooBig ? ZodIssueCode$5.too_big : ZodIssueCode$5.too_small,
          minimum: tooSmall ? def2.exactLength.value : void 0,
          maximum: tooBig ? def2.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def2.exactLength.message
        });
        status.dirty();
      }
    }
    if (def2.minLength !== null) {
      if (ctx.data.length < def2.minLength.value) {
        addIssueToContext$5(ctx, {
          code: ZodIssueCode$5.too_small,
          minimum: def2.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.minLength.message
        });
        status.dirty();
      }
    }
    if (def2.maxLength !== null) {
      if (ctx.data.length > def2.maxLength.value) {
        addIssueToContext$5(ctx, {
          code: ZodIssueCode$5.too_big,
          maximum: def2.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def2.type._parseAsync(new ParseInputLazyPath$5(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$5.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def2.type._parseSync(new ParseInputLazyPath$5(ctx, item, ctx.path, i));
    });
    return ParseStatus$5.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray6({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$5.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray6({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$5.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray6({
      ...this._def,
      exactLength: { value: len, message: errorUtil$5.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$5.create = (schema, params) => {
  return new ZodArray$5({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$5.ZodArray,
    ...processCreateParams$5(params)
  });
};
function deepPartialify$5(schema) {
  if (schema instanceof ZodObject$5) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$5.create(deepPartialify$5(fieldSchema));
    }
    return new ZodObject$5({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$5) {
    return new ZodArray$5({
      ...schema._def,
      type: deepPartialify$5(schema.element)
    });
  } else if (schema instanceof ZodOptional$5) {
    return ZodOptional$5.create(deepPartialify$5(schema.unwrap()));
  } else if (schema instanceof ZodNullable$5) {
    return ZodNullable$5.create(deepPartialify$5(schema.unwrap()));
  } else if (schema instanceof ZodTuple$5) {
    return ZodTuple$5.create(schema.items.map((item) => deepPartialify$5(item)));
  } else {
    return schema;
  }
}
let ZodObject$5 = class ZodObject6 extends ZodType$5 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$5.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx2, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.object,
        received: ctx2.parsedType
      });
      return INVALID$5;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$5 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$5(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$5) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$5(ctx, {
            code: ZodIssueCode$5.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$5(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$5.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$5.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$5.errToObj;
    return new ZodObject6({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil$5.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject6({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject6({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject6({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject6({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$5.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject6({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util$5.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject6({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util$5.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject6({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$5(this);
  }
  partial(mask) {
    const newShape = {};
    util$5.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject6({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util$5.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$5) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject6({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$5(util$5.objectKeys(this.shape));
  }
};
ZodObject$5.create = (shape, params) => {
  return new ZodObject$5({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$5.create(),
    typeName: ZodFirstPartyTypeKind$5.ZodObject,
    ...processCreateParams$5(params)
  });
};
ZodObject$5.strictCreate = (shape, params) => {
  return new ZodObject$5({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$5.create(),
    typeName: ZodFirstPartyTypeKind$5.ZodObject,
    ...processCreateParams$5(params)
  });
};
ZodObject$5.lazycreate = (shape, params) => {
  return new ZodObject$5({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$5.create(),
    typeName: ZodFirstPartyTypeKind$5.ZodObject,
    ...processCreateParams$5(params)
  });
};
let ZodUnion$5 = class ZodUnion6 extends ZodType$5 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$5(result.ctx.common.issues));
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_union,
        unionErrors
      });
      return INVALID$5;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$5(issues2));
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_union,
        unionErrors
      });
      return INVALID$5;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$5.create = (types, params) => {
  return new ZodUnion$5({
    options: types,
    typeName: ZodFirstPartyTypeKind$5.ZodUnion,
    ...processCreateParams$5(params)
  });
};
const getDiscriminator$5 = (type) => {
  if (type instanceof ZodLazy$5) {
    return getDiscriminator$5(type.schema);
  } else if (type instanceof ZodEffects$5) {
    return getDiscriminator$5(type.innerType());
  } else if (type instanceof ZodLiteral$5) {
    return [type.value];
  } else if (type instanceof ZodEnum$5) {
    return type.options;
  } else if (type instanceof ZodNativeEnum$5) {
    return util$5.objectValues(type.enum);
  } else if (type instanceof ZodDefault$5) {
    return getDiscriminator$5(type._def.innerType);
  } else if (type instanceof ZodUndefined$5) {
    return [void 0];
  } else if (type instanceof ZodNull$5) {
    return [null];
  } else if (type instanceof ZodOptional$5) {
    return [void 0, ...getDiscriminator$5(type.unwrap())];
  } else if (type instanceof ZodNullable$5) {
    return [null, ...getDiscriminator$5(type.unwrap())];
  } else if (type instanceof ZodBranded$5) {
    return getDiscriminator$5(type.unwrap());
  } else if (type instanceof ZodReadonly$5) {
    return getDiscriminator$5(type.unwrap());
  } else if (type instanceof ZodCatch$5) {
    return getDiscriminator$5(type._def.innerType);
  } else {
    return [];
  }
};
let ZodDiscriminatedUnion$5 = class ZodDiscriminatedUnion6 extends ZodType$5 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$5.object) {
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.object,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID$5;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator$5(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion6({
      typeName: ZodFirstPartyTypeKind$5.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams$5(params)
    });
  }
};
function mergeValues$5(a, b) {
  const aType = getParsedType$5(a);
  const bType = getParsedType$5(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$5.object && bType === ZodParsedType$5.object) {
    const bKeys = util$5.objectKeys(b);
    const sharedKeys = util$5.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$5(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$5.array && bType === ZodParsedType$5.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$5(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$5.date && bType === ZodParsedType$5.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$5 = class ZodIntersection6 extends ZodType$5 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$5(parsedLeft) || isAborted$5(parsedRight)) {
        return INVALID$5;
      }
      const merged = mergeValues$5(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$5(ctx, {
          code: ZodIssueCode$5.invalid_intersection_types
        });
        return INVALID$5;
      }
      if (isDirty$5(parsedLeft) || isDirty$5(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$5.create = (left, right, params) => {
  return new ZodIntersection$5({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$5.ZodIntersection,
    ...processCreateParams$5(params)
  });
};
let ZodTuple$5 = class ZodTuple6 extends ZodType$5 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$5.array) {
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.array,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$5;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$5(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$5.mergeArray(status, results);
      });
    } else {
      return ParseStatus$5.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple6({
      ...this._def,
      rest
    });
  }
};
ZodTuple$5.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$5({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$5.ZodTuple,
    rest: null,
    ...processCreateParams$5(params)
  });
};
let ZodRecord$5 = class ZodRecord6 extends ZodType$5 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$5.object) {
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.object,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath$5(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath$5(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus$5.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus$5.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType$5) {
      return new ZodRecord6({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind$5.ZodRecord,
        ...processCreateParams$5(third)
      });
    }
    return new ZodRecord6({
      keyType: ZodString$5.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind$5.ZodRecord,
      ...processCreateParams$5(second)
    });
  }
};
let ZodMap$5 = class ZodMap6 extends ZodType$5 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$5.map) {
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.map,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$5(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$5(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$5;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$5;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$5.create = (keyType, valueType, params) => {
  return new ZodMap$5({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$5.ZodMap,
    ...processCreateParams$5(params)
  });
};
let ZodSet$5 = class ZodSet6 extends ZodType$5 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$5.set) {
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.set,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    const def2 = this._def;
    if (def2.minSize !== null) {
      if (ctx.data.size < def2.minSize.value) {
        addIssueToContext$5(ctx, {
          code: ZodIssueCode$5.too_small,
          minimum: def2.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.minSize.message
        });
        status.dirty();
      }
    }
    if (def2.maxSize !== null) {
      if (ctx.data.size > def2.maxSize.value) {
        addIssueToContext$5(ctx, {
          code: ZodIssueCode$5.too_big,
          maximum: def2.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements22) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements22) {
        if (element.status === "aborted")
          return INVALID$5;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements2 = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$5(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements2).then((elements22) => finalizeSet(elements22));
    } else {
      return finalizeSet(elements2);
    }
  }
  min(minSize, message) {
    return new ZodSet6({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$5.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet6({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$5.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$5.create = (valueType, params) => {
  return new ZodSet$5({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$5.ZodSet,
    ...processCreateParams$5(params)
  });
};
let ZodFunction$5 = class ZodFunction6 extends ZodType$5 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$5.function) {
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.function,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    function makeArgsIssue(args, error) {
      return makeIssue$5({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$5(),
          errorMap$5
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$5.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue$5({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$5(),
          errorMap$5
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$5.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise$5) {
      const me = this;
      return OK$5(async function(...args) {
        const error = new ZodError$5([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK$5(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError$5([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError$5([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction6({
      ...this._def,
      args: ZodTuple$5.create(items).rest(ZodUnknown$5.create())
    });
  }
  returns(returnType) {
    return new ZodFunction6({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction6({
      args: args ? args : ZodTuple$5.create([]).rest(ZodUnknown$5.create()),
      returns: returns || ZodUnknown$5.create(),
      typeName: ZodFirstPartyTypeKind$5.ZodFunction,
      ...processCreateParams$5(params)
    });
  }
};
let ZodLazy$5 = class ZodLazy6 extends ZodType$5 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$5.create = (getter, params) => {
  return new ZodLazy$5({
    getter,
    typeName: ZodFirstPartyTypeKind$5.ZodLazy,
    ...processCreateParams$5(params)
  });
};
let ZodLiteral$5 = class ZodLiteral6 extends ZodType$5 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx, {
        received: ctx.data,
        code: ZodIssueCode$5.invalid_literal,
        expected: this._def.value
      });
      return INVALID$5;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$5.create = (value, params) => {
  return new ZodLiteral$5({
    value,
    typeName: ZodFirstPartyTypeKind$5.ZodLiteral,
    ...processCreateParams$5(params)
  });
};
function createZodEnum$5(values, params) {
  return new ZodEnum$5({
    values,
    typeName: ZodFirstPartyTypeKind$5.ZodEnum,
    ...processCreateParams$5(params)
  });
}
let ZodEnum$5 = class ZodEnum6 extends ZodType$5 {
  constructor() {
    super(...arguments);
    _ZodEnum_cache$5.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$5(ctx, {
        expected: util$5.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$5.invalid_type
      });
      return INVALID$5;
    }
    if (!__classPrivateFieldGet$5(this, _ZodEnum_cache$5)) {
      __classPrivateFieldSet$5(this, _ZodEnum_cache$5, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet$5(this, _ZodEnum_cache$5).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$5(ctx, {
        received: ctx.data,
        code: ZodIssueCode$5.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$5;
    }
    return OK$5(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum6.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum6.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache$5 = /* @__PURE__ */ new WeakMap();
ZodEnum$5.create = createZodEnum$5;
let ZodNativeEnum$5 = class ZodNativeEnum6 extends ZodType$5 {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache$5.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util$5.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$5.string && ctx.parsedType !== ZodParsedType$5.number) {
      const expectedValues = util$5.objectValues(nativeEnumValues);
      addIssueToContext$5(ctx, {
        expected: util$5.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$5.invalid_type
      });
      return INVALID$5;
    }
    if (!__classPrivateFieldGet$5(this, _ZodNativeEnum_cache$5)) {
      __classPrivateFieldSet$5(this, _ZodNativeEnum_cache$5, new Set(util$5.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet$5(this, _ZodNativeEnum_cache$5).has(input.data)) {
      const expectedValues = util$5.objectValues(nativeEnumValues);
      addIssueToContext$5(ctx, {
        received: ctx.data,
        code: ZodIssueCode$5.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$5;
    }
    return OK$5(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache$5 = /* @__PURE__ */ new WeakMap();
ZodNativeEnum$5.create = (values, params) => {
  return new ZodNativeEnum$5({
    values,
    typeName: ZodFirstPartyTypeKind$5.ZodNativeEnum,
    ...processCreateParams$5(params)
  });
};
let ZodPromise$5 = class ZodPromise6 extends ZodType$5 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$5.promise && ctx.common.async === false) {
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.promise,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    const promisified = ctx.parsedType === ZodParsedType$5.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$5(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$5.create = (schema, params) => {
  return new ZodPromise$5({
    type: schema,
    typeName: ZodFirstPartyTypeKind$5.ZodPromise,
    ...processCreateParams$5(params)
  });
};
let ZodEffects$5 = class ZodEffects6 extends ZodType$5 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$5.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$5(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$5;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$5;
          if (result.status === "dirty")
            return DIRTY$5(result.value);
          if (status.value === "dirty")
            return DIRTY$5(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$5;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$5;
        if (result.status === "dirty")
          return DIRTY$5(result.value);
        if (status.value === "dirty")
          return DIRTY$5(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$5;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$5;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$5(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$5(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util$5.assertNever(effect);
  }
};
ZodEffects$5.create = (schema, effect, params) => {
  return new ZodEffects$5({
    schema,
    typeName: ZodFirstPartyTypeKind$5.ZodEffects,
    effect,
    ...processCreateParams$5(params)
  });
};
ZodEffects$5.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$5({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$5.ZodEffects,
    ...processCreateParams$5(params)
  });
};
let ZodOptional$5 = class ZodOptional6 extends ZodType$5 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$5.undefined) {
      return OK$5(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$5.create = (type, params) => {
  return new ZodOptional$5({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$5.ZodOptional,
    ...processCreateParams$5(params)
  });
};
let ZodNullable$5 = class ZodNullable6 extends ZodType$5 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$5.null) {
      return OK$5(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$5.create = (type, params) => {
  return new ZodNullable$5({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$5.ZodNullable,
    ...processCreateParams$5(params)
  });
};
let ZodDefault$5 = class ZodDefault6 extends ZodType$5 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$5.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$5.create = (type, params) => {
  return new ZodDefault$5({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$5.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$5(params)
  });
};
let ZodCatch$5 = class ZodCatch6 extends ZodType$5 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$5(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$5(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$5(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$5.create = (type, params) => {
  return new ZodCatch$5({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$5.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$5(params)
  });
};
let ZodNaN$5 = class ZodNaN6 extends ZodType$5 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$5.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$5(ctx, {
        code: ZodIssueCode$5.invalid_type,
        expected: ZodParsedType$5.nan,
        received: ctx.parsedType
      });
      return INVALID$5;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$5.create = (params) => {
  return new ZodNaN$5({
    typeName: ZodFirstPartyTypeKind$5.ZodNaN,
    ...processCreateParams$5(params)
  });
};
const BRAND$5 = Symbol("zod_brand");
let ZodBranded$5 = class ZodBranded6 extends ZodType$5 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$5 = class ZodPipeline6 extends ZodType$5 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$5;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$5(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$5;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline6({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$5.ZodPipeline
    });
  }
};
let ZodReadonly$5 = class ZodReadonly6 extends ZodType$5 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$5(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$5(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$5.create = (type, params) => {
  return new ZodReadonly$5({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$5.ZodReadonly,
    ...processCreateParams$5(params)
  });
};
function cleanParams$5(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom$5(check, _params = {}, fatal) {
  if (check)
    return ZodAny$5.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams$5(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams$5(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny$5.create();
}
const late$5 = {
  object: ZodObject$5.lazycreate
};
var ZodFirstPartyTypeKind$5;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$5 || (ZodFirstPartyTypeKind$5 = {}));
const instanceOfType$5 = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom$5((data) => data instanceof cls, params);
const stringType$5 = ZodString$5.create;
const numberType$5 = ZodNumber$5.create;
const nanType$5 = ZodNaN$5.create;
const bigIntType$5 = ZodBigInt$5.create;
const booleanType$5 = ZodBoolean$5.create;
const dateType$5 = ZodDate$5.create;
const symbolType$5 = ZodSymbol$5.create;
const undefinedType$5 = ZodUndefined$5.create;
const nullType$5 = ZodNull$5.create;
const anyType$5 = ZodAny$5.create;
const unknownType$5 = ZodUnknown$5.create;
const neverType$5 = ZodNever$5.create;
const voidType$5 = ZodVoid$5.create;
const arrayType$5 = ZodArray$5.create;
const objectType$5 = ZodObject$5.create;
const strictObjectType$5 = ZodObject$5.strictCreate;
const unionType$5 = ZodUnion$5.create;
const discriminatedUnionType$5 = ZodDiscriminatedUnion$5.create;
const intersectionType$5 = ZodIntersection$5.create;
const tupleType$5 = ZodTuple$5.create;
const recordType$5 = ZodRecord$5.create;
const mapType$5 = ZodMap$5.create;
const setType$5 = ZodSet$5.create;
const functionType$5 = ZodFunction$5.create;
const lazyType$5 = ZodLazy$5.create;
const literalType$5 = ZodLiteral$5.create;
const enumType$5 = ZodEnum$5.create;
const nativeEnumType$5 = ZodNativeEnum$5.create;
const promiseType$5 = ZodPromise$5.create;
const effectsType$5 = ZodEffects$5.create;
const optionalType$5 = ZodOptional$5.create;
const nullableType$5 = ZodNullable$5.create;
const preprocessType$5 = ZodEffects$5.createWithPreprocess;
const pipelineType$5 = ZodPipeline$5.create;
const ostring$5 = () => stringType$5().optional();
const onumber$5 = () => numberType$5().optional();
const oboolean$5 = () => booleanType$5().optional();
const coerce$5 = {
  string: (arg) => ZodString$5.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber$5.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean$5.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt$5.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate$5.create({ ...arg, coerce: true })
};
const NEVER$5 = INVALID$5;
var z$5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap$5,
  setErrorMap: setErrorMap$5,
  getErrorMap: getErrorMap$5,
  makeIssue: makeIssue$5,
  EMPTY_PATH: EMPTY_PATH$5,
  addIssueToContext: addIssueToContext$5,
  ParseStatus: ParseStatus$5,
  INVALID: INVALID$5,
  DIRTY: DIRTY$5,
  OK: OK$5,
  isAborted: isAborted$5,
  isDirty: isDirty$5,
  isValid: isValid$5,
  isAsync: isAsync$5,
  get util() {
    return util$5;
  },
  get objectUtil() {
    return objectUtil$5;
  },
  ZodParsedType: ZodParsedType$5,
  getParsedType: getParsedType$5,
  ZodType: ZodType$5,
  datetimeRegex: datetimeRegex$5,
  ZodString: ZodString$5,
  ZodNumber: ZodNumber$5,
  ZodBigInt: ZodBigInt$5,
  ZodBoolean: ZodBoolean$5,
  ZodDate: ZodDate$5,
  ZodSymbol: ZodSymbol$5,
  ZodUndefined: ZodUndefined$5,
  ZodNull: ZodNull$5,
  ZodAny: ZodAny$5,
  ZodUnknown: ZodUnknown$5,
  ZodNever: ZodNever$5,
  ZodVoid: ZodVoid$5,
  ZodArray: ZodArray$5,
  ZodObject: ZodObject$5,
  ZodUnion: ZodUnion$5,
  ZodDiscriminatedUnion: ZodDiscriminatedUnion$5,
  ZodIntersection: ZodIntersection$5,
  ZodTuple: ZodTuple$5,
  ZodRecord: ZodRecord$5,
  ZodMap: ZodMap$5,
  ZodSet: ZodSet$5,
  ZodFunction: ZodFunction$5,
  ZodLazy: ZodLazy$5,
  ZodLiteral: ZodLiteral$5,
  ZodEnum: ZodEnum$5,
  ZodNativeEnum: ZodNativeEnum$5,
  ZodPromise: ZodPromise$5,
  ZodEffects: ZodEffects$5,
  ZodTransformer: ZodEffects$5,
  ZodOptional: ZodOptional$5,
  ZodNullable: ZodNullable$5,
  ZodDefault: ZodDefault$5,
  ZodCatch: ZodCatch$5,
  ZodNaN: ZodNaN$5,
  BRAND: BRAND$5,
  ZodBranded: ZodBranded$5,
  ZodPipeline: ZodPipeline$5,
  ZodReadonly: ZodReadonly$5,
  custom: custom$5,
  Schema: ZodType$5,
  ZodSchema: ZodType$5,
  late: late$5,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind$5;
  },
  coerce: coerce$5,
  any: anyType$5,
  array: arrayType$5,
  bigint: bigIntType$5,
  boolean: booleanType$5,
  date: dateType$5,
  discriminatedUnion: discriminatedUnionType$5,
  effect: effectsType$5,
  "enum": enumType$5,
  "function": functionType$5,
  "instanceof": instanceOfType$5,
  intersection: intersectionType$5,
  lazy: lazyType$5,
  literal: literalType$5,
  map: mapType$5,
  nan: nanType$5,
  nativeEnum: nativeEnumType$5,
  never: neverType$5,
  "null": nullType$5,
  nullable: nullableType$5,
  number: numberType$5,
  object: objectType$5,
  oboolean: oboolean$5,
  onumber: onumber$5,
  optional: optionalType$5,
  ostring: ostring$5,
  pipeline: pipelineType$5,
  preprocess: preprocessType$5,
  promise: promiseType$5,
  record: recordType$5,
  set: setType$5,
  strictObject: strictObjectType$5,
  string: stringType$5,
  symbol: symbolType$5,
  transformer: effectsType$5,
  tuple: tupleType$5,
  "undefined": undefinedType$5,
  union: unionType$5,
  unknown: unknownType$5,
  "void": voidType$5,
  NEVER: NEVER$5,
  ZodIssueCode: ZodIssueCode$5,
  quotelessJson: quotelessJson$5,
  ZodError: ZodError$5
});
const FONT_FAMILY_NAMES$4 = [
  "MODERN_SANS",
  "BOOK_SANS",
  "ORGANIC_SANS",
  "GEOMETRIC_SANS",
  "HEAVY_SANS",
  "ROUNDED_SANS",
  "MODERN_SERIF",
  "BOOK_SERIF",
  "MONOSPACE"
];
const PADDING_SCHEMA$3 = z$5.object({
  top: z$5.number(),
  bottom: z$5.number(),
  right: z$5.number(),
  left: z$5.number()
}).optional().nullable();
z$5.string().regex(/^#[0-9a-fA-F]{6}$/).nullable().optional();
z$5.enum(FONT_FAMILY_NAMES$4).nullable().optional();
const getPadding$3 = (padding) => padding ? `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px` : void 0;
const _hoisted_1$3 = ["href"];
const ImagePropsSchema = z$5.object({
  style: z$5.object({
    padding: PADDING_SCHEMA$3,
    backgroundColor: z$5.string().regex(/^#[0-9a-fA-F]{6}$/).optional().nullable(),
    textAlign: z$5.enum(["center", "left", "right"]).optional().nullable()
  }).optional().nullable(),
  props: z$5.object({
    width: z$5.number().optional().nullable(),
    height: z$5.number().optional().nullable(),
    url: z$5.string().optional().nullable(),
    alt: z$5.string().optional().nullable(),
    linkHref: z$5.string().optional().nullable(),
    contentAlignment: z$5.enum(["top", "middle", "bottom"]).optional().nullable()
  }).optional().nullable()
});
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    style: {},
    props: {}
  },
  setup(__props) {
    const props = __props;
    const imgAttrs = computed(() => {
      var _a, _b, _c;
      return {
        alt: ((_a = props.props) == null ? void 0 : _a.alt) ?? "",
        src: ((_b = props.props) == null ? void 0 : _b.url) ?? "",
        width: width.value,
        height: height.value,
        style: {
          width: width.value,
          height: height.value,
          outline: "none",
          border: "none",
          textDecoration: "none",
          verticalAlign: ((_c = props.props) == null ? void 0 : _c.contentAlignment) ?? "middle",
          display: "inline-block",
          maxWidth: "100%"
        }
      };
    });
    const sectionStyle = computed(() => {
      var _a, _b, _c;
      return {
        padding: getPadding$3((_a = props.style) == null ? void 0 : _a.padding),
        backgroundColor: ((_b = props.style) == null ? void 0 : _b.backgroundColor) ?? void 0,
        textAlign: ((_c = props.style) == null ? void 0 : _c.textAlign) ?? void 0
      };
    });
    const linkHref = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.linkHref) ?? null;
    });
    const width = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.width) ?? void 0;
    });
    const height = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.height) ?? void 0;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        style: normalizeStyle(sectionStyle.value)
      }, [
        !linkHref.value ? (openBlock(), createElementBlock("img", normalizeProps(mergeProps({ key: 0 }, imgAttrs.value)), null, 16)) : (openBlock(), createElementBlock("a", {
          key: 1,
          href: linkHref.value,
          style: { textDecoration: "none" },
          target: "_blank"
        }, [
          createElementVNode("img", normalizeProps(guardReactiveProps(imgAttrs.value)), null, 16)
        ], 8, _hoisted_1$3))
      ], 4);
    };
  }
});
/**
 *  Copyright 2025 AntonyDev
 *  @license MIT
**/
var util$4;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$4 || (util$4 = {}));
var objectUtil$4;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$4 || (objectUtil$4 = {}));
const ZodParsedType$4 = util$4.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$4 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$4.undefined;
    case "string":
      return ZodParsedType$4.string;
    case "number":
      return isNaN(data) ? ZodParsedType$4.nan : ZodParsedType$4.number;
    case "boolean":
      return ZodParsedType$4.boolean;
    case "function":
      return ZodParsedType$4.function;
    case "bigint":
      return ZodParsedType$4.bigint;
    case "symbol":
      return ZodParsedType$4.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$4.array;
      }
      if (data === null) {
        return ZodParsedType$4.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$4.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$4.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$4.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$4.date;
      }
      return ZodParsedType$4.object;
    default:
      return ZodParsedType$4.unknown;
  }
};
const ZodIssueCode$4 = util$4.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson$4 = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
let ZodError$4 = class ZodError7 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError7)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$4.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$4.create = (issues) => {
  const error = new ZodError$4(issues);
  return error;
};
const errorMap$4 = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode$4.invalid_type:
      if (issue.received === ZodParsedType$4.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode$4.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$4.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$4.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$4.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode$4.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$4.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$4.joinValues(issue.options)}`;
      break;
    case ZodIssueCode$4.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$4.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode$4.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$4.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$4.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$4.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util$4.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$4.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$4.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$4.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$4.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$4.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode$4.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$4.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap$4 = errorMap$4;
function setErrorMap$4(map) {
  overrideErrorMap$4 = map;
}
function getErrorMap$4() {
  return overrideErrorMap$4;
}
const makeIssue$4 = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH$4 = [];
function addIssueToContext$4(ctx, issueData) {
  const overrideMap = getErrorMap$4();
  const issue = makeIssue$4({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$4 ? void 0 : errorMap$4
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
let ParseStatus$4 = class ParseStatus7 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$4;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus7.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$4;
      if (value.status === "aborted")
        return INVALID$4;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$4 = Object.freeze({
  status: "aborted"
});
const DIRTY$4 = (value) => ({ status: "dirty", value });
const OK$4 = (value) => ({ status: "valid", value });
const isAborted$4 = (x) => x.status === "aborted";
const isDirty$4 = (x) => x.status === "dirty";
const isValid$4 = (x) => x.status === "valid";
const isAsync$4 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet$4(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet$4(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil$4;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil$4 || (errorUtil$4 = {}));
var _ZodEnum_cache$4, _ZodNativeEnum_cache$4;
let ParseInputLazyPath$4 = class ParseInputLazyPath7 {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$4 = (ctx, result) => {
  if (isValid$4(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$4(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$4(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$4 = class ZodType7 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$4(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$4(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$4(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$4(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$4(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$4(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$4(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$4(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$4(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$4(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$4(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$4(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$4(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$4.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$4({
      schema: this,
      typeName: ZodFirstPartyTypeKind$4.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def2) {
    this.spa = this.safeParseAsync;
    this._def = def2;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$4.create(this, this._def);
  }
  nullable() {
    return ZodNullable$4.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$4.create(this);
  }
  promise() {
    return ZodPromise$4.create(this, this._def);
  }
  or(option) {
    return ZodUnion$4.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$4.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects$4({
      ...processCreateParams$4(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$4.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def2) {
    const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodDefault$4({
      ...processCreateParams$4(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$4.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$4({
      typeName: ZodFirstPartyTypeKind$4.ZodBranded,
      type: this,
      ...processCreateParams$4(this._def)
    });
  }
  catch(def2) {
    const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodCatch$4({
      ...processCreateParams$4(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$4.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$4.create(this, target);
  }
  readonly() {
    return ZodReadonly$4.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$4 = /^c[^\s-]{8,}$/i;
const cuid2Regex$4 = /^[0-9a-z]+$/;
const ulidRegex$4 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$4 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$4 = /^[a-z0-9_-]{21}$/i;
const jwtRegex$4 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$4 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$4 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$4 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$4;
const ipv4Regex$4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$4 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$4 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$4 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$4 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$4 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$4 = new RegExp(`^${dateRegexSource$4}$`);
function timeRegexSource$4(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex$4(args) {
  return new RegExp(`^${timeRegexSource$4(args)}$`);
}
function datetimeRegex$4(args) {
  let regex = `${dateRegexSource$4}T${timeRegexSource$4(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$4(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex$4.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex$4.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$4(jwt, alg) {
  if (!jwtRegex$4.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr$4(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex$4.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex$4.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$4 = class ZodString7 extends ZodType$4 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx2, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.string,
        received: ctx2.parsedType
      });
      return INVALID$4;
    }
    const status = new ParseStatus$4();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$4(ctx, {
              code: ZodIssueCode$4.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$4(ctx, {
              code: ZodIssueCode$4.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "email",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$4) {
          emojiRegex$4 = new RegExp(_emojiRegex$4, "u");
        }
        if (!emojiRegex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "emoji",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "uuid",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "cuid",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "ulid",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "url",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "regex",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$4(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$4;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$4(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "duration",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$4(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "ip",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$4(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "jwt",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$4(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "cidr",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "base64",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$4.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            validation: "base64url",
            code: ZodIssueCode$4.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$4.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$4.invalid_string,
      ...errorUtil$4.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString7({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$4.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$4.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$4.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$4.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$4.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$4.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$4.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$4.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$4.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$4.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$4.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$4.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$4.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil$4.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil$4.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$4.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$4.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil$4.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$4.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$4.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$4.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$4.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$4.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$4.errToObj(message));
  }
  trim() {
    return new ZodString7({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString7({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString7({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$4.create = (params) => {
  var _a;
  return new ZodString$4({
    checks: [],
    typeName: ZodFirstPartyTypeKind$4.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$4(params)
  });
};
function floatSafeRemainder$4(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
let ZodNumber$4 = class ZodNumber7 extends ZodType$4 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx2, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.number,
        received: ctx2.parsedType
      });
      return INVALID$4;
    }
    let ctx = void 0;
    const status = new ParseStatus$4();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$4.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$4(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$4.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$4.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$4.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$4.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$4.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber7({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$4.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber7({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$4.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$4.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$4.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$4.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$4.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$4.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$4.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$4.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$4.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$4.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$4.create = (params) => {
  return new ZodNumber$4({
    checks: [],
    typeName: ZodFirstPartyTypeKind$4.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$4(params)
  });
};
let ZodBigInt$4 = class ZodBigInt7 extends ZodType$4 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$4();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$4.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$4(ctx, {
      code: ZodIssueCode$4.invalid_type,
      expected: ZodParsedType$4.bigint,
      received: ctx.parsedType
    });
    return INVALID$4;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$4.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$4.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$4.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$4.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt7({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$4.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt7({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$4.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$4.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$4.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$4.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$4.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$4.create = (params) => {
  var _a;
  return new ZodBigInt$4({
    checks: [],
    typeName: ZodFirstPartyTypeKind$4.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$4(params)
  });
};
let ZodBoolean$4 = class ZodBoolean7 extends ZodType$4 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.boolean,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    return OK$4(input.data);
  }
};
ZodBoolean$4.create = (params) => {
  return new ZodBoolean$4({
    typeName: ZodFirstPartyTypeKind$4.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$4(params)
  });
};
let ZodDate$4 = class ZodDate7 extends ZodType$4 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx2, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.date,
        received: ctx2.parsedType
      });
      return INVALID$4;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx2, {
        code: ZodIssueCode$4.invalid_date
      });
      return INVALID$4;
    }
    const status = new ParseStatus$4();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$4.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate7({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$4.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$4.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$4.create = (params) => {
  return new ZodDate$4({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$4.ZodDate,
    ...processCreateParams$4(params)
  });
};
let ZodSymbol$4 = class ZodSymbol7 extends ZodType$4 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.symbol,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    return OK$4(input.data);
  }
};
ZodSymbol$4.create = (params) => {
  return new ZodSymbol$4({
    typeName: ZodFirstPartyTypeKind$4.ZodSymbol,
    ...processCreateParams$4(params)
  });
};
let ZodUndefined$4 = class ZodUndefined7 extends ZodType$4 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.undefined,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    return OK$4(input.data);
  }
};
ZodUndefined$4.create = (params) => {
  return new ZodUndefined$4({
    typeName: ZodFirstPartyTypeKind$4.ZodUndefined,
    ...processCreateParams$4(params)
  });
};
let ZodNull$4 = class ZodNull7 extends ZodType$4 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.null,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    return OK$4(input.data);
  }
};
ZodNull$4.create = (params) => {
  return new ZodNull$4({
    typeName: ZodFirstPartyTypeKind$4.ZodNull,
    ...processCreateParams$4(params)
  });
};
let ZodAny$4 = class ZodAny7 extends ZodType$4 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$4(input.data);
  }
};
ZodAny$4.create = (params) => {
  return new ZodAny$4({
    typeName: ZodFirstPartyTypeKind$4.ZodAny,
    ...processCreateParams$4(params)
  });
};
let ZodUnknown$4 = class ZodUnknown7 extends ZodType$4 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$4(input.data);
  }
};
ZodUnknown$4.create = (params) => {
  return new ZodUnknown$4({
    typeName: ZodFirstPartyTypeKind$4.ZodUnknown,
    ...processCreateParams$4(params)
  });
};
let ZodNever$4 = class ZodNever7 extends ZodType$4 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$4(ctx, {
      code: ZodIssueCode$4.invalid_type,
      expected: ZodParsedType$4.never,
      received: ctx.parsedType
    });
    return INVALID$4;
  }
};
ZodNever$4.create = (params) => {
  return new ZodNever$4({
    typeName: ZodFirstPartyTypeKind$4.ZodNever,
    ...processCreateParams$4(params)
  });
};
let ZodVoid$4 = class ZodVoid7 extends ZodType$4 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.void,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    return OK$4(input.data);
  }
};
ZodVoid$4.create = (params) => {
  return new ZodVoid$4({
    typeName: ZodFirstPartyTypeKind$4.ZodVoid,
    ...processCreateParams$4(params)
  });
};
let ZodArray$4 = class ZodArray7 extends ZodType$4 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def2 = this._def;
    if (ctx.parsedType !== ZodParsedType$4.array) {
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.array,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    if (def2.exactLength !== null) {
      const tooBig = ctx.data.length > def2.exactLength.value;
      const tooSmall = ctx.data.length < def2.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$4(ctx, {
          code: tooBig ? ZodIssueCode$4.too_big : ZodIssueCode$4.too_small,
          minimum: tooSmall ? def2.exactLength.value : void 0,
          maximum: tooBig ? def2.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def2.exactLength.message
        });
        status.dirty();
      }
    }
    if (def2.minLength !== null) {
      if (ctx.data.length < def2.minLength.value) {
        addIssueToContext$4(ctx, {
          code: ZodIssueCode$4.too_small,
          minimum: def2.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.minLength.message
        });
        status.dirty();
      }
    }
    if (def2.maxLength !== null) {
      if (ctx.data.length > def2.maxLength.value) {
        addIssueToContext$4(ctx, {
          code: ZodIssueCode$4.too_big,
          maximum: def2.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def2.type._parseAsync(new ParseInputLazyPath$4(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$4.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def2.type._parseSync(new ParseInputLazyPath$4(ctx, item, ctx.path, i));
    });
    return ParseStatus$4.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray7({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$4.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray7({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$4.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray7({
      ...this._def,
      exactLength: { value: len, message: errorUtil$4.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$4.create = (schema, params) => {
  return new ZodArray$4({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$4.ZodArray,
    ...processCreateParams$4(params)
  });
};
function deepPartialify$4(schema) {
  if (schema instanceof ZodObject$4) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$4.create(deepPartialify$4(fieldSchema));
    }
    return new ZodObject$4({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$4) {
    return new ZodArray$4({
      ...schema._def,
      type: deepPartialify$4(schema.element)
    });
  } else if (schema instanceof ZodOptional$4) {
    return ZodOptional$4.create(deepPartialify$4(schema.unwrap()));
  } else if (schema instanceof ZodNullable$4) {
    return ZodNullable$4.create(deepPartialify$4(schema.unwrap()));
  } else if (schema instanceof ZodTuple$4) {
    return ZodTuple$4.create(schema.items.map((item) => deepPartialify$4(item)));
  } else {
    return schema;
  }
}
let ZodObject$4 = class ZodObject7 extends ZodType$4 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$4.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx2, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.object,
        received: ctx2.parsedType
      });
      return INVALID$4;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$4 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$4(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$4) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$4(ctx, {
            code: ZodIssueCode$4.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$4(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$4.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$4.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$4.errToObj;
    return new ZodObject7({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil$4.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject7({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject7({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject7({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject7({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$4.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject7({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util$4.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject7({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util$4.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject7({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$4(this);
  }
  partial(mask) {
    const newShape = {};
    util$4.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject7({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util$4.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$4) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject7({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$4(util$4.objectKeys(this.shape));
  }
};
ZodObject$4.create = (shape, params) => {
  return new ZodObject$4({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$4.create(),
    typeName: ZodFirstPartyTypeKind$4.ZodObject,
    ...processCreateParams$4(params)
  });
};
ZodObject$4.strictCreate = (shape, params) => {
  return new ZodObject$4({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$4.create(),
    typeName: ZodFirstPartyTypeKind$4.ZodObject,
    ...processCreateParams$4(params)
  });
};
ZodObject$4.lazycreate = (shape, params) => {
  return new ZodObject$4({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$4.create(),
    typeName: ZodFirstPartyTypeKind$4.ZodObject,
    ...processCreateParams$4(params)
  });
};
let ZodUnion$4 = class ZodUnion7 extends ZodType$4 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$4(result.ctx.common.issues));
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_union,
        unionErrors
      });
      return INVALID$4;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$4(issues2));
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_union,
        unionErrors
      });
      return INVALID$4;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$4.create = (types, params) => {
  return new ZodUnion$4({
    options: types,
    typeName: ZodFirstPartyTypeKind$4.ZodUnion,
    ...processCreateParams$4(params)
  });
};
const getDiscriminator$4 = (type) => {
  if (type instanceof ZodLazy$4) {
    return getDiscriminator$4(type.schema);
  } else if (type instanceof ZodEffects$4) {
    return getDiscriminator$4(type.innerType());
  } else if (type instanceof ZodLiteral$4) {
    return [type.value];
  } else if (type instanceof ZodEnum$4) {
    return type.options;
  } else if (type instanceof ZodNativeEnum$4) {
    return util$4.objectValues(type.enum);
  } else if (type instanceof ZodDefault$4) {
    return getDiscriminator$4(type._def.innerType);
  } else if (type instanceof ZodUndefined$4) {
    return [void 0];
  } else if (type instanceof ZodNull$4) {
    return [null];
  } else if (type instanceof ZodOptional$4) {
    return [void 0, ...getDiscriminator$4(type.unwrap())];
  } else if (type instanceof ZodNullable$4) {
    return [null, ...getDiscriminator$4(type.unwrap())];
  } else if (type instanceof ZodBranded$4) {
    return getDiscriminator$4(type.unwrap());
  } else if (type instanceof ZodReadonly$4) {
    return getDiscriminator$4(type.unwrap());
  } else if (type instanceof ZodCatch$4) {
    return getDiscriminator$4(type._def.innerType);
  } else {
    return [];
  }
};
let ZodDiscriminatedUnion$4 = class ZodDiscriminatedUnion7 extends ZodType$4 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$4.object) {
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.object,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID$4;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator$4(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion7({
      typeName: ZodFirstPartyTypeKind$4.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams$4(params)
    });
  }
};
function mergeValues$4(a, b) {
  const aType = getParsedType$4(a);
  const bType = getParsedType$4(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$4.object && bType === ZodParsedType$4.object) {
    const bKeys = util$4.objectKeys(b);
    const sharedKeys = util$4.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$4(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$4.array && bType === ZodParsedType$4.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$4(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$4.date && bType === ZodParsedType$4.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$4 = class ZodIntersection7 extends ZodType$4 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$4(parsedLeft) || isAborted$4(parsedRight)) {
        return INVALID$4;
      }
      const merged = mergeValues$4(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$4(ctx, {
          code: ZodIssueCode$4.invalid_intersection_types
        });
        return INVALID$4;
      }
      if (isDirty$4(parsedLeft) || isDirty$4(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$4.create = (left, right, params) => {
  return new ZodIntersection$4({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$4.ZodIntersection,
    ...processCreateParams$4(params)
  });
};
let ZodTuple$4 = class ZodTuple7 extends ZodType$4 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$4.array) {
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.array,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$4;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$4(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$4.mergeArray(status, results);
      });
    } else {
      return ParseStatus$4.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple7({
      ...this._def,
      rest
    });
  }
};
ZodTuple$4.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$4({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$4.ZodTuple,
    rest: null,
    ...processCreateParams$4(params)
  });
};
let ZodRecord$4 = class ZodRecord7 extends ZodType$4 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$4.object) {
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.object,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath$4(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath$4(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus$4.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus$4.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType$4) {
      return new ZodRecord7({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind$4.ZodRecord,
        ...processCreateParams$4(third)
      });
    }
    return new ZodRecord7({
      keyType: ZodString$4.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind$4.ZodRecord,
      ...processCreateParams$4(second)
    });
  }
};
let ZodMap$4 = class ZodMap7 extends ZodType$4 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$4.map) {
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.map,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$4(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$4(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$4;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$4;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$4.create = (keyType, valueType, params) => {
  return new ZodMap$4({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$4.ZodMap,
    ...processCreateParams$4(params)
  });
};
let ZodSet$4 = class ZodSet7 extends ZodType$4 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$4.set) {
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.set,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    const def2 = this._def;
    if (def2.minSize !== null) {
      if (ctx.data.size < def2.minSize.value) {
        addIssueToContext$4(ctx, {
          code: ZodIssueCode$4.too_small,
          minimum: def2.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.minSize.message
        });
        status.dirty();
      }
    }
    if (def2.maxSize !== null) {
      if (ctx.data.size > def2.maxSize.value) {
        addIssueToContext$4(ctx, {
          code: ZodIssueCode$4.too_big,
          maximum: def2.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements22) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements22) {
        if (element.status === "aborted")
          return INVALID$4;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements2 = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$4(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements2).then((elements22) => finalizeSet(elements22));
    } else {
      return finalizeSet(elements2);
    }
  }
  min(minSize, message) {
    return new ZodSet7({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$4.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet7({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$4.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$4.create = (valueType, params) => {
  return new ZodSet$4({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$4.ZodSet,
    ...processCreateParams$4(params)
  });
};
let ZodFunction$4 = class ZodFunction7 extends ZodType$4 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$4.function) {
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.function,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    function makeArgsIssue(args, error) {
      return makeIssue$4({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$4(),
          errorMap$4
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$4.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue$4({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$4(),
          errorMap$4
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$4.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise$4) {
      const me = this;
      return OK$4(async function(...args) {
        const error = new ZodError$4([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK$4(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError$4([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError$4([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction7({
      ...this._def,
      args: ZodTuple$4.create(items).rest(ZodUnknown$4.create())
    });
  }
  returns(returnType) {
    return new ZodFunction7({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction7({
      args: args ? args : ZodTuple$4.create([]).rest(ZodUnknown$4.create()),
      returns: returns || ZodUnknown$4.create(),
      typeName: ZodFirstPartyTypeKind$4.ZodFunction,
      ...processCreateParams$4(params)
    });
  }
};
let ZodLazy$4 = class ZodLazy7 extends ZodType$4 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$4.create = (getter, params) => {
  return new ZodLazy$4({
    getter,
    typeName: ZodFirstPartyTypeKind$4.ZodLazy,
    ...processCreateParams$4(params)
  });
};
let ZodLiteral$4 = class ZodLiteral7 extends ZodType$4 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx, {
        received: ctx.data,
        code: ZodIssueCode$4.invalid_literal,
        expected: this._def.value
      });
      return INVALID$4;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$4.create = (value, params) => {
  return new ZodLiteral$4({
    value,
    typeName: ZodFirstPartyTypeKind$4.ZodLiteral,
    ...processCreateParams$4(params)
  });
};
function createZodEnum$4(values, params) {
  return new ZodEnum$4({
    values,
    typeName: ZodFirstPartyTypeKind$4.ZodEnum,
    ...processCreateParams$4(params)
  });
}
let ZodEnum$4 = class ZodEnum7 extends ZodType$4 {
  constructor() {
    super(...arguments);
    _ZodEnum_cache$4.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$4(ctx, {
        expected: util$4.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$4.invalid_type
      });
      return INVALID$4;
    }
    if (!__classPrivateFieldGet$4(this, _ZodEnum_cache$4)) {
      __classPrivateFieldSet$4(this, _ZodEnum_cache$4, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet$4(this, _ZodEnum_cache$4).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$4(ctx, {
        received: ctx.data,
        code: ZodIssueCode$4.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$4;
    }
    return OK$4(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum7.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum7.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache$4 = /* @__PURE__ */ new WeakMap();
ZodEnum$4.create = createZodEnum$4;
let ZodNativeEnum$4 = class ZodNativeEnum7 extends ZodType$4 {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache$4.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util$4.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$4.string && ctx.parsedType !== ZodParsedType$4.number) {
      const expectedValues = util$4.objectValues(nativeEnumValues);
      addIssueToContext$4(ctx, {
        expected: util$4.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$4.invalid_type
      });
      return INVALID$4;
    }
    if (!__classPrivateFieldGet$4(this, _ZodNativeEnum_cache$4)) {
      __classPrivateFieldSet$4(this, _ZodNativeEnum_cache$4, new Set(util$4.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet$4(this, _ZodNativeEnum_cache$4).has(input.data)) {
      const expectedValues = util$4.objectValues(nativeEnumValues);
      addIssueToContext$4(ctx, {
        received: ctx.data,
        code: ZodIssueCode$4.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$4;
    }
    return OK$4(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache$4 = /* @__PURE__ */ new WeakMap();
ZodNativeEnum$4.create = (values, params) => {
  return new ZodNativeEnum$4({
    values,
    typeName: ZodFirstPartyTypeKind$4.ZodNativeEnum,
    ...processCreateParams$4(params)
  });
};
let ZodPromise$4 = class ZodPromise7 extends ZodType$4 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$4.promise && ctx.common.async === false) {
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.promise,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    const promisified = ctx.parsedType === ZodParsedType$4.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$4(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$4.create = (schema, params) => {
  return new ZodPromise$4({
    type: schema,
    typeName: ZodFirstPartyTypeKind$4.ZodPromise,
    ...processCreateParams$4(params)
  });
};
let ZodEffects$4 = class ZodEffects7 extends ZodType$4 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$4.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$4(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$4;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$4;
          if (result.status === "dirty")
            return DIRTY$4(result.value);
          if (status.value === "dirty")
            return DIRTY$4(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$4;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$4;
        if (result.status === "dirty")
          return DIRTY$4(result.value);
        if (status.value === "dirty")
          return DIRTY$4(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$4;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$4;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$4(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$4(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util$4.assertNever(effect);
  }
};
ZodEffects$4.create = (schema, effect, params) => {
  return new ZodEffects$4({
    schema,
    typeName: ZodFirstPartyTypeKind$4.ZodEffects,
    effect,
    ...processCreateParams$4(params)
  });
};
ZodEffects$4.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$4({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$4.ZodEffects,
    ...processCreateParams$4(params)
  });
};
let ZodOptional$4 = class ZodOptional7 extends ZodType$4 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$4.undefined) {
      return OK$4(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$4.create = (type, params) => {
  return new ZodOptional$4({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$4.ZodOptional,
    ...processCreateParams$4(params)
  });
};
let ZodNullable$4 = class ZodNullable7 extends ZodType$4 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$4.null) {
      return OK$4(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$4.create = (type, params) => {
  return new ZodNullable$4({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$4.ZodNullable,
    ...processCreateParams$4(params)
  });
};
let ZodDefault$4 = class ZodDefault7 extends ZodType$4 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$4.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$4.create = (type, params) => {
  return new ZodDefault$4({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$4.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$4(params)
  });
};
let ZodCatch$4 = class ZodCatch7 extends ZodType$4 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$4(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$4(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$4(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$4.create = (type, params) => {
  return new ZodCatch$4({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$4.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$4(params)
  });
};
let ZodNaN$4 = class ZodNaN7 extends ZodType$4 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$4.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$4(ctx, {
        code: ZodIssueCode$4.invalid_type,
        expected: ZodParsedType$4.nan,
        received: ctx.parsedType
      });
      return INVALID$4;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$4.create = (params) => {
  return new ZodNaN$4({
    typeName: ZodFirstPartyTypeKind$4.ZodNaN,
    ...processCreateParams$4(params)
  });
};
const BRAND$4 = Symbol("zod_brand");
let ZodBranded$4 = class ZodBranded7 extends ZodType$4 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$4 = class ZodPipeline7 extends ZodType$4 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$4;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$4(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$4;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline7({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$4.ZodPipeline
    });
  }
};
let ZodReadonly$4 = class ZodReadonly7 extends ZodType$4 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$4(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$4(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$4.create = (type, params) => {
  return new ZodReadonly$4({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$4.ZodReadonly,
    ...processCreateParams$4(params)
  });
};
function cleanParams$4(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom$4(check, _params = {}, fatal) {
  if (check)
    return ZodAny$4.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams$4(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams$4(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny$4.create();
}
const late$4 = {
  object: ZodObject$4.lazycreate
};
var ZodFirstPartyTypeKind$4;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$4 || (ZodFirstPartyTypeKind$4 = {}));
const instanceOfType$4 = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom$4((data) => data instanceof cls, params);
const stringType$4 = ZodString$4.create;
const numberType$4 = ZodNumber$4.create;
const nanType$4 = ZodNaN$4.create;
const bigIntType$4 = ZodBigInt$4.create;
const booleanType$4 = ZodBoolean$4.create;
const dateType$4 = ZodDate$4.create;
const symbolType$4 = ZodSymbol$4.create;
const undefinedType$4 = ZodUndefined$4.create;
const nullType$4 = ZodNull$4.create;
const anyType$4 = ZodAny$4.create;
const unknownType$4 = ZodUnknown$4.create;
const neverType$4 = ZodNever$4.create;
const voidType$4 = ZodVoid$4.create;
const arrayType$4 = ZodArray$4.create;
const objectType$4 = ZodObject$4.create;
const strictObjectType$4 = ZodObject$4.strictCreate;
const unionType$4 = ZodUnion$4.create;
const discriminatedUnionType$4 = ZodDiscriminatedUnion$4.create;
const intersectionType$4 = ZodIntersection$4.create;
const tupleType$4 = ZodTuple$4.create;
const recordType$4 = ZodRecord$4.create;
const mapType$4 = ZodMap$4.create;
const setType$4 = ZodSet$4.create;
const functionType$4 = ZodFunction$4.create;
const lazyType$4 = ZodLazy$4.create;
const literalType$4 = ZodLiteral$4.create;
const enumType$4 = ZodEnum$4.create;
const nativeEnumType$4 = ZodNativeEnum$4.create;
const promiseType$4 = ZodPromise$4.create;
const effectsType$4 = ZodEffects$4.create;
const optionalType$4 = ZodOptional$4.create;
const nullableType$4 = ZodNullable$4.create;
const preprocessType$4 = ZodEffects$4.createWithPreprocess;
const pipelineType$4 = ZodPipeline$4.create;
const ostring$4 = () => stringType$4().optional();
const onumber$4 = () => numberType$4().optional();
const oboolean$4 = () => booleanType$4().optional();
const coerce$4 = {
  string: (arg) => ZodString$4.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber$4.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean$4.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt$4.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate$4.create({ ...arg, coerce: true })
};
const NEVER$4 = INVALID$4;
var z$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap$4,
  setErrorMap: setErrorMap$4,
  getErrorMap: getErrorMap$4,
  makeIssue: makeIssue$4,
  EMPTY_PATH: EMPTY_PATH$4,
  addIssueToContext: addIssueToContext$4,
  ParseStatus: ParseStatus$4,
  INVALID: INVALID$4,
  DIRTY: DIRTY$4,
  OK: OK$4,
  isAborted: isAborted$4,
  isDirty: isDirty$4,
  isValid: isValid$4,
  isAsync: isAsync$4,
  get util() {
    return util$4;
  },
  get objectUtil() {
    return objectUtil$4;
  },
  ZodParsedType: ZodParsedType$4,
  getParsedType: getParsedType$4,
  ZodType: ZodType$4,
  datetimeRegex: datetimeRegex$4,
  ZodString: ZodString$4,
  ZodNumber: ZodNumber$4,
  ZodBigInt: ZodBigInt$4,
  ZodBoolean: ZodBoolean$4,
  ZodDate: ZodDate$4,
  ZodSymbol: ZodSymbol$4,
  ZodUndefined: ZodUndefined$4,
  ZodNull: ZodNull$4,
  ZodAny: ZodAny$4,
  ZodUnknown: ZodUnknown$4,
  ZodNever: ZodNever$4,
  ZodVoid: ZodVoid$4,
  ZodArray: ZodArray$4,
  ZodObject: ZodObject$4,
  ZodUnion: ZodUnion$4,
  ZodDiscriminatedUnion: ZodDiscriminatedUnion$4,
  ZodIntersection: ZodIntersection$4,
  ZodTuple: ZodTuple$4,
  ZodRecord: ZodRecord$4,
  ZodMap: ZodMap$4,
  ZodSet: ZodSet$4,
  ZodFunction: ZodFunction$4,
  ZodLazy: ZodLazy$4,
  ZodLiteral: ZodLiteral$4,
  ZodEnum: ZodEnum$4,
  ZodNativeEnum: ZodNativeEnum$4,
  ZodPromise: ZodPromise$4,
  ZodEffects: ZodEffects$4,
  ZodTransformer: ZodEffects$4,
  ZodOptional: ZodOptional$4,
  ZodNullable: ZodNullable$4,
  ZodDefault: ZodDefault$4,
  ZodCatch: ZodCatch$4,
  ZodNaN: ZodNaN$4,
  BRAND: BRAND$4,
  ZodBranded: ZodBranded$4,
  ZodPipeline: ZodPipeline$4,
  ZodReadonly: ZodReadonly$4,
  custom: custom$4,
  Schema: ZodType$4,
  ZodSchema: ZodType$4,
  late: late$4,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind$4;
  },
  coerce: coerce$4,
  any: anyType$4,
  array: arrayType$4,
  bigint: bigIntType$4,
  boolean: booleanType$4,
  date: dateType$4,
  discriminatedUnion: discriminatedUnionType$4,
  effect: effectsType$4,
  "enum": enumType$4,
  "function": functionType$4,
  "instanceof": instanceOfType$4,
  intersection: intersectionType$4,
  lazy: lazyType$4,
  literal: literalType$4,
  map: mapType$4,
  nan: nanType$4,
  nativeEnum: nativeEnumType$4,
  never: neverType$4,
  "null": nullType$4,
  nullable: nullableType$4,
  number: numberType$4,
  object: objectType$4,
  oboolean: oboolean$4,
  onumber: onumber$4,
  optional: optionalType$4,
  ostring: ostring$4,
  pipeline: pipelineType$4,
  preprocess: preprocessType$4,
  promise: promiseType$4,
  record: recordType$4,
  set: setType$4,
  strictObject: strictObjectType$4,
  string: stringType$4,
  symbol: symbolType$4,
  transformer: effectsType$4,
  tuple: tupleType$4,
  "undefined": undefinedType$4,
  union: unionType$4,
  unknown: unknownType$4,
  "void": voidType$4,
  NEVER: NEVER$4,
  ZodIssueCode: ZodIssueCode$4,
  quotelessJson: quotelessJson$4,
  ZodError: ZodError$4
});
const SpacerPropsSchema = z$4.object({
  props: z$4.object({
    height: z$4.number().gte(0).optional().nullish()
  }).optional().nullable()
});
const SpacerPropsDefaults = {
  height: 16
};
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    props: {}
  },
  setup(__props) {
    const props = __props;
    const style = computed(() => {
      var _a;
      return {
        height: (((_a = props.props) == null ? void 0 : _a.height) ?? SpacerPropsDefaults.height) + "px"
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        style: normalizeStyle(style.value)
      }, null, 4);
    };
  }
});
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var she;
var hasRequiredShe;
function requireShe() {
  if (hasRequiredShe) return she;
  hasRequiredShe = 1;
  var escapes = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  var unescapes = {
    "&amp;": "&",
    "&lt;": "<",
    "&gt;": ">",
    "&quot;": '"',
    "&#39;": "'"
  };
  var rescaped = /(&amp;|&lt;|&gt;|&quot;|&#39;)/g;
  var runescaped = /[&<>"']/g;
  function escapeHtmlChar(match) {
    return escapes[match];
  }
  function unescapeHtmlChar(match) {
    return unescapes[match];
  }
  function escapeHtml(text) {
    return text == null ? "" : String(text).replace(runescaped, escapeHtmlChar);
  }
  function unescapeHtml(html2) {
    return html2 == null ? "" : String(html2).replace(rescaped, unescapeHtmlChar);
  }
  escapeHtml.options = unescapeHtml.options = {};
  she = {
    encode: escapeHtml,
    escape: escapeHtml,
    decode: unescapeHtml,
    unescape: unescapeHtml,
    version: "1.0.0-browser"
  };
  return she;
}
var assignment_1;
var hasRequiredAssignment;
function requireAssignment() {
  if (hasRequiredAssignment) return assignment_1;
  hasRequiredAssignment = 1;
  function assignment(result) {
    var stack = Array.prototype.slice.call(arguments, 1);
    var item;
    var key;
    while (stack.length) {
      item = stack.shift();
      for (key in item) {
        if (item.hasOwnProperty(key)) {
          if (Object.prototype.toString.call(result[key]) === "[object Object]") {
            result[key] = assignment(result[key], item[key]);
          } else {
            result[key] = item[key];
          }
        }
      }
    }
    return result;
  }
  assignment_1 = assignment;
  return assignment_1;
}
var lowercase;
var hasRequiredLowercase;
function requireLowercase() {
  if (hasRequiredLowercase) return lowercase;
  hasRequiredLowercase = 1;
  lowercase = function lowercase2(string) {
    return typeof string === "string" ? string.toLowerCase() : string;
  };
  return lowercase;
}
var toMap_1;
var hasRequiredToMap;
function requireToMap() {
  if (hasRequiredToMap) return toMap_1;
  hasRequiredToMap = 1;
  function toMap(list2) {
    return list2.reduce(asKey, {});
  }
  function asKey(accumulator, item) {
    accumulator[item] = true;
    return accumulator;
  }
  toMap_1 = toMap;
  return toMap_1;
}
var attributes;
var hasRequiredAttributes;
function requireAttributes() {
  if (hasRequiredAttributes) return attributes;
  hasRequiredAttributes = 1;
  var toMap = requireToMap();
  var uris = ["background", "base", "cite", "href", "longdesc", "src", "usemap"];
  attributes = {
    uris: toMap(uris)
    // attributes that have an href and hence need to be sanitized
  };
  return attributes;
}
var elements;
var hasRequiredElements;
function requireElements() {
  if (hasRequiredElements) return elements;
  hasRequiredElements = 1;
  var toMap = requireToMap();
  var voids = ["area", "br", "col", "hr", "img", "wbr", "input", "base", "basefont", "link", "meta"];
  elements = {
    voids: toMap(voids)
  };
  return elements;
}
var parser_1;
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser_1;
  hasRequiredParser = 1;
  var he = requireShe();
  var lowercase2 = requireLowercase();
  requireAttributes();
  var elements2 = requireElements();
  var rstart = /^<\s*([\w:-]+)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*>/;
  var rend = /^<\s*\/\s*([\w:-]+)[^>]*>/;
  var rattrs = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g;
  var rtag = /^</;
  var rtagend = /^<\s*\//;
  function createStack() {
    var stack = [];
    stack.lastItem = function lastItem() {
      return stack[stack.length - 1];
    };
    return stack;
  }
  function parser(html2, handler) {
    var stack = createStack();
    var last = html2;
    var chars;
    while (html2) {
      parsePart();
    }
    parseEndTag();
    function parsePart() {
      chars = true;
      parseTag();
      var same = html2 === last;
      last = html2;
      if (same) {
        html2 = "";
      }
    }
    function parseTag() {
      if (html2.substr(0, 4) === "<!--") {
        parseComment();
      } else if (rtagend.test(html2)) {
        parseEdge(rend, parseEndTag);
      } else if (rtag.test(html2)) {
        parseEdge(rstart, parseStartTag);
      }
      parseTagDecode();
    }
    function parseEdge(regex, parser2) {
      var match = html2.match(regex);
      if (match) {
        html2 = html2.substring(match[0].length);
        match[0].replace(regex, parser2);
        chars = false;
      }
    }
    function parseComment() {
      var index = html2.indexOf("-->");
      if (index >= 0) {
        if (handler.comment) {
          handler.comment(html2.substring(4, index));
        }
        html2 = html2.substring(index + 3);
        chars = false;
      }
    }
    function parseTagDecode() {
      if (!chars) {
        return;
      }
      var text;
      var index = html2.indexOf("<");
      if (index >= 0) {
        text = html2.substring(0, index);
        html2 = html2.substring(index);
      } else {
        text = html2;
        html2 = "";
      }
      if (handler.chars) {
        handler.chars(text);
      }
    }
    function parseStartTag(tag2, tagName, rest, unary) {
      var attrs = {};
      var low = lowercase2(tagName);
      var u = elements2.voids[low] || !!unary;
      rest.replace(rattrs, attrReplacer);
      if (!u) {
        stack.push(low);
      }
      if (handler.start) {
        handler.start(low, attrs, u);
      }
      function attrReplacer(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
        if (doubleQuotedValue === void 0 && singleQuotedValue === void 0 && unquotedValue === void 0) {
          attrs[name] = void 0;
        } else {
          attrs[name] = he.decode(doubleQuotedValue || singleQuotedValue || unquotedValue || "");
        }
      }
    }
    function parseEndTag(tag2, tagName) {
      var i;
      var pos = 0;
      var low = lowercase2(tagName);
      if (low) {
        for (pos = stack.length - 1; pos >= 0; pos--) {
          if (stack[pos] === low) {
            break;
          }
        }
      }
      if (pos >= 0) {
        for (i = stack.length - 1; i >= pos; i--) {
          if (handler.end) {
            handler.end(stack[i]);
          }
        }
        stack.length = pos;
      }
    }
  }
  parser_1 = parser;
  return parser_1;
}
var sanitizer_1;
var hasRequiredSanitizer;
function requireSanitizer() {
  if (hasRequiredSanitizer) return sanitizer_1;
  hasRequiredSanitizer = 1;
  var he = requireShe();
  var lowercase2 = requireLowercase();
  var attributes2 = requireAttributes();
  var elements2 = requireElements();
  function sanitizer(buffer, options) {
    var context;
    var o = options || {};
    reset();
    return {
      start,
      end,
      chars
    };
    function out(value) {
      buffer.push(value);
    }
    function start(tag2, attrs, unary) {
      var low = lowercase2(tag2);
      if (context.ignoring) {
        ignore(low);
        return;
      }
      if ((o.allowedTags || []).indexOf(low) === -1) {
        ignore(low);
        return;
      }
      if (o.filter && !o.filter({ tag: low, attrs })) {
        ignore(low);
        return;
      }
      out("<");
      out(low);
      Object.keys(attrs).forEach(parse);
      out(unary ? "/>" : ">");
      function parse(key) {
        var value = attrs[key];
        var classesOk = (o.allowedClasses || {})[low] || [];
        var attrsOk = (o.allowedAttributes || {})[low] || [];
        var valid;
        var lkey = lowercase2(key);
        if (lkey === "class" && attrsOk.indexOf(lkey) === -1) {
          value = value.split(" ").filter(isValidClass).join(" ").trim();
          valid = value.length;
        } else {
          valid = attrsOk.indexOf(lkey) !== -1 && (attributes2.uris[lkey] !== true || testUrl(value));
        }
        if (valid) {
          out(" ");
          out(key);
          if (typeof value === "string") {
            out('="');
            out(he.encode(value));
            out('"');
          }
        }
        function isValidClass(className) {
          return classesOk && classesOk.indexOf(className) !== -1;
        }
      }
    }
    function end(tag2) {
      var low = lowercase2(tag2);
      var allowed = (o.allowedTags || []).indexOf(low) !== -1;
      if (allowed) {
        if (context.ignoring === false) {
          out("</");
          out(low);
          out(">");
        } else {
          unignore(low);
        }
      } else {
        unignore(low);
      }
    }
    function testUrl(text) {
      var start2 = text[0];
      if (start2 === "#" || start2 === "/") {
        return true;
      }
      var colon = text.indexOf(":");
      if (colon === -1) {
        return true;
      }
      var questionmark = text.indexOf("?");
      if (questionmark !== -1 && colon > questionmark) {
        return true;
      }
      var hash = text.indexOf("#");
      if (hash !== -1 && colon > hash) {
        return true;
      }
      return o.allowedSchemes.some(matches);
      function matches(scheme) {
        return text.indexOf(scheme + ":") === 0;
      }
    }
    function chars(text) {
      if (context.ignoring === false) {
        out(o.transformText ? o.transformText(text) : text);
      }
    }
    function ignore(tag2) {
      if (elements2.voids[tag2]) {
        return;
      }
      if (context.ignoring === false) {
        context = { ignoring: tag2, depth: 1 };
      } else if (context.ignoring === tag2) {
        context.depth++;
      }
    }
    function unignore(tag2) {
      if (context.ignoring === tag2) {
        if (--context.depth <= 0) {
          reset();
        }
      }
    }
    function reset() {
      context = { ignoring: false, depth: 0 };
    }
  }
  sanitizer_1 = sanitizer;
  return sanitizer_1;
}
var defaults_1;
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults) return defaults_1;
  hasRequiredDefaults = 1;
  var defaults = {
    allowedAttributes: {
      a: ["href", "name", "target", "title", "aria-label"],
      iframe: ["allowfullscreen", "frameborder", "src"],
      img: ["src", "alt", "title", "aria-label"]
    },
    allowedClasses: {},
    allowedSchemes: ["http", "https", "mailto"],
    allowedTags: [
      "a",
      "abbr",
      "article",
      "b",
      "blockquote",
      "br",
      "caption",
      "code",
      "del",
      "details",
      "div",
      "em",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "hr",
      "i",
      "img",
      "ins",
      "kbd",
      "li",
      "main",
      "mark",
      "ol",
      "p",
      "pre",
      "section",
      "span",
      "strike",
      "strong",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "th",
      "thead",
      "tr",
      "u",
      "ul"
    ],
    filter: null
  };
  defaults_1 = defaults;
  return defaults_1;
}
var insane_1;
var hasRequiredInsane;
function requireInsane() {
  if (hasRequiredInsane) return insane_1;
  hasRequiredInsane = 1;
  requireShe();
  var assign = requireAssignment();
  var parser = requireParser();
  var sanitizer = requireSanitizer();
  var defaults = requireDefaults();
  function insane2(html2, options, strict) {
    var buffer = [];
    var configuration = strict === true ? options : assign({}, defaults, options);
    var handler = sanitizer(buffer, configuration);
    parser(html2, handler);
    return buffer.join("");
  }
  insane2.defaults = defaults;
  insane_1 = insane2;
  return insane_1;
}
var insaneExports = requireInsane();
const insane = /* @__PURE__ */ getDefaultExportFromCjs(insaneExports);
function _getDefaults() {
  return {
    async: false,
    breaks: false,
    extensions: null,
    gfm: true,
    hooks: null,
    pedantic: false,
    renderer: null,
    silent: false,
    tokenizer: null,
    walkTokens: null
  };
}
let _defaults = _getDefaults();
function changeDefaults(newDefaults) {
  _defaults = newDefaults;
}
const noopTest = { exec: () => null };
function edit(regex, opt = "") {
  let source = typeof regex === "string" ? regex : regex.source;
  const obj = {
    replace: (name, val) => {
      let valSource = typeof val === "string" ? val : val.source;
      valSource = valSource.replace(other.caret, "$1");
      source = source.replace(name, valSource);
      return obj;
    },
    getRegex: () => {
      return new RegExp(source, opt);
    }
  };
  return obj;
}
const other = {
  codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
  outputLinkReplace: /\\([\[\]])/g,
  indentCodeCompensation: /^(\s+)(?:```)/,
  beginningSpace: /^\s+/,
  endingHash: /#$/,
  startingSpaceChar: /^ /,
  endingSpaceChar: / $/,
  nonSpaceChar: /[^ ]/,
  newLineCharGlobal: /\n/g,
  tabCharGlobal: /\t/g,
  multipleSpaceGlobal: /\s+/g,
  blankLine: /^[ \t]*$/,
  doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
  blockquoteStart: /^ {0,3}>/,
  blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
  blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
  listReplaceTabs: /^\t+/,
  listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
  listIsTask: /^\[[ xX]\] /,
  listReplaceTask: /^\[[ xX]\] +/,
  anyLine: /\n.*\n/,
  hrefBrackets: /^<(.*)>$/,
  tableDelimiter: /[:|]/,
  tableAlignChars: /^\||\| *$/g,
  tableRowBlankLine: /\n[ \t]*$/,
  tableAlignRight: /^ *-+: *$/,
  tableAlignCenter: /^ *:-+: *$/,
  tableAlignLeft: /^ *:-+ *$/,
  startATag: /^<a /i,
  endATag: /^<\/a>/i,
  startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
  endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
  startAngleBracket: /^</,
  endAngleBracket: />$/,
  pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
  unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
  escapeTest: /[&<>"']/,
  escapeReplace: /[&<>"']/g,
  escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
  escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
  unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
  caret: /(^|[^\[])\^/g,
  percentDecode: /%25/g,
  findPipe: /\|/g,
  splitPipe: / \|/,
  slashPipe: /\\\|/g,
  carriageReturn: /\r\n|\r/g,
  spaceLine: /^ +$/gm,
  notSpaceStart: /^\S*/,
  endingNewline: /\n$/,
  listItemRegex: (bull) => new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`),
  nextBulletRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
  hrRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
  fencesBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`),
  headingBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),
  htmlBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, "i")
};
const newline = /^(?:[ \t]*(?:\n|$))+/;
const blockCode = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
const fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
const hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
const heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
const bullet = /(?:[*+-]|\d{1,9}[.)])/;
const lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
const lheading = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex();
const lheadingGfm = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex();
const _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
const blockText = /^[^\n]+/;
const _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
const def = edit(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
const list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
const _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
const _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
const html = edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
const paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
const blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex();
const blockNormal = {
  blockquote,
  code: blockCode,
  def,
  fences,
  heading,
  hr,
  html,
  lheading,
  list,
  newline,
  paragraph,
  table: noopTest,
  text: blockText
};
const gfmTable = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
const blockGfm = {
  ...blockNormal,
  lheading: lheadingGfm,
  table: gfmTable,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
};
const blockPedantic = {
  ...blockNormal,
  html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
};
const escape$1 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
const inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
const br = /^( {2,}|\\)\n(?!\s*$)/;
const inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
const _punctuation = /[\p{P}\p{S}]/u;
const _punctuationOrSpace = /[\s\p{P}\p{S}]/u;
const _notPunctuationOrSpace = /[^\s\p{P}\p{S}]/u;
const punctuation = edit(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, _punctuationOrSpace).getRegex();
const _punctuationGfmStrongEm = /(?!~)[\p{P}\p{S}]/u;
const _punctuationOrSpaceGfmStrongEm = /(?!~)[\s\p{P}\p{S}]/u;
const _notPunctuationOrSpaceGfmStrongEm = /(?:[^\s\p{P}\p{S}]|~)/u;
const blockSkip = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g;
const emStrongLDelimCore = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
const emStrongLDelim = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuation).getRegex();
const emStrongLDelimGfm = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuationGfmStrongEm).getRegex();
const emStrongRDelimAstCore = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)";
const emStrongRDelimAst = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
const emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm).replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm).replace(/punct/g, _punctuationGfmStrongEm).getRegex();
const emStrongRDelimUnd = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
const anyPunctuation = edit(/\\(punct)/, "gu").replace(/punct/g, _punctuation).getRegex();
const autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
const _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex();
const tag = edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
const _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
const link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
const reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex();
const nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex();
const reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex();
const inlineNormal = {
  _backpedal: noopTest,
  // only used for GFM url
  anyPunctuation,
  autolink,
  blockSkip,
  br,
  code: inlineCode,
  del: noopTest,
  emStrongLDelim,
  emStrongRDelimAst,
  emStrongRDelimUnd,
  escape: escape$1,
  link,
  nolink,
  punctuation,
  reflink,
  reflinkSearch,
  tag,
  text: inlineText,
  url: noopTest
};
const inlinePedantic = {
  ...inlineNormal,
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
};
const inlineGfm = {
  ...inlineNormal,
  emStrongRDelimAst: emStrongRDelimAstGfm,
  emStrongLDelim: emStrongLDelimGfm,
  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
const inlineBreaks = {
  ...inlineGfm,
  br: edit(br).replace("{2,}", "*").getRegex(),
  text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
const block = {
  normal: blockNormal,
  gfm: blockGfm,
  pedantic: blockPedantic
};
const inline = {
  normal: inlineNormal,
  gfm: inlineGfm,
  breaks: inlineBreaks,
  pedantic: inlinePedantic
};
const escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
const getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html2, encode) {
  if (encode) {
    if (other.escapeTest.test(html2)) {
      return html2.replace(other.escapeReplace, getEscapeReplacement);
    }
  } else {
    if (other.escapeTestNoEncode.test(html2)) {
      return html2.replace(other.escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html2;
}
function cleanUrl(href) {
  try {
    href = encodeURI(href).replace(other.percentDecode, "%");
  } catch {
    return null;
  }
  return href;
}
function splitCells(tableRow, count) {
  var _a;
  const row = tableRow.replace(other.findPipe, (match, offset, str) => {
    let escaped = false;
    let curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(other.splitPipe);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !((_a = cells.at(-1)) == null ? void 0 : _a.trim())) {
    cells.pop();
  }
  if (count) {
    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count)
        cells.push("");
    }
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(other.slashPipe, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && true) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  let level = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function outputLink(cap, link2, raw, lexer, rules) {
  const href = link2.href;
  const title = link2.title || null;
  const text = cap[1].replace(rules.other.outputLinkReplace, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer.inlineTokens(text)
    };
    lexer.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text
  };
}
function indentCodeCompensation(raw, text, rules) {
  const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(rules.other.beginningSpace);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
class _Tokenizer {
  // set by the lexer
  constructor(options) {
    __publicField(this, "options");
    __publicField(this, "rules");
    __publicField(this, "lexer");
    this.options = options || _defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(this.rules.other.codeRemoveIndent, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "", this.rules);
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (this.rules.other.endingHash.test(text)) {
        const trimmed = rtrim(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: rtrim(cap[0], "\n")
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      let lines = rtrim(cap[0], "\n").split("\n");
      let raw = "";
      let text = "";
      const tokens = [];
      while (lines.length > 0) {
        let inBlockquote = false;
        const currentLines = [];
        let i;
        for (i = 0; i < lines.length; i++) {
          if (this.rules.other.blockquoteStart.test(lines[i])) {
            currentLines.push(lines[i]);
            inBlockquote = true;
          } else if (!inBlockquote) {
            currentLines.push(lines[i]);
          } else {
            break;
          }
        }
        lines = lines.slice(i);
        const currentRaw = currentLines.join("\n");
        const currentText = currentRaw.replace(this.rules.other.blockquoteSetextReplace, "\n    $1").replace(this.rules.other.blockquoteSetextReplace2, "");
        raw = raw ? `${raw}
${currentRaw}` : currentRaw;
        text = text ? `${text}
${currentText}` : currentText;
        const top = this.lexer.state.top;
        this.lexer.state.top = true;
        this.lexer.blockTokens(currentText, tokens, true);
        this.lexer.state.top = top;
        if (lines.length === 0) {
          break;
        }
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "code") {
          break;
        } else if ((lastToken == null ? void 0 : lastToken.type) === "blockquote") {
          const oldToken = lastToken;
          const newText = oldToken.raw + "\n" + lines.join("\n");
          const newToken = this.blockquote(newText);
          tokens[tokens.length - 1] = newToken;
          raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;
          text = text.substring(0, text.length - oldToken.text.length) + newToken.text;
          break;
        } else if ((lastToken == null ? void 0 : lastToken.type) === "list") {
          const oldToken = lastToken;
          const newText = oldToken.raw + "\n" + lines.join("\n");
          const newToken = this.list(newText);
          tokens[tokens.length - 1] = newToken;
          raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;
          text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;
          lines = newText.substring(tokens.at(-1).raw.length).split("\n");
          continue;
        }
      }
      return {
        type: "blockquote",
        raw,
        tokens,
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list2 = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = this.rules.other.listItemRegex(bull);
      let endsWithBlankLine = false;
      while (src) {
        let endEarly = false;
        let raw = "";
        let itemContents = "";
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        let line = cap[2].split("\n", 1)[0].replace(this.rules.other.listReplaceTabs, (t) => " ".repeat(3 * t.length));
        let nextLine = src.split("\n", 1)[0];
        let blankLine = !line.trim();
        let indent = 0;
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimStart();
        } else if (blankLine) {
          indent = cap[1].length + 1;
        } else {
          indent = cap[2].search(this.rules.other.nonSpaceChar);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        if (blankLine && this.rules.other.blankLine.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = this.rules.other.nextBulletRegex(indent);
          const hrRegex = this.rules.other.hrRegex(indent);
          const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);
          const headingBeginRegex = this.rules.other.headingBeginRegex(indent);
          const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);
          while (src) {
            const rawLine = src.split("\n", 1)[0];
            let nextLineWithoutTabs;
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(this.rules.other.listReplaceNesting, "  ");
              nextLineWithoutTabs = nextLine;
            } else {
              nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, "    ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (htmlBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(nextLine)) {
              break;
            }
            if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLineWithoutTabs.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLineWithoutTabs.slice(indent);
          }
        }
        if (!list2.loose) {
          if (endsWithBlankLine) {
            list2.loose = true;
          } else if (this.rules.other.doubleBlankLine.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        let istask = null;
        let ischecked;
        if (this.options.gfm) {
          istask = this.rules.other.listIsTask.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(this.rules.other.listReplaceTask, "");
          }
        }
        list2.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents,
          tokens: []
        });
        list2.raw += raw;
      }
      const lastItem = list2.items.at(-1);
      if (lastItem) {
        lastItem.raw = lastItem.raw.trimEnd();
        lastItem.text = lastItem.text.trimEnd();
      } else {
        return;
      }
      list2.raw = list2.raw.trimEnd();
      for (let i = 0; i < list2.items.length; i++) {
        this.lexer.state.top = false;
        list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
        if (!list2.loose) {
          const spacers = list2.items[i].tokens.filter((t) => t.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => this.rules.other.anyLine.test(t.raw));
          list2.loose = hasMultipleLineBreaks;
        }
      }
      if (list2.loose) {
        for (let i = 0; i < list2.items.length; i++) {
          list2.items[i].loose = true;
        }
      }
      return list2;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        block: true,
        raw: cap[0],
        pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
        text: cap[0]
      };
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag2 = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " ");
      const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : cap[3];
      return {
        type: "def",
        tag: tag2,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    var _a;
    const cap = this.rules.block.table.exec(src);
    if (!cap) {
      return;
    }
    if (!this.rules.other.tableDelimiter.test(cap[2])) {
      return;
    }
    const headers = splitCells(cap[1]);
    const aligns = cap[2].replace(this.rules.other.tableAlignChars, "").split("|");
    const rows = ((_a = cap[3]) == null ? void 0 : _a.trim()) ? cap[3].replace(this.rules.other.tableRowBlankLine, "").split("\n") : [];
    const item = {
      type: "table",
      raw: cap[0],
      header: [],
      align: [],
      rows: []
    };
    if (headers.length !== aligns.length) {
      return;
    }
    for (const align of aligns) {
      if (this.rules.other.tableAlignRight.test(align)) {
        item.align.push("right");
      } else if (this.rules.other.tableAlignCenter.test(align)) {
        item.align.push("center");
      } else if (this.rules.other.tableAlignLeft.test(align)) {
        item.align.push("left");
      } else {
        item.align.push(null);
      }
    }
    for (let i = 0; i < headers.length; i++) {
      item.header.push({
        text: headers[i],
        tokens: this.lexer.inline(headers[i]),
        header: true,
        align: item.align[i]
      });
    }
    for (const row of rows) {
      item.rows.push(splitCells(row, item.header.length).map((cell, i) => {
        return {
          text: cell,
          tokens: this.lexer.inline(cell),
          header: false,
          align: item.align[i]
        };
      }));
    }
    return item;
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: cap[1]
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: false,
        text: cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {
        if (!this.rules.other.endAngleBracket.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link2 = this.rules.other.pedanticHrefTitle.exec(href);
        if (link2) {
          href = link2[1];
          title = link2[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (this.rules.other.startAngleBracket.test(href)) {
        if (this.options.pedantic && !this.rules.other.endAngleBracket.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline.anyPunctuation, "$1") : href,
        title: title ? title.replace(this.rules.inline.anyPunctuation, "$1") : title
      }, cap[0], this.lexer, this.rules);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, " ");
      const link2 = links[linkString.toLowerCase()];
      if (!link2) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link2, cap[0], this.lexer, this.rules);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrongLDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
      const lLength = [...match[0]].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = [...rDelim].length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const lastCharLength = [...match[0]][0].length;
        const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
        if (Math.min(lLength, rLength) % 2) {
          const text2 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text2,
            tokens: this.lexer.inlineTokens(text2)
          };
        }
        const text = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text,
          tokens: this.lexer.inlineTokens(text)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(this.rules.other.newLineCharGlobal, " ");
      const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);
      const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = cap[1];
        href = "mailto:" + text;
      } else {
        text = cap[1];
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src) {
    var _a;
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = cap[0];
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = ((_a = this.rules.inline._backpedal.exec(cap[0])) == null ? void 0 : _a[0]) ?? "";
        } while (prevCapZero !== cap[0]);
        text = cap[0];
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      const escaped = this.lexer.state.inRawBlock;
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        escaped
      };
    }
  }
}
class _Lexer {
  constructor(options) {
    __publicField(this, "tokens");
    __publicField(this, "options");
    __publicField(this, "state");
    __publicField(this, "tokenizer");
    __publicField(this, "inlineQueue");
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options || _defaults;
    this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      other,
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options) {
    const lexer = new _Lexer(options);
    return lexer.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options) {
    const lexer = new _Lexer(options);
    return lexer.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(other.carriageReturn, "\n");
    this.blockTokens(src, this.tokens);
    for (let i = 0; i < this.inlineQueue.length; i++) {
      const next = this.inlineQueue[i];
      this.inlineTokens(next.src, next.tokens);
    }
    this.inlineQueue = [];
    return this.tokens;
  }
  blockTokens(src, tokens = [], lastParagraphClipped = false) {
    var _a, _b, _c;
    if (this.options.pedantic) {
      src = src.replace(other.tabCharGlobal, "    ").replace(other.spaceLine, "");
    }
    while (src) {
      let token;
      if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.block) == null ? void 0 : _b.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if (token.raw.length === 1 && lastToken !== void 0) {
          lastToken.raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "paragraph" || (lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.at(-1).src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "paragraph" || (lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue.at(-1).src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      let cutSrc = src;
      if ((_c = this.options.extensions) == null ? void 0 : _c.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        const lastToken = tokens.at(-1);
        if (lastParagraphClipped && (lastToken == null ? void 0 : lastToken.type) === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue.at(-1).src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue.at(-1).src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    var _a, _b, _c;
    let maskedSrc = src;
    let match = null;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    let keepPrevChar = false;
    let prevChar = "";
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      let token;
      if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.inline) == null ? void 0 : _b.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens.at(-1);
        if (token.type === "text" && (lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      let cutSrc = src;
      if ((_c = this.options.extensions) == null ? void 0 : _c.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        const lastToken = tokens.at(-1);
        if ((lastToken == null ? void 0 : lastToken.type) === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
}
class _Renderer {
  // set by the parser
  constructor(options) {
    __publicField(this, "options");
    __publicField(this, "parser");
    this.options = options || _defaults;
  }
  space(token) {
    return "";
  }
  code({ text, lang, escaped }) {
    var _a;
    const langString = (_a = (lang || "").match(other.notSpaceStart)) == null ? void 0 : _a[0];
    const code = text.replace(other.endingNewline, "") + "\n";
    if (!langString) {
      return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="language-' + escape(langString) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
  }
  blockquote({ tokens }) {
    const body = this.parser.parse(tokens);
    return `<blockquote>
${body}</blockquote>
`;
  }
  html({ text }) {
    return text;
  }
  heading({ tokens, depth }) {
    return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>
`;
  }
  hr(token) {
    return "<hr>\n";
  }
  list(token) {
    const ordered = token.ordered;
    const start = token.start;
    let body = "";
    for (let j = 0; j < token.items.length; j++) {
      const item = token.items[j];
      body += this.listitem(item);
    }
    const type = ordered ? "ol" : "ul";
    const startAttr = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startAttr + ">\n" + body + "</" + type + ">\n";
  }
  listitem(item) {
    var _a;
    let itemBody = "";
    if (item.task) {
      const checkbox = this.checkbox({ checked: !!item.checked });
      if (item.loose) {
        if (((_a = item.tokens[0]) == null ? void 0 : _a.type) === "paragraph") {
          item.tokens[0].text = checkbox + " " + item.tokens[0].text;
          if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
            item.tokens[0].tokens[0].text = checkbox + " " + escape(item.tokens[0].tokens[0].text);
            item.tokens[0].tokens[0].escaped = true;
          }
        } else {
          item.tokens.unshift({
            type: "text",
            raw: checkbox + " ",
            text: checkbox + " ",
            escaped: true
          });
        }
      } else {
        itemBody += checkbox + " ";
      }
    }
    itemBody += this.parser.parse(item.tokens, !!item.loose);
    return `<li>${itemBody}</li>
`;
  }
  checkbox({ checked }) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens }) {
    return `<p>${this.parser.parseInline(tokens)}</p>
`;
  }
  table(token) {
    let header = "";
    let cell = "";
    for (let j = 0; j < token.header.length; j++) {
      cell += this.tablecell(token.header[j]);
    }
    header += this.tablerow({ text: cell });
    let body = "";
    for (let j = 0; j < token.rows.length; j++) {
      const row = token.rows[j];
      cell = "";
      for (let k = 0; k < row.length; k++) {
        cell += this.tablecell(row[k]);
      }
      body += this.tablerow({ text: cell });
    }
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  tablerow({ text }) {
    return `<tr>
${text}</tr>
`;
  }
  tablecell(token) {
    const content = this.parser.parseInline(token.tokens);
    const type = token.header ? "th" : "td";
    const tag2 = token.align ? `<${type} align="${token.align}">` : `<${type}>`;
    return tag2 + content + `</${type}>
`;
  }
  /**
   * span level renderer
   */
  strong({ tokens }) {
    return `<strong>${this.parser.parseInline(tokens)}</strong>`;
  }
  em({ tokens }) {
    return `<em>${this.parser.parseInline(tokens)}</em>`;
  }
  codespan({ text }) {
    return `<code>${escape(text, true)}</code>`;
  }
  br(token) {
    return "<br>";
  }
  del({ tokens }) {
    return `<del>${this.parser.parseInline(tokens)}</del>`;
  }
  link({ href, title, tokens }) {
    const text = this.parser.parseInline(tokens);
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + escape(title) + '"';
    }
    out += ">" + text + "</a>";
    return out;
  }
  image({ href, title, text }) {
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return escape(text);
    }
    href = cleanHref;
    let out = `<img src="${href}" alt="${text}"`;
    if (title) {
      out += ` title="${escape(title)}"`;
    }
    out += ">";
    return out;
  }
  text(token) {
    return "tokens" in token && token.tokens ? this.parser.parseInline(token.tokens) : "escaped" in token && token.escaped ? token.text : escape(token.text);
  }
}
class _TextRenderer {
  // no need for block level renderers
  strong({ text }) {
    return text;
  }
  em({ text }) {
    return text;
  }
  codespan({ text }) {
    return text;
  }
  del({ text }) {
    return text;
  }
  html({ text }) {
    return text;
  }
  text({ text }) {
    return text;
  }
  link({ text }) {
    return "" + text;
  }
  image({ text }) {
    return "" + text;
  }
  br() {
    return "";
  }
}
class _Parser {
  constructor(options) {
    __publicField(this, "options");
    __publicField(this, "renderer");
    __publicField(this, "textRenderer");
    this.options = options || _defaults;
    this.options.renderer = this.options.renderer || new _Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.renderer.parser = this;
    this.textRenderer = new _TextRenderer();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options) {
    const parser = new _Parser(options);
    return parser.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options) {
    const parser = new _Parser(options);
    return parser.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    var _a, _b;
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const anyToken = tokens[i];
      if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.renderers) == null ? void 0 : _b[anyToken.type]) {
        const genericToken = anyToken;
        const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
          out += ret || "";
          continue;
        }
      }
      const token = anyToken;
      switch (token.type) {
        case "space": {
          out += this.renderer.space(token);
          continue;
        }
        case "hr": {
          out += this.renderer.hr(token);
          continue;
        }
        case "heading": {
          out += this.renderer.heading(token);
          continue;
        }
        case "code": {
          out += this.renderer.code(token);
          continue;
        }
        case "table": {
          out += this.renderer.table(token);
          continue;
        }
        case "blockquote": {
          out += this.renderer.blockquote(token);
          continue;
        }
        case "list": {
          out += this.renderer.list(token);
          continue;
        }
        case "html": {
          out += this.renderer.html(token);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(token);
          continue;
        }
        case "text": {
          let textToken = token;
          let body = this.renderer.text(textToken);
          while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
            textToken = tokens[++i];
            body += "\n" + this.renderer.text(textToken);
          }
          if (top) {
            out += this.renderer.paragraph({
              type: "paragraph",
              raw: body,
              text: body,
              tokens: [{ type: "text", raw: body, text: body, escaped: true }]
            });
          } else {
            out += body;
          }
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer = this.renderer) {
    var _a, _b;
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const anyToken = tokens[i];
      if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.renderers) == null ? void 0 : _b[anyToken.type]) {
        const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(anyToken.type)) {
          out += ret || "";
          continue;
        }
      }
      const token = anyToken;
      switch (token.type) {
        case "escape": {
          out += renderer.text(token);
          break;
        }
        case "html": {
          out += renderer.html(token);
          break;
        }
        case "link": {
          out += renderer.link(token);
          break;
        }
        case "image": {
          out += renderer.image(token);
          break;
        }
        case "strong": {
          out += renderer.strong(token);
          break;
        }
        case "em": {
          out += renderer.em(token);
          break;
        }
        case "codespan": {
          out += renderer.codespan(token);
          break;
        }
        case "br": {
          out += renderer.br(token);
          break;
        }
        case "del": {
          out += renderer.del(token);
          break;
        }
        case "text": {
          out += renderer.text(token);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
}
class _Hooks {
  constructor(options) {
    __publicField(this, "options");
    __publicField(this, "block");
    this.options = options || _defaults;
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html2) {
    return html2;
  }
  /**
   * Process all tokens before walk tokens
   */
  processAllTokens(tokens) {
    return tokens;
  }
  /**
   * Provide function to tokenize markdown
   */
  provideLexer() {
    return this.block ? _Lexer.lex : _Lexer.lexInline;
  }
  /**
   * Provide function to parse tokens
   */
  provideParser() {
    return this.block ? _Parser.parse : _Parser.parseInline;
  }
}
__publicField(_Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess",
  "processAllTokens"
]));
class Marked {
  constructor(...args) {
    __publicField(this, "defaults", _getDefaults());
    __publicField(this, "options", this.setOptions);
    __publicField(this, "parse", this.parseMarkdown(true));
    __publicField(this, "parseInline", this.parseMarkdown(false));
    __publicField(this, "Parser", _Parser);
    __publicField(this, "Renderer", _Renderer);
    __publicField(this, "TextRenderer", _TextRenderer);
    __publicField(this, "Lexer", _Lexer);
    __publicField(this, "Tokenizer", _Tokenizer);
    __publicField(this, "Hooks", _Hooks);
    this.use(...args);
  }
  /**
   * Run callback for every token
   */
  walkTokens(tokens, callback) {
    var _a, _b;
    let values = [];
    for (const token of tokens) {
      values = values.concat(callback.call(this, token));
      switch (token.type) {
        case "table": {
          const tableToken = token;
          for (const cell of tableToken.header) {
            values = values.concat(this.walkTokens(cell.tokens, callback));
          }
          for (const row of tableToken.rows) {
            for (const cell of row) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
          }
          break;
        }
        case "list": {
          const listToken = token;
          values = values.concat(this.walkTokens(listToken.items, callback));
          break;
        }
        default: {
          const genericToken = token;
          if ((_b = (_a = this.defaults.extensions) == null ? void 0 : _a.childTokens) == null ? void 0 : _b[genericToken.type]) {
            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
              const tokens2 = genericToken[childTokens].flat(Infinity);
              values = values.concat(this.walkTokens(tokens2, callback));
            });
          } else if (genericToken.tokens) {
            values = values.concat(this.walkTokens(genericToken.tokens, callback));
          }
        }
      }
    }
    return values;
  }
  use(...args) {
    const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
    args.forEach((pack) => {
      const opts = { ...pack };
      opts.async = this.defaults.async || opts.async || false;
      if (pack.extensions) {
        pack.extensions.forEach((ext) => {
          if (!ext.name) {
            throw new Error("extension name required");
          }
          if ("renderer" in ext) {
            const prevRenderer = extensions.renderers[ext.name];
            if (prevRenderer) {
              extensions.renderers[ext.name] = function(...args2) {
                let ret = ext.renderer.apply(this, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args2);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if ("tokenizer" in ext) {
            if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            const extLevel = extensions[ext.level];
            if (extLevel) {
              extLevel.unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) {
              if (ext.level === "block") {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === "inline") {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if ("childTokens" in ext && ext.childTokens) {
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
        opts.extensions = extensions;
      }
      if (pack.renderer) {
        const renderer = this.defaults.renderer || new _Renderer(this.defaults);
        for (const prop in pack.renderer) {
          if (!(prop in renderer)) {
            throw new Error(`renderer '${prop}' does not exist`);
          }
          if (["options", "parser"].includes(prop)) {
            continue;
          }
          const rendererProp = prop;
          const rendererFunc = pack.renderer[rendererProp];
          const prevRenderer = renderer[rendererProp];
          renderer[rendererProp] = (...args2) => {
            let ret = rendererFunc.apply(renderer, args2);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args2);
            }
            return ret || "";
          };
        }
        opts.renderer = renderer;
      }
      if (pack.tokenizer) {
        const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
        for (const prop in pack.tokenizer) {
          if (!(prop in tokenizer)) {
            throw new Error(`tokenizer '${prop}' does not exist`);
          }
          if (["options", "rules", "lexer"].includes(prop)) {
            continue;
          }
          const tokenizerProp = prop;
          const tokenizerFunc = pack.tokenizer[tokenizerProp];
          const prevTokenizer = tokenizer[tokenizerProp];
          tokenizer[tokenizerProp] = (...args2) => {
            let ret = tokenizerFunc.apply(tokenizer, args2);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args2);
            }
            return ret;
          };
        }
        opts.tokenizer = tokenizer;
      }
      if (pack.hooks) {
        const hooks = this.defaults.hooks || new _Hooks();
        for (const prop in pack.hooks) {
          if (!(prop in hooks)) {
            throw new Error(`hook '${prop}' does not exist`);
          }
          if (["options", "block"].includes(prop)) {
            continue;
          }
          const hooksProp = prop;
          const hooksFunc = pack.hooks[hooksProp];
          const prevHook = hooks[hooksProp];
          if (_Hooks.passThroughHooks.has(prop)) {
            hooks[hooksProp] = (arg) => {
              if (this.defaults.async) {
                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                  return prevHook.call(hooks, ret2);
                });
              }
              const ret = hooksFunc.call(hooks, arg);
              return prevHook.call(hooks, ret);
            };
          } else {
            hooks[hooksProp] = (...args2) => {
              let ret = hooksFunc.apply(hooks, args2);
              if (ret === false) {
                ret = prevHook.apply(hooks, args2);
              }
              return ret;
            };
          }
        }
        opts.hooks = hooks;
      }
      if (pack.walkTokens) {
        const walkTokens = this.defaults.walkTokens;
        const packWalktokens = pack.walkTokens;
        opts.walkTokens = function(token) {
          let values = [];
          values.push(packWalktokens.call(this, token));
          if (walkTokens) {
            values = values.concat(walkTokens.call(this, token));
          }
          return values;
        };
      }
      this.defaults = { ...this.defaults, ...opts };
    });
    return this;
  }
  setOptions(opt) {
    this.defaults = { ...this.defaults, ...opt };
    return this;
  }
  lexer(src, options) {
    return _Lexer.lex(src, options ?? this.defaults);
  }
  parser(tokens, options) {
    return _Parser.parse(tokens, options ?? this.defaults);
  }
  parseMarkdown(blockType) {
    const parse = (src, options) => {
      const origOpt = { ...options };
      const opt = { ...this.defaults, ...origOpt };
      const throwError = this.onError(!!opt.silent, !!opt.async);
      if (this.defaults.async === true && origOpt.async === false) {
        return throwError(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      }
      if (typeof src === "undefined" || src === null) {
        return throwError(new Error("marked(): input parameter is undefined or null"));
      }
      if (typeof src !== "string") {
        return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
      }
      if (opt.hooks) {
        opt.hooks.options = opt;
        opt.hooks.block = blockType;
      }
      const lexer = opt.hooks ? opt.hooks.provideLexer() : blockType ? _Lexer.lex : _Lexer.lexInline;
      const parser = opt.hooks ? opt.hooks.provideParser() : blockType ? _Parser.parse : _Parser.parseInline;
      if (opt.async) {
        return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer(src2, opt)).then((tokens) => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);
      }
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        let tokens = lexer(src, opt);
        if (opt.hooks) {
          tokens = opt.hooks.processAllTokens(tokens);
        }
        if (opt.walkTokens) {
          this.walkTokens(tokens, opt.walkTokens);
        }
        let html2 = parser(tokens, opt);
        if (opt.hooks) {
          html2 = opt.hooks.postprocess(html2);
        }
        return html2;
      } catch (e) {
        return throwError(e);
      }
    };
    return parse;
  }
  onError(silent, async) {
    return (e) => {
      e.message += "\nPlease report this to https://github.com/markedjs/marked.";
      if (silent) {
        const msg = "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
        if (async) {
          return Promise.resolve(msg);
        }
        return msg;
      }
      if (async) {
        return Promise.reject(e);
      }
      throw e;
    };
  }
}
const markedInstance = new Marked();
function marked(src, opt) {
  return markedInstance.parse(src, opt);
}
marked.options = marked.setOptions = function(options) {
  markedInstance.setOptions(options);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function(...args) {
  markedInstance.use(...args);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.walkTokens = function(tokens, callback) {
  return markedInstance.walkTokens(tokens, callback);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
marked.options;
marked.setOptions;
marked.use;
marked.walkTokens;
marked.parseInline;
_Parser.parse;
_Lexer.lex;
const _hoisted_1$2 = ["innerHTML"];
const _sfc_main$1$2 = /* @__PURE__ */ defineComponent({
  __name: "EmailMarkdown",
  props: {
    style: {},
    markdown: {}
  },
  setup(__props) {
    const ALLOWED_TAGS = [
      "a",
      "article",
      "b",
      "blockquote",
      "br",
      "caption",
      "code",
      "del",
      "details",
      "div",
      "em",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "hr",
      "i",
      "img",
      "ins",
      "kbd",
      "li",
      "main",
      "ol",
      "p",
      "pre",
      "section",
      "span",
      "strong",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "th",
      "thead",
      "tr",
      "u",
      "ul"
    ];
    const GENERIC_ALLOWED_ATTRIBUTES = ["style", "title"];
    const props = __props;
    const data = computed(() => renderMarkdownString(props.markdown));
    const rest = computed(() => {
      const { markdown: _, ...rest2 } = props;
      return rest2;
    });
    function renderMarkdownString(str) {
      const html2 = marked.parse(str, {
        async: false,
        breaks: true,
        gfm: true,
        pedantic: false,
        silent: false,
        renderer: new CustomRenderer()
      });
      if (typeof html2 !== "string") {
        throw new Error("marked.parse did not return a string");
      }
      return sanitizer(html2);
    }
    function sanitizer(html2) {
      return insane(html2, {
        allowedTags: ALLOWED_TAGS,
        allowedAttributes: {
          ...ALLOWED_TAGS.reduce((res, tag2) => {
            res[tag2] = [...GENERIC_ALLOWED_ATTRIBUTES];
            return res;
          }, {}),
          img: ["src", "srcset", "alt", "width", "height", ...GENERIC_ALLOWED_ATTRIBUTES],
          table: ["width", ...GENERIC_ALLOWED_ATTRIBUTES],
          td: ["align", "width", ...GENERIC_ALLOWED_ATTRIBUTES],
          th: ["align", "width", ...GENERIC_ALLOWED_ATTRIBUTES],
          a: ["href", "target", ...GENERIC_ALLOWED_ATTRIBUTES],
          ol: ["start", ...GENERIC_ALLOWED_ATTRIBUTES],
          ul: ["start", ...GENERIC_ALLOWED_ATTRIBUTES]
        }
      });
    }
    class CustomRenderer extends _Renderer {
      table(tokens) {
        const result = super.table(tokens);
        return result.replace("<table", '<table width="100%"');
      }
      link(tokens) {
        const result = super.link(tokens);
        return result.replace("<a", '<a target="_blank"');
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps(rest.value, {
        innerHTML: data.value,
        class: "revert-browser-styles"
      }), null, 16, _hoisted_1$2);
    };
  }
});
var util$3;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$3 || (util$3 = {}));
var objectUtil$3;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$3 || (objectUtil$3 = {}));
const ZodParsedType$3 = util$3.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$3 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$3.undefined;
    case "string":
      return ZodParsedType$3.string;
    case "number":
      return isNaN(data) ? ZodParsedType$3.nan : ZodParsedType$3.number;
    case "boolean":
      return ZodParsedType$3.boolean;
    case "function":
      return ZodParsedType$3.function;
    case "bigint":
      return ZodParsedType$3.bigint;
    case "symbol":
      return ZodParsedType$3.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$3.array;
      }
      if (data === null) {
        return ZodParsedType$3.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$3.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$3.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$3.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$3.date;
      }
      return ZodParsedType$3.object;
    default:
      return ZodParsedType$3.unknown;
  }
};
const ZodIssueCode$3 = util$3.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson$3 = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
let ZodError$3 = class ZodError8 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError8)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$3.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$3.create = (issues) => {
  const error = new ZodError$3(issues);
  return error;
};
const errorMap$3 = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode$3.invalid_type:
      if (issue.received === ZodParsedType$3.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode$3.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$3.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$3.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$3.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode$3.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$3.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$3.joinValues(issue.options)}`;
      break;
    case ZodIssueCode$3.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$3.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode$3.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$3.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$3.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$3.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util$3.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$3.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$3.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$3.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$3.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$3.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode$3.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$3.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap$3 = errorMap$3;
function setErrorMap$3(map) {
  overrideErrorMap$3 = map;
}
function getErrorMap$3() {
  return overrideErrorMap$3;
}
const makeIssue$3 = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH$3 = [];
function addIssueToContext$3(ctx, issueData) {
  const overrideMap = getErrorMap$3();
  const issue = makeIssue$3({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$3 ? void 0 : errorMap$3
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
let ParseStatus$3 = class ParseStatus8 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$3;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus8.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$3;
      if (value.status === "aborted")
        return INVALID$3;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$3 = Object.freeze({
  status: "aborted"
});
const DIRTY$3 = (value) => ({ status: "dirty", value });
const OK$3 = (value) => ({ status: "valid", value });
const isAborted$3 = (x) => x.status === "aborted";
const isDirty$3 = (x) => x.status === "dirty";
const isValid$3 = (x) => x.status === "valid";
const isAsync$3 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet$3(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet$3(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil$3;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil$3 || (errorUtil$3 = {}));
var _ZodEnum_cache$3, _ZodNativeEnum_cache$3;
let ParseInputLazyPath$3 = class ParseInputLazyPath8 {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$3 = (ctx, result) => {
  if (isValid$3(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$3(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$3(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$3 = class ZodType8 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$3(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$3(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$3(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$3(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$3(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$3(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$3(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$3(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$3(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$3(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$3(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$3(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$3(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$3.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$3({
      schema: this,
      typeName: ZodFirstPartyTypeKind$3.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def2) {
    this.spa = this.safeParseAsync;
    this._def = def2;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$3.create(this, this._def);
  }
  nullable() {
    return ZodNullable$3.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$3.create(this);
  }
  promise() {
    return ZodPromise$3.create(this, this._def);
  }
  or(option) {
    return ZodUnion$3.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$3.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects$3({
      ...processCreateParams$3(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$3.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def2) {
    const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodDefault$3({
      ...processCreateParams$3(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$3.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$3({
      typeName: ZodFirstPartyTypeKind$3.ZodBranded,
      type: this,
      ...processCreateParams$3(this._def)
    });
  }
  catch(def2) {
    const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodCatch$3({
      ...processCreateParams$3(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$3.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$3.create(this, target);
  }
  readonly() {
    return ZodReadonly$3.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$3 = /^c[^\s-]{8,}$/i;
const cuid2Regex$3 = /^[0-9a-z]+$/;
const ulidRegex$3 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$3 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$3 = /^[a-z0-9_-]{21}$/i;
const jwtRegex$3 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$3 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$3 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$3 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$3;
const ipv4Regex$3 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$3 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$3 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$3 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$3 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$3 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$3 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$3 = new RegExp(`^${dateRegexSource$3}$`);
function timeRegexSource$3(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex$3(args) {
  return new RegExp(`^${timeRegexSource$3(args)}$`);
}
function datetimeRegex$3(args) {
  let regex = `${dateRegexSource$3}T${timeRegexSource$3(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$3(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex$3.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex$3.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$3(jwt, alg) {
  if (!jwtRegex$3.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr$3(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex$3.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex$3.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$3 = class ZodString8 extends ZodType$3 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx2, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.string,
        received: ctx2.parsedType
      });
      return INVALID$3;
    }
    const status = new ParseStatus$3();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$3(ctx, {
              code: ZodIssueCode$3.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$3(ctx, {
              code: ZodIssueCode$3.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "email",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$3) {
          emojiRegex$3 = new RegExp(_emojiRegex$3, "u");
        }
        if (!emojiRegex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "emoji",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "uuid",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "cuid",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "ulid",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "url",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "regex",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$3(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$3;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$3(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "duration",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$3(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "ip",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$3(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "jwt",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$3(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "cidr",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "base64",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            validation: "base64url",
            code: ZodIssueCode$3.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$3.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$3.invalid_string,
      ...errorUtil$3.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString8({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$3.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$3.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$3.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$3.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$3.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$3.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$3.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$3.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$3.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$3.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$3.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$3.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$3.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil$3.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil$3.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$3.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$3.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil$3.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$3.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$3.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$3.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$3.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$3.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$3.errToObj(message));
  }
  trim() {
    return new ZodString8({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString8({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString8({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$3.create = (params) => {
  var _a;
  return new ZodString$3({
    checks: [],
    typeName: ZodFirstPartyTypeKind$3.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$3(params)
  });
};
function floatSafeRemainder$3(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
let ZodNumber$3 = class ZodNumber8 extends ZodType$3 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx2, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.number,
        received: ctx2.parsedType
      });
      return INVALID$3;
    }
    let ctx = void 0;
    const status = new ParseStatus$3();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$3.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$3(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$3.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$3.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$3.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$3.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$3.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber8({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$3.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber8({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$3.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$3.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$3.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$3.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$3.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$3.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$3.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$3.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$3.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$3.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$3.create = (params) => {
  return new ZodNumber$3({
    checks: [],
    typeName: ZodFirstPartyTypeKind$3.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$3(params)
  });
};
let ZodBigInt$3 = class ZodBigInt8 extends ZodType$3 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$3();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$3.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$3(ctx, {
      code: ZodIssueCode$3.invalid_type,
      expected: ZodParsedType$3.bigint,
      received: ctx.parsedType
    });
    return INVALID$3;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$3.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$3.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$3.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$3.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt8({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$3.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt8({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$3.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$3.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$3.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$3.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$3.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$3.create = (params) => {
  var _a;
  return new ZodBigInt$3({
    checks: [],
    typeName: ZodFirstPartyTypeKind$3.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$3(params)
  });
};
let ZodBoolean$3 = class ZodBoolean8 extends ZodType$3 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.boolean,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    return OK$3(input.data);
  }
};
ZodBoolean$3.create = (params) => {
  return new ZodBoolean$3({
    typeName: ZodFirstPartyTypeKind$3.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$3(params)
  });
};
let ZodDate$3 = class ZodDate8 extends ZodType$3 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx2, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.date,
        received: ctx2.parsedType
      });
      return INVALID$3;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx2, {
        code: ZodIssueCode$3.invalid_date
      });
      return INVALID$3;
    }
    const status = new ParseStatus$3();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$3.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate8({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$3.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$3.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$3.create = (params) => {
  return new ZodDate$3({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$3.ZodDate,
    ...processCreateParams$3(params)
  });
};
let ZodSymbol$3 = class ZodSymbol8 extends ZodType$3 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.symbol,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    return OK$3(input.data);
  }
};
ZodSymbol$3.create = (params) => {
  return new ZodSymbol$3({
    typeName: ZodFirstPartyTypeKind$3.ZodSymbol,
    ...processCreateParams$3(params)
  });
};
let ZodUndefined$3 = class ZodUndefined8 extends ZodType$3 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.undefined,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    return OK$3(input.data);
  }
};
ZodUndefined$3.create = (params) => {
  return new ZodUndefined$3({
    typeName: ZodFirstPartyTypeKind$3.ZodUndefined,
    ...processCreateParams$3(params)
  });
};
let ZodNull$3 = class ZodNull8 extends ZodType$3 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.null,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    return OK$3(input.data);
  }
};
ZodNull$3.create = (params) => {
  return new ZodNull$3({
    typeName: ZodFirstPartyTypeKind$3.ZodNull,
    ...processCreateParams$3(params)
  });
};
let ZodAny$3 = class ZodAny8 extends ZodType$3 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$3(input.data);
  }
};
ZodAny$3.create = (params) => {
  return new ZodAny$3({
    typeName: ZodFirstPartyTypeKind$3.ZodAny,
    ...processCreateParams$3(params)
  });
};
let ZodUnknown$3 = class ZodUnknown8 extends ZodType$3 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$3(input.data);
  }
};
ZodUnknown$3.create = (params) => {
  return new ZodUnknown$3({
    typeName: ZodFirstPartyTypeKind$3.ZodUnknown,
    ...processCreateParams$3(params)
  });
};
let ZodNever$3 = class ZodNever8 extends ZodType$3 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$3(ctx, {
      code: ZodIssueCode$3.invalid_type,
      expected: ZodParsedType$3.never,
      received: ctx.parsedType
    });
    return INVALID$3;
  }
};
ZodNever$3.create = (params) => {
  return new ZodNever$3({
    typeName: ZodFirstPartyTypeKind$3.ZodNever,
    ...processCreateParams$3(params)
  });
};
let ZodVoid$3 = class ZodVoid8 extends ZodType$3 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.void,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    return OK$3(input.data);
  }
};
ZodVoid$3.create = (params) => {
  return new ZodVoid$3({
    typeName: ZodFirstPartyTypeKind$3.ZodVoid,
    ...processCreateParams$3(params)
  });
};
let ZodArray$3 = class ZodArray8 extends ZodType$3 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def2 = this._def;
    if (ctx.parsedType !== ZodParsedType$3.array) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.array,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    if (def2.exactLength !== null) {
      const tooBig = ctx.data.length > def2.exactLength.value;
      const tooSmall = ctx.data.length < def2.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$3(ctx, {
          code: tooBig ? ZodIssueCode$3.too_big : ZodIssueCode$3.too_small,
          minimum: tooSmall ? def2.exactLength.value : void 0,
          maximum: tooBig ? def2.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def2.exactLength.message
        });
        status.dirty();
      }
    }
    if (def2.minLength !== null) {
      if (ctx.data.length < def2.minLength.value) {
        addIssueToContext$3(ctx, {
          code: ZodIssueCode$3.too_small,
          minimum: def2.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.minLength.message
        });
        status.dirty();
      }
    }
    if (def2.maxLength !== null) {
      if (ctx.data.length > def2.maxLength.value) {
        addIssueToContext$3(ctx, {
          code: ZodIssueCode$3.too_big,
          maximum: def2.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def2.type._parseAsync(new ParseInputLazyPath$3(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$3.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def2.type._parseSync(new ParseInputLazyPath$3(ctx, item, ctx.path, i));
    });
    return ParseStatus$3.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray8({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$3.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray8({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$3.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray8({
      ...this._def,
      exactLength: { value: len, message: errorUtil$3.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$3.create = (schema, params) => {
  return new ZodArray$3({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$3.ZodArray,
    ...processCreateParams$3(params)
  });
};
function deepPartialify$3(schema) {
  if (schema instanceof ZodObject$3) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$3.create(deepPartialify$3(fieldSchema));
    }
    return new ZodObject$3({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$3) {
    return new ZodArray$3({
      ...schema._def,
      type: deepPartialify$3(schema.element)
    });
  } else if (schema instanceof ZodOptional$3) {
    return ZodOptional$3.create(deepPartialify$3(schema.unwrap()));
  } else if (schema instanceof ZodNullable$3) {
    return ZodNullable$3.create(deepPartialify$3(schema.unwrap()));
  } else if (schema instanceof ZodTuple$3) {
    return ZodTuple$3.create(schema.items.map((item) => deepPartialify$3(item)));
  } else {
    return schema;
  }
}
let ZodObject$3 = class ZodObject8 extends ZodType$3 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$3.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx2, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.object,
        received: ctx2.parsedType
      });
      return INVALID$3;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$3 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$3(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$3) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$3(ctx, {
            code: ZodIssueCode$3.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$3(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$3.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$3.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$3.errToObj;
    return new ZodObject8({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil$3.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject8({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject8({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject8({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject8({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$3.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject8({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util$3.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject8({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util$3.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject8({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$3(this);
  }
  partial(mask) {
    const newShape = {};
    util$3.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject8({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util$3.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$3) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject8({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$3(util$3.objectKeys(this.shape));
  }
};
ZodObject$3.create = (shape, params) => {
  return new ZodObject$3({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$3.create(),
    typeName: ZodFirstPartyTypeKind$3.ZodObject,
    ...processCreateParams$3(params)
  });
};
ZodObject$3.strictCreate = (shape, params) => {
  return new ZodObject$3({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$3.create(),
    typeName: ZodFirstPartyTypeKind$3.ZodObject,
    ...processCreateParams$3(params)
  });
};
ZodObject$3.lazycreate = (shape, params) => {
  return new ZodObject$3({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$3.create(),
    typeName: ZodFirstPartyTypeKind$3.ZodObject,
    ...processCreateParams$3(params)
  });
};
let ZodUnion$3 = class ZodUnion8 extends ZodType$3 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$3(result.ctx.common.issues));
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_union,
        unionErrors
      });
      return INVALID$3;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$3(issues2));
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_union,
        unionErrors
      });
      return INVALID$3;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$3.create = (types, params) => {
  return new ZodUnion$3({
    options: types,
    typeName: ZodFirstPartyTypeKind$3.ZodUnion,
    ...processCreateParams$3(params)
  });
};
const getDiscriminator$3 = (type) => {
  if (type instanceof ZodLazy$3) {
    return getDiscriminator$3(type.schema);
  } else if (type instanceof ZodEffects$3) {
    return getDiscriminator$3(type.innerType());
  } else if (type instanceof ZodLiteral$3) {
    return [type.value];
  } else if (type instanceof ZodEnum$3) {
    return type.options;
  } else if (type instanceof ZodNativeEnum$3) {
    return util$3.objectValues(type.enum);
  } else if (type instanceof ZodDefault$3) {
    return getDiscriminator$3(type._def.innerType);
  } else if (type instanceof ZodUndefined$3) {
    return [void 0];
  } else if (type instanceof ZodNull$3) {
    return [null];
  } else if (type instanceof ZodOptional$3) {
    return [void 0, ...getDiscriminator$3(type.unwrap())];
  } else if (type instanceof ZodNullable$3) {
    return [null, ...getDiscriminator$3(type.unwrap())];
  } else if (type instanceof ZodBranded$3) {
    return getDiscriminator$3(type.unwrap());
  } else if (type instanceof ZodReadonly$3) {
    return getDiscriminator$3(type.unwrap());
  } else if (type instanceof ZodCatch$3) {
    return getDiscriminator$3(type._def.innerType);
  } else {
    return [];
  }
};
let ZodDiscriminatedUnion$3 = class ZodDiscriminatedUnion8 extends ZodType$3 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$3.object) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.object,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID$3;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator$3(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion8({
      typeName: ZodFirstPartyTypeKind$3.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams$3(params)
    });
  }
};
function mergeValues$3(a, b) {
  const aType = getParsedType$3(a);
  const bType = getParsedType$3(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$3.object && bType === ZodParsedType$3.object) {
    const bKeys = util$3.objectKeys(b);
    const sharedKeys = util$3.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$3(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$3.array && bType === ZodParsedType$3.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$3(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$3.date && bType === ZodParsedType$3.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$3 = class ZodIntersection8 extends ZodType$3 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$3(parsedLeft) || isAborted$3(parsedRight)) {
        return INVALID$3;
      }
      const merged = mergeValues$3(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$3(ctx, {
          code: ZodIssueCode$3.invalid_intersection_types
        });
        return INVALID$3;
      }
      if (isDirty$3(parsedLeft) || isDirty$3(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$3.create = (left, right, params) => {
  return new ZodIntersection$3({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$3.ZodIntersection,
    ...processCreateParams$3(params)
  });
};
let ZodTuple$3 = class ZodTuple8 extends ZodType$3 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$3.array) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.array,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$3;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$3(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$3.mergeArray(status, results);
      });
    } else {
      return ParseStatus$3.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple8({
      ...this._def,
      rest
    });
  }
};
ZodTuple$3.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$3({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$3.ZodTuple,
    rest: null,
    ...processCreateParams$3(params)
  });
};
let ZodRecord$3 = class ZodRecord8 extends ZodType$3 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$3.object) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.object,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath$3(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath$3(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus$3.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus$3.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType$3) {
      return new ZodRecord8({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind$3.ZodRecord,
        ...processCreateParams$3(third)
      });
    }
    return new ZodRecord8({
      keyType: ZodString$3.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind$3.ZodRecord,
      ...processCreateParams$3(second)
    });
  }
};
let ZodMap$3 = class ZodMap8 extends ZodType$3 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$3.map) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.map,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$3(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$3(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$3;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$3;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$3.create = (keyType, valueType, params) => {
  return new ZodMap$3({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$3.ZodMap,
    ...processCreateParams$3(params)
  });
};
let ZodSet$3 = class ZodSet8 extends ZodType$3 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$3.set) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.set,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    const def2 = this._def;
    if (def2.minSize !== null) {
      if (ctx.data.size < def2.minSize.value) {
        addIssueToContext$3(ctx, {
          code: ZodIssueCode$3.too_small,
          minimum: def2.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.minSize.message
        });
        status.dirty();
      }
    }
    if (def2.maxSize !== null) {
      if (ctx.data.size > def2.maxSize.value) {
        addIssueToContext$3(ctx, {
          code: ZodIssueCode$3.too_big,
          maximum: def2.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements3) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements3) {
        if (element.status === "aborted")
          return INVALID$3;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements2 = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$3(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements2).then((elements3) => finalizeSet(elements3));
    } else {
      return finalizeSet(elements2);
    }
  }
  min(minSize, message) {
    return new ZodSet8({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$3.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet8({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$3.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$3.create = (valueType, params) => {
  return new ZodSet$3({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$3.ZodSet,
    ...processCreateParams$3(params)
  });
};
let ZodFunction$3 = class ZodFunction8 extends ZodType$3 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$3.function) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.function,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    function makeArgsIssue(args, error) {
      return makeIssue$3({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$3(),
          errorMap$3
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$3.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue$3({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$3(),
          errorMap$3
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$3.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise$3) {
      const me = this;
      return OK$3(async function(...args) {
        const error = new ZodError$3([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK$3(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError$3([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError$3([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction8({
      ...this._def,
      args: ZodTuple$3.create(items).rest(ZodUnknown$3.create())
    });
  }
  returns(returnType) {
    return new ZodFunction8({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction8({
      args: args ? args : ZodTuple$3.create([]).rest(ZodUnknown$3.create()),
      returns: returns || ZodUnknown$3.create(),
      typeName: ZodFirstPartyTypeKind$3.ZodFunction,
      ...processCreateParams$3(params)
    });
  }
};
let ZodLazy$3 = class ZodLazy8 extends ZodType$3 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$3.create = (getter, params) => {
  return new ZodLazy$3({
    getter,
    typeName: ZodFirstPartyTypeKind$3.ZodLazy,
    ...processCreateParams$3(params)
  });
};
let ZodLiteral$3 = class ZodLiteral8 extends ZodType$3 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx, {
        received: ctx.data,
        code: ZodIssueCode$3.invalid_literal,
        expected: this._def.value
      });
      return INVALID$3;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$3.create = (value, params) => {
  return new ZodLiteral$3({
    value,
    typeName: ZodFirstPartyTypeKind$3.ZodLiteral,
    ...processCreateParams$3(params)
  });
};
function createZodEnum$3(values, params) {
  return new ZodEnum$3({
    values,
    typeName: ZodFirstPartyTypeKind$3.ZodEnum,
    ...processCreateParams$3(params)
  });
}
let ZodEnum$3 = class ZodEnum8 extends ZodType$3 {
  constructor() {
    super(...arguments);
    _ZodEnum_cache$3.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$3(ctx, {
        expected: util$3.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$3.invalid_type
      });
      return INVALID$3;
    }
    if (!__classPrivateFieldGet$3(this, _ZodEnum_cache$3)) {
      __classPrivateFieldSet$3(this, _ZodEnum_cache$3, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet$3(this, _ZodEnum_cache$3).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$3(ctx, {
        received: ctx.data,
        code: ZodIssueCode$3.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$3;
    }
    return OK$3(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum8.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum8.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache$3 = /* @__PURE__ */ new WeakMap();
ZodEnum$3.create = createZodEnum$3;
let ZodNativeEnum$3 = class ZodNativeEnum8 extends ZodType$3 {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache$3.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util$3.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$3.string && ctx.parsedType !== ZodParsedType$3.number) {
      const expectedValues = util$3.objectValues(nativeEnumValues);
      addIssueToContext$3(ctx, {
        expected: util$3.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$3.invalid_type
      });
      return INVALID$3;
    }
    if (!__classPrivateFieldGet$3(this, _ZodNativeEnum_cache$3)) {
      __classPrivateFieldSet$3(this, _ZodNativeEnum_cache$3, new Set(util$3.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet$3(this, _ZodNativeEnum_cache$3).has(input.data)) {
      const expectedValues = util$3.objectValues(nativeEnumValues);
      addIssueToContext$3(ctx, {
        received: ctx.data,
        code: ZodIssueCode$3.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$3;
    }
    return OK$3(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache$3 = /* @__PURE__ */ new WeakMap();
ZodNativeEnum$3.create = (values, params) => {
  return new ZodNativeEnum$3({
    values,
    typeName: ZodFirstPartyTypeKind$3.ZodNativeEnum,
    ...processCreateParams$3(params)
  });
};
let ZodPromise$3 = class ZodPromise8 extends ZodType$3 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$3.promise && ctx.common.async === false) {
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.promise,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    const promisified = ctx.parsedType === ZodParsedType$3.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$3(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$3.create = (schema, params) => {
  return new ZodPromise$3({
    type: schema,
    typeName: ZodFirstPartyTypeKind$3.ZodPromise,
    ...processCreateParams$3(params)
  });
};
let ZodEffects$3 = class ZodEffects8 extends ZodType$3 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$3.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$3(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$3;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$3;
          if (result.status === "dirty")
            return DIRTY$3(result.value);
          if (status.value === "dirty")
            return DIRTY$3(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$3;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$3;
        if (result.status === "dirty")
          return DIRTY$3(result.value);
        if (status.value === "dirty")
          return DIRTY$3(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$3;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$3;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$3(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$3(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util$3.assertNever(effect);
  }
};
ZodEffects$3.create = (schema, effect, params) => {
  return new ZodEffects$3({
    schema,
    typeName: ZodFirstPartyTypeKind$3.ZodEffects,
    effect,
    ...processCreateParams$3(params)
  });
};
ZodEffects$3.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$3({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$3.ZodEffects,
    ...processCreateParams$3(params)
  });
};
let ZodOptional$3 = class ZodOptional8 extends ZodType$3 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$3.undefined) {
      return OK$3(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$3.create = (type, params) => {
  return new ZodOptional$3({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$3.ZodOptional,
    ...processCreateParams$3(params)
  });
};
let ZodNullable$3 = class ZodNullable8 extends ZodType$3 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$3.null) {
      return OK$3(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$3.create = (type, params) => {
  return new ZodNullable$3({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$3.ZodNullable,
    ...processCreateParams$3(params)
  });
};
let ZodDefault$3 = class ZodDefault8 extends ZodType$3 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$3.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$3.create = (type, params) => {
  return new ZodDefault$3({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$3.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$3(params)
  });
};
let ZodCatch$3 = class ZodCatch8 extends ZodType$3 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$3(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$3(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$3(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$3.create = (type, params) => {
  return new ZodCatch$3({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$3.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$3(params)
  });
};
let ZodNaN$3 = class ZodNaN8 extends ZodType$3 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$3.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$3(ctx, {
        code: ZodIssueCode$3.invalid_type,
        expected: ZodParsedType$3.nan,
        received: ctx.parsedType
      });
      return INVALID$3;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$3.create = (params) => {
  return new ZodNaN$3({
    typeName: ZodFirstPartyTypeKind$3.ZodNaN,
    ...processCreateParams$3(params)
  });
};
const BRAND$3 = Symbol("zod_brand");
let ZodBranded$3 = class ZodBranded8 extends ZodType$3 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$3 = class ZodPipeline8 extends ZodType$3 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$3;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$3(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$3;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline8({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$3.ZodPipeline
    });
  }
};
let ZodReadonly$3 = class ZodReadonly8 extends ZodType$3 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$3(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$3(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$3.create = (type, params) => {
  return new ZodReadonly$3({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$3.ZodReadonly,
    ...processCreateParams$3(params)
  });
};
function cleanParams$3(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom$3(check, _params = {}, fatal) {
  if (check)
    return ZodAny$3.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams$3(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams$3(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny$3.create();
}
const late$3 = {
  object: ZodObject$3.lazycreate
};
var ZodFirstPartyTypeKind$3;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$3 || (ZodFirstPartyTypeKind$3 = {}));
const instanceOfType$3 = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom$3((data) => data instanceof cls, params);
const stringType$3 = ZodString$3.create;
const numberType$3 = ZodNumber$3.create;
const nanType$3 = ZodNaN$3.create;
const bigIntType$3 = ZodBigInt$3.create;
const booleanType$3 = ZodBoolean$3.create;
const dateType$3 = ZodDate$3.create;
const symbolType$3 = ZodSymbol$3.create;
const undefinedType$3 = ZodUndefined$3.create;
const nullType$3 = ZodNull$3.create;
const anyType$3 = ZodAny$3.create;
const unknownType$3 = ZodUnknown$3.create;
const neverType$3 = ZodNever$3.create;
const voidType$3 = ZodVoid$3.create;
const arrayType$3 = ZodArray$3.create;
const objectType$3 = ZodObject$3.create;
const strictObjectType$3 = ZodObject$3.strictCreate;
const unionType$3 = ZodUnion$3.create;
const discriminatedUnionType$3 = ZodDiscriminatedUnion$3.create;
const intersectionType$3 = ZodIntersection$3.create;
const tupleType$3 = ZodTuple$3.create;
const recordType$3 = ZodRecord$3.create;
const mapType$3 = ZodMap$3.create;
const setType$3 = ZodSet$3.create;
const functionType$3 = ZodFunction$3.create;
const lazyType$3 = ZodLazy$3.create;
const literalType$3 = ZodLiteral$3.create;
const enumType$3 = ZodEnum$3.create;
const nativeEnumType$3 = ZodNativeEnum$3.create;
const promiseType$3 = ZodPromise$3.create;
const effectsType$3 = ZodEffects$3.create;
const optionalType$3 = ZodOptional$3.create;
const nullableType$3 = ZodNullable$3.create;
const preprocessType$3 = ZodEffects$3.createWithPreprocess;
const pipelineType$3 = ZodPipeline$3.create;
const ostring$3 = () => stringType$3().optional();
const onumber$3 = () => numberType$3().optional();
const oboolean$3 = () => booleanType$3().optional();
const coerce$3 = {
  string: (arg) => ZodString$3.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber$3.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean$3.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt$3.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate$3.create({ ...arg, coerce: true })
};
const NEVER$3 = INVALID$3;
var z$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap$3,
  setErrorMap: setErrorMap$3,
  getErrorMap: getErrorMap$3,
  makeIssue: makeIssue$3,
  EMPTY_PATH: EMPTY_PATH$3,
  addIssueToContext: addIssueToContext$3,
  ParseStatus: ParseStatus$3,
  INVALID: INVALID$3,
  DIRTY: DIRTY$3,
  OK: OK$3,
  isAborted: isAborted$3,
  isDirty: isDirty$3,
  isValid: isValid$3,
  isAsync: isAsync$3,
  get util() {
    return util$3;
  },
  get objectUtil() {
    return objectUtil$3;
  },
  ZodParsedType: ZodParsedType$3,
  getParsedType: getParsedType$3,
  ZodType: ZodType$3,
  datetimeRegex: datetimeRegex$3,
  ZodString: ZodString$3,
  ZodNumber: ZodNumber$3,
  ZodBigInt: ZodBigInt$3,
  ZodBoolean: ZodBoolean$3,
  ZodDate: ZodDate$3,
  ZodSymbol: ZodSymbol$3,
  ZodUndefined: ZodUndefined$3,
  ZodNull: ZodNull$3,
  ZodAny: ZodAny$3,
  ZodUnknown: ZodUnknown$3,
  ZodNever: ZodNever$3,
  ZodVoid: ZodVoid$3,
  ZodArray: ZodArray$3,
  ZodObject: ZodObject$3,
  ZodUnion: ZodUnion$3,
  ZodDiscriminatedUnion: ZodDiscriminatedUnion$3,
  ZodIntersection: ZodIntersection$3,
  ZodTuple: ZodTuple$3,
  ZodRecord: ZodRecord$3,
  ZodMap: ZodMap$3,
  ZodSet: ZodSet$3,
  ZodFunction: ZodFunction$3,
  ZodLazy: ZodLazy$3,
  ZodLiteral: ZodLiteral$3,
  ZodEnum: ZodEnum$3,
  ZodNativeEnum: ZodNativeEnum$3,
  ZodPromise: ZodPromise$3,
  ZodEffects: ZodEffects$3,
  ZodTransformer: ZodEffects$3,
  ZodOptional: ZodOptional$3,
  ZodNullable: ZodNullable$3,
  ZodDefault: ZodDefault$3,
  ZodCatch: ZodCatch$3,
  ZodNaN: ZodNaN$3,
  BRAND: BRAND$3,
  ZodBranded: ZodBranded$3,
  ZodPipeline: ZodPipeline$3,
  ZodReadonly: ZodReadonly$3,
  custom: custom$3,
  Schema: ZodType$3,
  ZodSchema: ZodType$3,
  late: late$3,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind$3;
  },
  coerce: coerce$3,
  any: anyType$3,
  array: arrayType$3,
  bigint: bigIntType$3,
  boolean: booleanType$3,
  date: dateType$3,
  discriminatedUnion: discriminatedUnionType$3,
  effect: effectsType$3,
  "enum": enumType$3,
  "function": functionType$3,
  "instanceof": instanceOfType$3,
  intersection: intersectionType$3,
  lazy: lazyType$3,
  literal: literalType$3,
  map: mapType$3,
  nan: nanType$3,
  nativeEnum: nativeEnumType$3,
  never: neverType$3,
  "null": nullType$3,
  nullable: nullableType$3,
  number: numberType$3,
  object: objectType$3,
  oboolean: oboolean$3,
  onumber: onumber$3,
  optional: optionalType$3,
  ostring: ostring$3,
  pipeline: pipelineType$3,
  preprocess: preprocessType$3,
  promise: promiseType$3,
  record: recordType$3,
  set: setType$3,
  strictObject: strictObjectType$3,
  string: stringType$3,
  symbol: symbolType$3,
  transformer: effectsType$3,
  tuple: tupleType$3,
  "undefined": undefinedType$3,
  union: unionType$3,
  unknown: unknownType$3,
  "void": voidType$3,
  NEVER: NEVER$3,
  ZodIssueCode: ZodIssueCode$3,
  quotelessJson: quotelessJson$3,
  ZodError: ZodError$3
});
const FONT_FAMILIES = [
  {
    key: "MODERN_SANS",
    label: "Modern sans",
    value: '"Helvetica Neue", "Arial Nova", "Nimbus Sans", Arial, sans-serif'
  },
  {
    key: "BOOK_SANS",
    label: "Book sans",
    value: 'Optima, Candara, "Noto Sans", source-sans-pro, sans-serif'
  },
  {
    key: "ORGANIC_SANS",
    label: "Organic sans",
    value: 'Seravek, "Gill Sans Nova", Ubuntu, Calibri, "DejaVu Sans", source-sans-pro, sans-serif'
  },
  {
    key: "GEOMETRIC_SANS",
    label: "Geometric sans",
    value: 'Avenir, "Avenir Next LT Pro", Montserrat, Corbel, "URW Gothic", source-sans-pro, sans-serif'
  },
  {
    key: "HEAVY_SANS",
    label: "Heavy sans",
    value: 'Bahnschrift, "DIN Alternate", "Franklin Gothic Medium", "Nimbus Sans Narrow", sans-serif-condensed, sans-serif'
  },
  {
    key: "ROUNDED_SANS",
    label: "Rounded sans",
    value: 'ui-rounded, "Hiragino Maru Gothic ProN", Quicksand, Comfortaa, Manjari, "Arial Rounded MT Bold", Calibri, source-sans-pro, sans-serif'
  },
  {
    key: "MODERN_SERIF",
    label: "Modern serif",
    value: 'Charter, "Bitstream Charter", "Sitka Text", Cambria, serif'
  },
  {
    key: "BOOK_SERIF",
    label: "Book serif",
    value: '"Iowan Old Style", "Palatino Linotype", "URW Palladio L", P052, serif'
  },
  {
    key: "MONOSPACE",
    label: "Monospace",
    value: '"Nimbus Mono PS", "Courier New", "Cutive Mono", monospace'
  }
];
const FONT_FAMILY_NAMES$3 = [
  "MODERN_SANS",
  "BOOK_SANS",
  "ORGANIC_SANS",
  "GEOMETRIC_SANS",
  "HEAVY_SANS",
  "ROUNDED_SANS",
  "MODERN_SERIF",
  "BOOK_SERIF",
  "MONOSPACE"
];
const PADDING_SCHEMA$2 = z$3.object({
  top: z$3.number(),
  bottom: z$3.number(),
  right: z$3.number(),
  left: z$3.number()
}).optional().nullable();
const COLOR_SCHEMA$3 = z$3.string().regex(/^#[0-9a-fA-F]{6}$/).nullable().optional();
const FONT_FAMILY_SCHEMA$1 = z$3.enum(FONT_FAMILY_NAMES$3).nullable().optional();
function getFontFamily(fontFamily) {
  var _a;
  return (_a = FONT_FAMILIES.find((f) => f.key === fontFamily)) == null ? void 0 : _a.value;
}
const getPadding$2 = (padding) => padding ? `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px` : void 0;
const TextPropsSchema = z$3.object({
  style: z$3.object({
    color: COLOR_SCHEMA$3,
    backgroundColor: COLOR_SCHEMA$3,
    fontSize: z$3.number().gte(0).optional().nullable(),
    fontFamily: FONT_FAMILY_SCHEMA$1,
    fontWeight: z$3.enum(["bold", "normal"]).optional().nullable(),
    textAlign: z$3.enum(["left", "center", "right"]).optional().nullable(),
    padding: PADDING_SCHEMA$2
  }).optional().nullable(),
  props: z$3.object({
    markdown: z$3.boolean().optional().nullable(),
    text: z$3.string().optional().nullable()
  }).optional().nullable()
});
const TextPropsDefaults = {
  text: ""
};
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    style: {},
    props: {}
  },
  setup(__props) {
    const props = __props;
    const style = computed(() => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      return {
        color: ((_a = props.style) == null ? void 0 : _a.color) ?? void 0,
        backgroundColor: ((_b = props.style) == null ? void 0 : _b.backgroundColor) ?? void 0,
        fontSize: ((_c = props.style) == null ? void 0 : _c.fontSize) ? ((_d = props.style) == null ? void 0 : _d.fontSize) + "px" : void 0,
        // FIXME: type
        fontFamily: getFontFamily((_e = props.style) == null ? void 0 : _e.fontFamily),
        fontWeight: ((_f = props.style) == null ? void 0 : _f.fontWeight) ?? void 0,
        // FIXME: text align type like HTMLAttributes
        textAlign: ((_g = props.style) == null ? void 0 : _g.textAlign) ?? void 0,
        // FIXME: type
        padding: getPadding$2((_h = props.style) == null ? void 0 : _h.padding)
      };
    });
    const text = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.text) ?? TextPropsDefaults.text;
    });
    return (_ctx, _cache) => {
      var _a;
      return ((_a = props == null ? void 0 : props.props) == null ? void 0 : _a.markdown) ? (openBlock(), createBlock(_sfc_main$1$2, {
        key: 0,
        markdown: text.value,
        style: normalizeStyle(style.value)
      }, null, 8, ["markdown", "style"])) : (openBlock(), createElementBlock("div", {
        key: 1,
        style: normalizeStyle(style.value)
      }, toDisplayString(text.value), 5));
    };
  }
});
/**
*  Copyright 2025 AntonyDev
*  @license MIT
**/
const _sfc_main$1$1 = /* @__PURE__ */ defineComponent({
  __name: "TableCell",
  props: {
    index: {},
    props: {}
  },
  setup(__props) {
    const props = __props;
    const contentAlignment = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.contentAlignment) ?? ColumnsContainerPropsDefaults.contentAlignment;
    });
    const columnsCount = computed(() => {
      var _a;
      return ((_a = props.props) == null ? void 0 : _a.columnsCount) ?? ColumnsContainerPropsDefaults.columnsCount;
    });
    const style = computed(() => {
      var _a;
      return {
        boxSizing: "content-box",
        verticalAlign: contentAlignment.value,
        paddingLeft: getPaddingBefore(props.index, props.props) + "px",
        paddingRight: getPaddingAfter(props.index, props.props) + "px",
        width: ((_a = props.props.fixedWidths) == null ? void 0 : _a[props.index]) ?? void 0
      };
    });
    function getPaddingBefore(index, { columnsGap, columnsCount: columnsCount2 }) {
      if (index === 0) {
        return 0;
      }
      if (columnsCount2 === 2) {
        return columnsGap / 2;
      }
      if (index === 1) {
        return columnsGap / 3;
      }
      return 2 * columnsGap / 3;
    }
    function getPaddingAfter(index, { columnsGap, columnsCount: columnsCount2 }) {
      if (columnsCount2 === 2) {
        if (index === 0) {
          return columnsGap / 2;
        }
        return 0;
      }
      if (index === 0) {
        return 2 * columnsGap / 3;
      }
      if (index === 1) {
        return columnsGap / 3;
      }
      return 0;
    }
    return (_ctx, _cache) => {
      return columnsCount.value !== 2 || _ctx.index !== 2 ? (openBlock(), createElementBlock("td", {
        key: 0,
        style: normalizeStyle(style.value)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 4)) : createCommentVNode("", true);
    };
  }
});
var util$2;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$2 || (util$2 = {}));
var objectUtil$2;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$2 || (objectUtil$2 = {}));
const ZodParsedType$2 = util$2.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$2.undefined;
    case "string":
      return ZodParsedType$2.string;
    case "number":
      return isNaN(data) ? ZodParsedType$2.nan : ZodParsedType$2.number;
    case "boolean":
      return ZodParsedType$2.boolean;
    case "function":
      return ZodParsedType$2.function;
    case "bigint":
      return ZodParsedType$2.bigint;
    case "symbol":
      return ZodParsedType$2.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$2.array;
      }
      if (data === null) {
        return ZodParsedType$2.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$2.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$2.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$2.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$2.date;
      }
      return ZodParsedType$2.object;
    default:
      return ZodParsedType$2.unknown;
  }
};
const ZodIssueCode$2 = util$2.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson$2 = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
let ZodError$2 = class ZodError9 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError9)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$2.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$2.create = (issues) => {
  const error = new ZodError$2(issues);
  return error;
};
const errorMap$2 = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode$2.invalid_type:
      if (issue.received === ZodParsedType$2.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode$2.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$2.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$2.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$2.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode$2.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$2.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$2.joinValues(issue.options)}`;
      break;
    case ZodIssueCode$2.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$2.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode$2.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$2.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$2.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$2.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util$2.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$2.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$2.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$2.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$2.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$2.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode$2.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$2.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap$2 = errorMap$2;
function setErrorMap$2(map) {
  overrideErrorMap$2 = map;
}
function getErrorMap$2() {
  return overrideErrorMap$2;
}
const makeIssue$2 = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH$2 = [];
function addIssueToContext$2(ctx, issueData) {
  const overrideMap = getErrorMap$2();
  const issue = makeIssue$2({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$2 ? void 0 : errorMap$2
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
let ParseStatus$2 = class ParseStatus9 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$2;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus9.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$2;
      if (value.status === "aborted")
        return INVALID$2;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$2 = Object.freeze({
  status: "aborted"
});
const DIRTY$2 = (value) => ({ status: "dirty", value });
const OK$2 = (value) => ({ status: "valid", value });
const isAborted$2 = (x) => x.status === "aborted";
const isDirty$2 = (x) => x.status === "dirty";
const isValid$2 = (x) => x.status === "valid";
const isAsync$2 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet$2(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet$2(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil$2;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil$2 || (errorUtil$2 = {}));
var _ZodEnum_cache$2, _ZodNativeEnum_cache$2;
let ParseInputLazyPath$2 = class ParseInputLazyPath9 {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$2 = (ctx, result) => {
  if (isValid$2(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$2(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$2(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$2 = class ZodType9 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$2(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$2(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$2(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$2(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$2(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$2(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$2(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$2(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$2(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$2(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$2(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$2(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$2(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$2.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$2({
      schema: this,
      typeName: ZodFirstPartyTypeKind$2.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def2) {
    this.spa = this.safeParseAsync;
    this._def = def2;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$2.create(this, this._def);
  }
  nullable() {
    return ZodNullable$2.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$2.create(this);
  }
  promise() {
    return ZodPromise$2.create(this, this._def);
  }
  or(option) {
    return ZodUnion$2.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$2.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects$2({
      ...processCreateParams$2(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$2.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def2) {
    const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodDefault$2({
      ...processCreateParams$2(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$2.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$2({
      typeName: ZodFirstPartyTypeKind$2.ZodBranded,
      type: this,
      ...processCreateParams$2(this._def)
    });
  }
  catch(def2) {
    const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodCatch$2({
      ...processCreateParams$2(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$2.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$2.create(this, target);
  }
  readonly() {
    return ZodReadonly$2.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$2 = /^c[^\s-]{8,}$/i;
const cuid2Regex$2 = /^[0-9a-z]+$/;
const ulidRegex$2 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$2 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$2 = /^[a-z0-9_-]{21}$/i;
const jwtRegex$2 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$2 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$2 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$2 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$2;
const ipv4Regex$2 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$2 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$2 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$2 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$2 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$2 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$2 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$2 = new RegExp(`^${dateRegexSource$2}$`);
function timeRegexSource$2(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex$2(args) {
  return new RegExp(`^${timeRegexSource$2(args)}$`);
}
function datetimeRegex$2(args) {
  let regex = `${dateRegexSource$2}T${timeRegexSource$2(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$2(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex$2.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex$2.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$2(jwt, alg) {
  if (!jwtRegex$2.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr$2(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex$2.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex$2.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$2 = class ZodString9 extends ZodType$2 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx2, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.string,
        received: ctx2.parsedType
      });
      return INVALID$2;
    }
    const status = new ParseStatus$2();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$2(ctx, {
              code: ZodIssueCode$2.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$2(ctx, {
              code: ZodIssueCode$2.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "email",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$2) {
          emojiRegex$2 = new RegExp(_emojiRegex$2, "u");
        }
        if (!emojiRegex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "emoji",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "uuid",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "cuid",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "ulid",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "url",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "regex",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$2(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$2;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$2(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "duration",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$2(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "ip",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$2(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "jwt",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$2(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "cidr",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "base64",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            validation: "base64url",
            code: ZodIssueCode$2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$2.invalid_string,
      ...errorUtil$2.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString9({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$2.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$2.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$2.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$2.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$2.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$2.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$2.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$2.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$2.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$2.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$2.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$2.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$2.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil$2.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil$2.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$2.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$2.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil$2.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$2.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$2.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$2.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$2.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$2.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$2.errToObj(message));
  }
  trim() {
    return new ZodString9({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString9({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString9({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$2.create = (params) => {
  var _a;
  return new ZodString$2({
    checks: [],
    typeName: ZodFirstPartyTypeKind$2.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$2(params)
  });
};
function floatSafeRemainder$2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
let ZodNumber$2 = class ZodNumber9 extends ZodType$2 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx2, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.number,
        received: ctx2.parsedType
      });
      return INVALID$2;
    }
    let ctx = void 0;
    const status = new ParseStatus$2();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$2.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$2(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$2.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$2.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$2.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$2.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber9({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$2.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber9({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$2.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$2.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$2.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$2.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$2.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$2.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$2.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$2.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$2.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$2.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$2.create = (params) => {
  return new ZodNumber$2({
    checks: [],
    typeName: ZodFirstPartyTypeKind$2.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$2(params)
  });
};
let ZodBigInt$2 = class ZodBigInt9 extends ZodType$2 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$2();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$2(ctx, {
      code: ZodIssueCode$2.invalid_type,
      expected: ZodParsedType$2.bigint,
      received: ctx.parsedType
    });
    return INVALID$2;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$2.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$2.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$2.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$2.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt9({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$2.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt9({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$2.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$2.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$2.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$2.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$2.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$2.create = (params) => {
  var _a;
  return new ZodBigInt$2({
    checks: [],
    typeName: ZodFirstPartyTypeKind$2.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$2(params)
  });
};
let ZodBoolean$2 = class ZodBoolean9 extends ZodType$2 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.boolean,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    return OK$2(input.data);
  }
};
ZodBoolean$2.create = (params) => {
  return new ZodBoolean$2({
    typeName: ZodFirstPartyTypeKind$2.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$2(params)
  });
};
let ZodDate$2 = class ZodDate9 extends ZodType$2 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx2, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.date,
        received: ctx2.parsedType
      });
      return INVALID$2;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx2, {
        code: ZodIssueCode$2.invalid_date
      });
      return INVALID$2;
    }
    const status = new ParseStatus$2();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate9({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$2.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$2.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$2.create = (params) => {
  return new ZodDate$2({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$2.ZodDate,
    ...processCreateParams$2(params)
  });
};
let ZodSymbol$2 = class ZodSymbol9 extends ZodType$2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.symbol,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    return OK$2(input.data);
  }
};
ZodSymbol$2.create = (params) => {
  return new ZodSymbol$2({
    typeName: ZodFirstPartyTypeKind$2.ZodSymbol,
    ...processCreateParams$2(params)
  });
};
let ZodUndefined$2 = class ZodUndefined9 extends ZodType$2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.undefined,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    return OK$2(input.data);
  }
};
ZodUndefined$2.create = (params) => {
  return new ZodUndefined$2({
    typeName: ZodFirstPartyTypeKind$2.ZodUndefined,
    ...processCreateParams$2(params)
  });
};
let ZodNull$2 = class ZodNull9 extends ZodType$2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.null,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    return OK$2(input.data);
  }
};
ZodNull$2.create = (params) => {
  return new ZodNull$2({
    typeName: ZodFirstPartyTypeKind$2.ZodNull,
    ...processCreateParams$2(params)
  });
};
let ZodAny$2 = class ZodAny9 extends ZodType$2 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$2(input.data);
  }
};
ZodAny$2.create = (params) => {
  return new ZodAny$2({
    typeName: ZodFirstPartyTypeKind$2.ZodAny,
    ...processCreateParams$2(params)
  });
};
let ZodUnknown$2 = class ZodUnknown9 extends ZodType$2 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$2(input.data);
  }
};
ZodUnknown$2.create = (params) => {
  return new ZodUnknown$2({
    typeName: ZodFirstPartyTypeKind$2.ZodUnknown,
    ...processCreateParams$2(params)
  });
};
let ZodNever$2 = class ZodNever9 extends ZodType$2 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$2(ctx, {
      code: ZodIssueCode$2.invalid_type,
      expected: ZodParsedType$2.never,
      received: ctx.parsedType
    });
    return INVALID$2;
  }
};
ZodNever$2.create = (params) => {
  return new ZodNever$2({
    typeName: ZodFirstPartyTypeKind$2.ZodNever,
    ...processCreateParams$2(params)
  });
};
let ZodVoid$2 = class ZodVoid9 extends ZodType$2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.void,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    return OK$2(input.data);
  }
};
ZodVoid$2.create = (params) => {
  return new ZodVoid$2({
    typeName: ZodFirstPartyTypeKind$2.ZodVoid,
    ...processCreateParams$2(params)
  });
};
let ZodArray$2 = class ZodArray9 extends ZodType$2 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def2 = this._def;
    if (ctx.parsedType !== ZodParsedType$2.array) {
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.array,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    if (def2.exactLength !== null) {
      const tooBig = ctx.data.length > def2.exactLength.value;
      const tooSmall = ctx.data.length < def2.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$2(ctx, {
          code: tooBig ? ZodIssueCode$2.too_big : ZodIssueCode$2.too_small,
          minimum: tooSmall ? def2.exactLength.value : void 0,
          maximum: tooBig ? def2.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def2.exactLength.message
        });
        status.dirty();
      }
    }
    if (def2.minLength !== null) {
      if (ctx.data.length < def2.minLength.value) {
        addIssueToContext$2(ctx, {
          code: ZodIssueCode$2.too_small,
          minimum: def2.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.minLength.message
        });
        status.dirty();
      }
    }
    if (def2.maxLength !== null) {
      if (ctx.data.length > def2.maxLength.value) {
        addIssueToContext$2(ctx, {
          code: ZodIssueCode$2.too_big,
          maximum: def2.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def2.type._parseAsync(new ParseInputLazyPath$2(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$2.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def2.type._parseSync(new ParseInputLazyPath$2(ctx, item, ctx.path, i));
    });
    return ParseStatus$2.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray9({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$2.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray9({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$2.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray9({
      ...this._def,
      exactLength: { value: len, message: errorUtil$2.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$2.create = (schema, params) => {
  return new ZodArray$2({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$2.ZodArray,
    ...processCreateParams$2(params)
  });
};
function deepPartialify$2(schema) {
  if (schema instanceof ZodObject$2) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$2.create(deepPartialify$2(fieldSchema));
    }
    return new ZodObject$2({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$2) {
    return new ZodArray$2({
      ...schema._def,
      type: deepPartialify$2(schema.element)
    });
  } else if (schema instanceof ZodOptional$2) {
    return ZodOptional$2.create(deepPartialify$2(schema.unwrap()));
  } else if (schema instanceof ZodNullable$2) {
    return ZodNullable$2.create(deepPartialify$2(schema.unwrap()));
  } else if (schema instanceof ZodTuple$2) {
    return ZodTuple$2.create(schema.items.map((item) => deepPartialify$2(item)));
  } else {
    return schema;
  }
}
let ZodObject$2 = class ZodObject9 extends ZodType$2 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$2.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx2, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.object,
        received: ctx2.parsedType
      });
      return INVALID$2;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$2 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$2(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$2) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$2(ctx, {
            code: ZodIssueCode$2.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$2(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$2.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$2.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$2.errToObj;
    return new ZodObject9({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil$2.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject9({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject9({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject9({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject9({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$2.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject9({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util$2.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject9({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util$2.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject9({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$2(this);
  }
  partial(mask) {
    const newShape = {};
    util$2.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject9({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util$2.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$2) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject9({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$2(util$2.objectKeys(this.shape));
  }
};
ZodObject$2.create = (shape, params) => {
  return new ZodObject$2({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$2.create(),
    typeName: ZodFirstPartyTypeKind$2.ZodObject,
    ...processCreateParams$2(params)
  });
};
ZodObject$2.strictCreate = (shape, params) => {
  return new ZodObject$2({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$2.create(),
    typeName: ZodFirstPartyTypeKind$2.ZodObject,
    ...processCreateParams$2(params)
  });
};
ZodObject$2.lazycreate = (shape, params) => {
  return new ZodObject$2({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$2.create(),
    typeName: ZodFirstPartyTypeKind$2.ZodObject,
    ...processCreateParams$2(params)
  });
};
let ZodUnion$2 = class ZodUnion9 extends ZodType$2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$2(result.ctx.common.issues));
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_union,
        unionErrors
      });
      return INVALID$2;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$2(issues2));
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_union,
        unionErrors
      });
      return INVALID$2;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$2.create = (types, params) => {
  return new ZodUnion$2({
    options: types,
    typeName: ZodFirstPartyTypeKind$2.ZodUnion,
    ...processCreateParams$2(params)
  });
};
const getDiscriminator$2 = (type) => {
  if (type instanceof ZodLazy$2) {
    return getDiscriminator$2(type.schema);
  } else if (type instanceof ZodEffects$2) {
    return getDiscriminator$2(type.innerType());
  } else if (type instanceof ZodLiteral$2) {
    return [type.value];
  } else if (type instanceof ZodEnum$2) {
    return type.options;
  } else if (type instanceof ZodNativeEnum$2) {
    return util$2.objectValues(type.enum);
  } else if (type instanceof ZodDefault$2) {
    return getDiscriminator$2(type._def.innerType);
  } else if (type instanceof ZodUndefined$2) {
    return [void 0];
  } else if (type instanceof ZodNull$2) {
    return [null];
  } else if (type instanceof ZodOptional$2) {
    return [void 0, ...getDiscriminator$2(type.unwrap())];
  } else if (type instanceof ZodNullable$2) {
    return [null, ...getDiscriminator$2(type.unwrap())];
  } else if (type instanceof ZodBranded$2) {
    return getDiscriminator$2(type.unwrap());
  } else if (type instanceof ZodReadonly$2) {
    return getDiscriminator$2(type.unwrap());
  } else if (type instanceof ZodCatch$2) {
    return getDiscriminator$2(type._def.innerType);
  } else {
    return [];
  }
};
let ZodDiscriminatedUnion$2 = class ZodDiscriminatedUnion9 extends ZodType$2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$2.object) {
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.object,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID$2;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator$2(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion9({
      typeName: ZodFirstPartyTypeKind$2.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams$2(params)
    });
  }
};
function mergeValues$2(a, b) {
  const aType = getParsedType$2(a);
  const bType = getParsedType$2(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$2.object && bType === ZodParsedType$2.object) {
    const bKeys = util$2.objectKeys(b);
    const sharedKeys = util$2.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$2(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$2.array && bType === ZodParsedType$2.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$2(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$2.date && bType === ZodParsedType$2.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$2 = class ZodIntersection9 extends ZodType$2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$2(parsedLeft) || isAborted$2(parsedRight)) {
        return INVALID$2;
      }
      const merged = mergeValues$2(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$2(ctx, {
          code: ZodIssueCode$2.invalid_intersection_types
        });
        return INVALID$2;
      }
      if (isDirty$2(parsedLeft) || isDirty$2(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$2.create = (left, right, params) => {
  return new ZodIntersection$2({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$2.ZodIntersection,
    ...processCreateParams$2(params)
  });
};
let ZodTuple$2 = class ZodTuple9 extends ZodType$2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$2.array) {
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.array,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$2;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$2(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$2.mergeArray(status, results);
      });
    } else {
      return ParseStatus$2.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple9({
      ...this._def,
      rest
    });
  }
};
ZodTuple$2.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$2({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$2.ZodTuple,
    rest: null,
    ...processCreateParams$2(params)
  });
};
let ZodRecord$2 = class ZodRecord9 extends ZodType$2 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$2.object) {
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.object,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath$2(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath$2(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus$2.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus$2.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType$2) {
      return new ZodRecord9({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind$2.ZodRecord,
        ...processCreateParams$2(third)
      });
    }
    return new ZodRecord9({
      keyType: ZodString$2.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind$2.ZodRecord,
      ...processCreateParams$2(second)
    });
  }
};
let ZodMap$2 = class ZodMap9 extends ZodType$2 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$2.map) {
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.map,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$2(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$2(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$2;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$2;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$2.create = (keyType, valueType, params) => {
  return new ZodMap$2({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$2.ZodMap,
    ...processCreateParams$2(params)
  });
};
let ZodSet$2 = class ZodSet9 extends ZodType$2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$2.set) {
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.set,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    const def2 = this._def;
    if (def2.minSize !== null) {
      if (ctx.data.size < def2.minSize.value) {
        addIssueToContext$2(ctx, {
          code: ZodIssueCode$2.too_small,
          minimum: def2.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.minSize.message
        });
        status.dirty();
      }
    }
    if (def2.maxSize !== null) {
      if (ctx.data.size > def2.maxSize.value) {
        addIssueToContext$2(ctx, {
          code: ZodIssueCode$2.too_big,
          maximum: def2.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements22) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements22) {
        if (element.status === "aborted")
          return INVALID$2;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements2 = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$2(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements2).then((elements22) => finalizeSet(elements22));
    } else {
      return finalizeSet(elements2);
    }
  }
  min(minSize, message) {
    return new ZodSet9({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$2.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet9({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$2.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$2.create = (valueType, params) => {
  return new ZodSet$2({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$2.ZodSet,
    ...processCreateParams$2(params)
  });
};
let ZodFunction$2 = class ZodFunction9 extends ZodType$2 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$2.function) {
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.function,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    function makeArgsIssue(args, error) {
      return makeIssue$2({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$2(),
          errorMap$2
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$2.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue$2({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$2(),
          errorMap$2
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$2.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise$2) {
      const me = this;
      return OK$2(async function(...args) {
        const error = new ZodError$2([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK$2(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError$2([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError$2([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction9({
      ...this._def,
      args: ZodTuple$2.create(items).rest(ZodUnknown$2.create())
    });
  }
  returns(returnType) {
    return new ZodFunction9({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction9({
      args: args ? args : ZodTuple$2.create([]).rest(ZodUnknown$2.create()),
      returns: returns || ZodUnknown$2.create(),
      typeName: ZodFirstPartyTypeKind$2.ZodFunction,
      ...processCreateParams$2(params)
    });
  }
};
let ZodLazy$2 = class ZodLazy9 extends ZodType$2 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$2.create = (getter, params) => {
  return new ZodLazy$2({
    getter,
    typeName: ZodFirstPartyTypeKind$2.ZodLazy,
    ...processCreateParams$2(params)
  });
};
let ZodLiteral$2 = class ZodLiteral9 extends ZodType$2 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx, {
        received: ctx.data,
        code: ZodIssueCode$2.invalid_literal,
        expected: this._def.value
      });
      return INVALID$2;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$2.create = (value, params) => {
  return new ZodLiteral$2({
    value,
    typeName: ZodFirstPartyTypeKind$2.ZodLiteral,
    ...processCreateParams$2(params)
  });
};
function createZodEnum$2(values, params) {
  return new ZodEnum$2({
    values,
    typeName: ZodFirstPartyTypeKind$2.ZodEnum,
    ...processCreateParams$2(params)
  });
}
let ZodEnum$2 = class ZodEnum9 extends ZodType$2 {
  constructor() {
    super(...arguments);
    _ZodEnum_cache$2.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$2(ctx, {
        expected: util$2.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$2.invalid_type
      });
      return INVALID$2;
    }
    if (!__classPrivateFieldGet$2(this, _ZodEnum_cache$2)) {
      __classPrivateFieldSet$2(this, _ZodEnum_cache$2, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet$2(this, _ZodEnum_cache$2).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$2(ctx, {
        received: ctx.data,
        code: ZodIssueCode$2.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$2;
    }
    return OK$2(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum9.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum9.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache$2 = /* @__PURE__ */ new WeakMap();
ZodEnum$2.create = createZodEnum$2;
let ZodNativeEnum$2 = class ZodNativeEnum9 extends ZodType$2 {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache$2.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util$2.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$2.string && ctx.parsedType !== ZodParsedType$2.number) {
      const expectedValues = util$2.objectValues(nativeEnumValues);
      addIssueToContext$2(ctx, {
        expected: util$2.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$2.invalid_type
      });
      return INVALID$2;
    }
    if (!__classPrivateFieldGet$2(this, _ZodNativeEnum_cache$2)) {
      __classPrivateFieldSet$2(this, _ZodNativeEnum_cache$2, new Set(util$2.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet$2(this, _ZodNativeEnum_cache$2).has(input.data)) {
      const expectedValues = util$2.objectValues(nativeEnumValues);
      addIssueToContext$2(ctx, {
        received: ctx.data,
        code: ZodIssueCode$2.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$2;
    }
    return OK$2(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache$2 = /* @__PURE__ */ new WeakMap();
ZodNativeEnum$2.create = (values, params) => {
  return new ZodNativeEnum$2({
    values,
    typeName: ZodFirstPartyTypeKind$2.ZodNativeEnum,
    ...processCreateParams$2(params)
  });
};
let ZodPromise$2 = class ZodPromise9 extends ZodType$2 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$2.promise && ctx.common.async === false) {
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.promise,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    const promisified = ctx.parsedType === ZodParsedType$2.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$2(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$2.create = (schema, params) => {
  return new ZodPromise$2({
    type: schema,
    typeName: ZodFirstPartyTypeKind$2.ZodPromise,
    ...processCreateParams$2(params)
  });
};
let ZodEffects$2 = class ZodEffects9 extends ZodType$2 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$2.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$2(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$2;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$2;
          if (result.status === "dirty")
            return DIRTY$2(result.value);
          if (status.value === "dirty")
            return DIRTY$2(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$2;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$2;
        if (result.status === "dirty")
          return DIRTY$2(result.value);
        if (status.value === "dirty")
          return DIRTY$2(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$2;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$2;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$2(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$2(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util$2.assertNever(effect);
  }
};
ZodEffects$2.create = (schema, effect, params) => {
  return new ZodEffects$2({
    schema,
    typeName: ZodFirstPartyTypeKind$2.ZodEffects,
    effect,
    ...processCreateParams$2(params)
  });
};
ZodEffects$2.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$2({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$2.ZodEffects,
    ...processCreateParams$2(params)
  });
};
let ZodOptional$2 = class ZodOptional9 extends ZodType$2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$2.undefined) {
      return OK$2(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$2.create = (type, params) => {
  return new ZodOptional$2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$2.ZodOptional,
    ...processCreateParams$2(params)
  });
};
let ZodNullable$2 = class ZodNullable9 extends ZodType$2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$2.null) {
      return OK$2(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$2.create = (type, params) => {
  return new ZodNullable$2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$2.ZodNullable,
    ...processCreateParams$2(params)
  });
};
let ZodDefault$2 = class ZodDefault9 extends ZodType$2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$2.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$2.create = (type, params) => {
  return new ZodDefault$2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$2.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$2(params)
  });
};
let ZodCatch$2 = class ZodCatch9 extends ZodType$2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$2(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$2(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$2(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$2.create = (type, params) => {
  return new ZodCatch$2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$2.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$2(params)
  });
};
let ZodNaN$2 = class ZodNaN9 extends ZodType$2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$2.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$2(ctx, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.nan,
        received: ctx.parsedType
      });
      return INVALID$2;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$2.create = (params) => {
  return new ZodNaN$2({
    typeName: ZodFirstPartyTypeKind$2.ZodNaN,
    ...processCreateParams$2(params)
  });
};
const BRAND$2 = Symbol("zod_brand");
let ZodBranded$2 = class ZodBranded9 extends ZodType$2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$2 = class ZodPipeline9 extends ZodType$2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$2;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$2(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$2;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline9({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$2.ZodPipeline
    });
  }
};
let ZodReadonly$2 = class ZodReadonly9 extends ZodType$2 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$2(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$2(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$2.create = (type, params) => {
  return new ZodReadonly$2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$2.ZodReadonly,
    ...processCreateParams$2(params)
  });
};
function cleanParams$2(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom$2(check, _params = {}, fatal) {
  if (check)
    return ZodAny$2.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams$2(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams$2(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny$2.create();
}
const late$2 = {
  object: ZodObject$2.lazycreate
};
var ZodFirstPartyTypeKind$2;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$2 || (ZodFirstPartyTypeKind$2 = {}));
const instanceOfType$2 = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom$2((data) => data instanceof cls, params);
const stringType$2 = ZodString$2.create;
const numberType$2 = ZodNumber$2.create;
const nanType$2 = ZodNaN$2.create;
const bigIntType$2 = ZodBigInt$2.create;
const booleanType$2 = ZodBoolean$2.create;
const dateType$2 = ZodDate$2.create;
const symbolType$2 = ZodSymbol$2.create;
const undefinedType$2 = ZodUndefined$2.create;
const nullType$2 = ZodNull$2.create;
const anyType$2 = ZodAny$2.create;
const unknownType$2 = ZodUnknown$2.create;
const neverType$2 = ZodNever$2.create;
const voidType$2 = ZodVoid$2.create;
const arrayType$2 = ZodArray$2.create;
const objectType$2 = ZodObject$2.create;
const strictObjectType$2 = ZodObject$2.strictCreate;
const unionType$2 = ZodUnion$2.create;
const discriminatedUnionType$2 = ZodDiscriminatedUnion$2.create;
const intersectionType$2 = ZodIntersection$2.create;
const tupleType$2 = ZodTuple$2.create;
const recordType$2 = ZodRecord$2.create;
const mapType$2 = ZodMap$2.create;
const setType$2 = ZodSet$2.create;
const functionType$2 = ZodFunction$2.create;
const lazyType$2 = ZodLazy$2.create;
const literalType$2 = ZodLiteral$2.create;
const enumType$2 = ZodEnum$2.create;
const nativeEnumType$2 = ZodNativeEnum$2.create;
const promiseType$2 = ZodPromise$2.create;
const effectsType$2 = ZodEffects$2.create;
const optionalType$2 = ZodOptional$2.create;
const nullableType$2 = ZodNullable$2.create;
const preprocessType$2 = ZodEffects$2.createWithPreprocess;
const pipelineType$2 = ZodPipeline$2.create;
const ostring$2 = () => stringType$2().optional();
const onumber$2 = () => numberType$2().optional();
const oboolean$2 = () => booleanType$2().optional();
const coerce$2 = {
  string: (arg) => ZodString$2.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber$2.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean$2.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt$2.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate$2.create({ ...arg, coerce: true })
};
const NEVER$2 = INVALID$2;
var z$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap$2,
  setErrorMap: setErrorMap$2,
  getErrorMap: getErrorMap$2,
  makeIssue: makeIssue$2,
  EMPTY_PATH: EMPTY_PATH$2,
  addIssueToContext: addIssueToContext$2,
  ParseStatus: ParseStatus$2,
  INVALID: INVALID$2,
  DIRTY: DIRTY$2,
  OK: OK$2,
  isAborted: isAborted$2,
  isDirty: isDirty$2,
  isValid: isValid$2,
  isAsync: isAsync$2,
  get util() {
    return util$2;
  },
  get objectUtil() {
    return objectUtil$2;
  },
  ZodParsedType: ZodParsedType$2,
  getParsedType: getParsedType$2,
  ZodType: ZodType$2,
  datetimeRegex: datetimeRegex$2,
  ZodString: ZodString$2,
  ZodNumber: ZodNumber$2,
  ZodBigInt: ZodBigInt$2,
  ZodBoolean: ZodBoolean$2,
  ZodDate: ZodDate$2,
  ZodSymbol: ZodSymbol$2,
  ZodUndefined: ZodUndefined$2,
  ZodNull: ZodNull$2,
  ZodAny: ZodAny$2,
  ZodUnknown: ZodUnknown$2,
  ZodNever: ZodNever$2,
  ZodVoid: ZodVoid$2,
  ZodArray: ZodArray$2,
  ZodObject: ZodObject$2,
  ZodUnion: ZodUnion$2,
  ZodDiscriminatedUnion: ZodDiscriminatedUnion$2,
  ZodIntersection: ZodIntersection$2,
  ZodTuple: ZodTuple$2,
  ZodRecord: ZodRecord$2,
  ZodMap: ZodMap$2,
  ZodSet: ZodSet$2,
  ZodFunction: ZodFunction$2,
  ZodLazy: ZodLazy$2,
  ZodLiteral: ZodLiteral$2,
  ZodEnum: ZodEnum$2,
  ZodNativeEnum: ZodNativeEnum$2,
  ZodPromise: ZodPromise$2,
  ZodEffects: ZodEffects$2,
  ZodTransformer: ZodEffects$2,
  ZodOptional: ZodOptional$2,
  ZodNullable: ZodNullable$2,
  ZodDefault: ZodDefault$2,
  ZodCatch: ZodCatch$2,
  ZodNaN: ZodNaN$2,
  BRAND: BRAND$2,
  ZodBranded: ZodBranded$2,
  ZodPipeline: ZodPipeline$2,
  ZodReadonly: ZodReadonly$2,
  custom: custom$2,
  Schema: ZodType$2,
  ZodSchema: ZodType$2,
  late: late$2,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind$2;
  },
  coerce: coerce$2,
  any: anyType$2,
  array: arrayType$2,
  bigint: bigIntType$2,
  boolean: booleanType$2,
  date: dateType$2,
  discriminatedUnion: discriminatedUnionType$2,
  effect: effectsType$2,
  "enum": enumType$2,
  "function": functionType$2,
  "instanceof": instanceOfType$2,
  intersection: intersectionType$2,
  lazy: lazyType$2,
  literal: literalType$2,
  map: mapType$2,
  nan: nanType$2,
  nativeEnum: nativeEnumType$2,
  never: neverType$2,
  "null": nullType$2,
  nullable: nullableType$2,
  number: numberType$2,
  object: objectType$2,
  oboolean: oboolean$2,
  onumber: onumber$2,
  optional: optionalType$2,
  ostring: ostring$2,
  pipeline: pipelineType$2,
  preprocess: preprocessType$2,
  promise: promiseType$2,
  record: recordType$2,
  set: setType$2,
  strictObject: strictObjectType$2,
  string: stringType$2,
  symbol: symbolType$2,
  transformer: effectsType$2,
  tuple: tupleType$2,
  "undefined": undefinedType$2,
  union: unionType$2,
  unknown: unknownType$2,
  "void": voidType$2,
  NEVER: NEVER$2,
  ZodIssueCode: ZodIssueCode$2,
  quotelessJson: quotelessJson$2,
  ZodError: ZodError$2
});
const FONT_FAMILY_NAMES$2 = [
  "MODERN_SANS",
  "BOOK_SANS",
  "ORGANIC_SANS",
  "GEOMETRIC_SANS",
  "HEAVY_SANS",
  "ROUNDED_SANS",
  "MODERN_SERIF",
  "BOOK_SERIF",
  "MONOSPACE"
];
const PADDING_SCHEMA$1 = z$2.object({
  top: z$2.number(),
  bottom: z$2.number(),
  right: z$2.number(),
  left: z$2.number()
}).optional().nullable();
const COLOR_SCHEMA$2 = z$2.string().regex(/^#[0-9a-fA-F]{6}$/).nullable().optional();
z$2.enum(FONT_FAMILY_NAMES$2).nullable().optional();
const getPadding$1 = (padding) => padding ? `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px` : void 0;
const _hoisted_1$1 = {
  align: "center",
  width: "100%",
  cellPadding: "0",
  border: "0",
  style: { tableLayout: "fixed", borderCollapse: "collapse" }
};
const _hoisted_2 = { style: { width: "100%" } };
const _hoisted_3 = { style: { width: "100%" } };
const FIXED_WIDTHS_SCHEMA = z$2.tuple([z$2.number().nullish(), z$2.number().nullish(), z$2.number().nullish()]).optional().nullable();
const ColumnsContainerPropsSchema$1 = z$2.object({
  style: z$2.object({
    backgroundColor: COLOR_SCHEMA$2,
    padding: PADDING_SCHEMA$1
  }).optional().nullable(),
  props: z$2.object({
    fixedWidths: FIXED_WIDTHS_SCHEMA,
    columnsCount: z$2.union([z$2.literal(2), z$2.literal(3)]).optional().nullable(),
    columnsGap: z$2.number().optional().nullable(),
    contentAlignment: z$2.enum(["top", "middle", "bottom"]).optional().nullable()
  }).optional().nullable()
});
const ColumnsContainerPropsDefaults = {
  columnsCount: 2,
  columnsGap: 0,
  contentAlignment: "middle"
};
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    style: {},
    props: {}
  },
  setup(__props) {
    const props = __props;
    const wStyle = computed(() => {
      var _a, _b;
      return {
        backgroundColor: ((_a = props.style) == null ? void 0 : _a.backgroundColor) ?? void 0,
        padding: getPadding$1((_b = props.style) == null ? void 0 : _b.padding)
      };
    });
    const blockProps = computed(() => {
      var _a, _b, _c, _d;
      return {
        columnsCount: ((_a = props.props) == null ? void 0 : _a.columnsCount) ?? ColumnsContainerPropsDefaults.columnsCount,
        columnsGap: ((_b = props.props) == null ? void 0 : _b.columnsGap) ?? ColumnsContainerPropsDefaults.columnsGap,
        contentAlignment: ((_c = props.props) == null ? void 0 : _c.contentAlignment) ?? ColumnsContainerPropsDefaults.contentAlignment,
        fixedWidths: (_d = props.props) == null ? void 0 : _d.fixedWidths
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        style: normalizeStyle(wStyle.value)
      }, [
        createElementVNode("table", _hoisted_1$1, [
          createElementVNode("tbody", _hoisted_2, [
            createElementVNode("tr", _hoisted_3, [
              createVNode(_sfc_main$1$1, {
                index: 0,
                props: blockProps.value
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "column-0")
                ]),
                _: 3
              }, 8, ["props"]),
              createVNode(_sfc_main$1$1, {
                index: 1,
                props: blockProps.value
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "column-1")
                ]),
                _: 3
              }, 8, ["props"]),
              createVNode(_sfc_main$1$1, {
                index: 2,
                props: blockProps.value
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "column-2")
                ]),
                _: 3
              }, 8, ["props"])
            ])
          ])
        ])
      ], 4);
    };
  }
});
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "ReaderEditorChildrenIds",
  props: {
    document: {},
    childrenIds: {}
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.childrenIds, (childId) => {
        return openBlock(), createBlock(_sfc_main$1, {
          key: childId,
          id: childId,
          document: _ctx.document
        }, null, 8, ["id", "document"]);
      }), 128);
    };
  }
});
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "ColumnsContainerReader",
  props: {
    style: {},
    document: {},
    props: {}
  },
  setup(__props) {
    const props = __props;
    const columns = computed(() => {
      var _a;
      return (_a = props.props) == null ? void 0 : _a.columns;
    });
    const restProps = computed(() => {
      const { columns: _, ...rest } = props.props ?? {};
      return rest;
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$6), {
        props: restProps.value,
        style: normalizeStyle(_ctx.style)
      }, {
        "column-0": withCtx(() => {
          var _a, _b;
          return [
            createVNode(_sfc_main$5, {
              "children-ids": (_b = (_a = columns.value) == null ? void 0 : _a[0]) == null ? void 0 : _b.childrenIds,
              document: _ctx.document
            }, null, 8, ["children-ids", "document"])
          ];
        }),
        "column-1": withCtx(() => {
          var _a, _b;
          return [
            createVNode(_sfc_main$5, {
              "children-ids": (_b = (_a = columns.value) == null ? void 0 : _a[1]) == null ? void 0 : _b.childrenIds,
              document: _ctx.document
            }, null, 8, ["children-ids", "document"])
          ];
        }),
        "column-2": withCtx(() => {
          var _a, _b;
          return [
            createVNode(_sfc_main$5, {
              "children-ids": (_b = (_a = columns.value) == null ? void 0 : _a[2]) == null ? void 0 : _b.childrenIds,
              document: _ctx.document
            }, null, 8, ["children-ids", "document"])
          ];
        }),
        _: 1
      }, 8, ["props", "style"]);
    };
  }
});
var util$1;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$1 || (util$1 = {}));
var objectUtil$1;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil$1 || (objectUtil$1 = {}));
const ZodParsedType$1 = util$1.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType$1 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType$1.undefined;
    case "string":
      return ZodParsedType$1.string;
    case "number":
      return isNaN(data) ? ZodParsedType$1.nan : ZodParsedType$1.number;
    case "boolean":
      return ZodParsedType$1.boolean;
    case "function":
      return ZodParsedType$1.function;
    case "bigint":
      return ZodParsedType$1.bigint;
    case "symbol":
      return ZodParsedType$1.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType$1.array;
      }
      if (data === null) {
        return ZodParsedType$1.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType$1.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType$1.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType$1.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType$1.date;
      }
      return ZodParsedType$1.object;
    default:
      return ZodParsedType$1.unknown;
  }
};
const ZodIssueCode$1 = util$1.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson$1 = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
let ZodError$1 = class ZodError10 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError10)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$1.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$1.create = (issues) => {
  const error = new ZodError$1(issues);
  return error;
};
const errorMap$1 = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode$1.invalid_type:
      if (issue.received === ZodParsedType$1.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode$1.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$1.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$1.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$1.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode$1.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode$1.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$1.joinValues(issue.options)}`;
      break;
    case ZodIssueCode$1.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$1.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode$1.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode$1.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode$1.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode$1.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util$1.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode$1.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$1.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode$1.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode$1.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode$1.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode$1.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$1.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap$1 = errorMap$1;
function setErrorMap$1(map) {
  overrideErrorMap$1 = map;
}
function getErrorMap$1() {
  return overrideErrorMap$1;
}
const makeIssue$1 = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH$1 = [];
function addIssueToContext$1(ctx, issueData) {
  const overrideMap = getErrorMap$1();
  const issue = makeIssue$1({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap$1 ? void 0 : errorMap$1
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
let ParseStatus$1 = class ParseStatus10 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID$1;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus10.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID$1;
      if (value.status === "aborted")
        return INVALID$1;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
const INVALID$1 = Object.freeze({
  status: "aborted"
});
const DIRTY$1 = (value) => ({ status: "dirty", value });
const OK$1 = (value) => ({ status: "valid", value });
const isAborted$1 = (x) => x.status === "aborted";
const isDirty$1 = (x) => x.status === "dirty";
const isValid$1 = (x) => x.status === "valid";
const isAsync$1 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet$1(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet$1(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil$1;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil$1 || (errorUtil$1 = {}));
var _ZodEnum_cache$1, _ZodNativeEnum_cache$1;
let ParseInputLazyPath$1 = class ParseInputLazyPath10 {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
const handleResult$1 = (ctx, result) => {
  if (isValid$1(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError$1(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams$1(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$1 = class ZodType10 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType$1(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType$1(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus$1(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$1(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync$1(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$1(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult$1(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$1(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid$1(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$1(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType$1(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync$1(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult$1(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode$1.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects$1({
      schema: this,
      typeName: ZodFirstPartyTypeKind$1.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def2) {
    this.spa = this.safeParseAsync;
    this._def = def2;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$1.create(this, this._def);
  }
  nullable() {
    return ZodNullable$1.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$1.create(this);
  }
  promise() {
    return ZodPromise$1.create(this, this._def);
  }
  or(option) {
    return ZodUnion$1.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$1.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects$1({
      ...processCreateParams$1(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$1.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def2) {
    const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodDefault$1({
      ...processCreateParams$1(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind$1.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$1({
      typeName: ZodFirstPartyTypeKind$1.ZodBranded,
      type: this,
      ...processCreateParams$1(this._def)
    });
  }
  catch(def2) {
    const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodCatch$1({
      ...processCreateParams$1(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind$1.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline$1.create(this, target);
  }
  readonly() {
    return ZodReadonly$1.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$1 = /^c[^\s-]{8,}$/i;
const cuid2Regex$1 = /^[0-9a-z]+$/;
const ulidRegex$1 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex$1 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex$1 = /^[a-z0-9_-]{21}$/i;
const jwtRegex$1 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex$1 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex$1 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$1;
const ipv4Regex$1 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex$1 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex$1 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex$1 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$1 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex$1 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource$1 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex$1 = new RegExp(`^${dateRegexSource$1}$`);
function timeRegexSource$1(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex$1(args) {
  return new RegExp(`^${timeRegexSource$1(args)}$`);
}
function datetimeRegex$1(args) {
  let regex = `${dateRegexSource$1}T${timeRegexSource$1(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP$1(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex$1.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex$1.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT$1(jwt, alg) {
  if (!jwtRegex$1.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr$1(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex$1.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex$1.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$1 = class ZodString10 extends ZodType$1 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx2, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.string,
        received: ctx2.parsedType
      });
      return INVALID$1;
    }
    const status = new ParseStatus$1();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "email",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$1) {
          emojiRegex$1 = new RegExp(_emojiRegex$1, "u");
        }
        if (!emojiRegex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "emoji",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "uuid",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "nanoid",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "cuid",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "cuid2",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "ulid",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "url",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "regex",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex$1(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex$1;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex$1(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "duration",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP$1(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "ip",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT$1(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "jwt",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr$1(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "cidr",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "base64",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            validation: "base64url",
            code: ZodIssueCode$1.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$1.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode$1.invalid_string,
      ...errorUtil$1.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString10({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil$1.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil$1.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil$1.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil$1.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil$1.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil$1.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$1.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil$1.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil$1.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil$1.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil$1.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil$1.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil$1.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil$1.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil$1.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil$1.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil$1.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil$1.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil$1.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil$1.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil$1.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil$1.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil$1.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil$1.errToObj(message));
  }
  trim() {
    return new ZodString10({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString10({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString10({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$1.create = (params) => {
  var _a;
  return new ZodString$1({
    checks: [],
    typeName: ZodFirstPartyTypeKind$1.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$1(params)
  });
};
function floatSafeRemainder$1(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
let ZodNumber$1 = class ZodNumber10 extends ZodType$1 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx2, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.number,
        received: ctx2.parsedType
      });
      return INVALID$1;
    }
    let ctx = void 0;
    const status = new ParseStatus$1();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$1.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder$1(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$1.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$1.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$1.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$1.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$1.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber10({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$1.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber10({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$1.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil$1.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil$1.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil$1.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil$1.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$1.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$1.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$1.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$1.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$1.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$1.create = (params) => {
  return new ZodNumber$1({
    checks: [],
    typeName: ZodFirstPartyTypeKind$1.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$1(params)
  });
};
let ZodBigInt$1 = class ZodBigInt10 extends ZodType$1 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus$1();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$1.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$1(ctx, {
      code: ZodIssueCode$1.invalid_type,
      expected: ZodParsedType$1.bigint,
      received: ctx.parsedType
    });
    return INVALID$1;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil$1.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil$1.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil$1.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil$1.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt10({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil$1.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt10({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$1.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil$1.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$1.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil$1.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil$1.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt$1.create = (params) => {
  var _a;
  return new ZodBigInt$1({
    checks: [],
    typeName: ZodFirstPartyTypeKind$1.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams$1(params)
  });
};
let ZodBoolean$1 = class ZodBoolean10 extends ZodType$1 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.boolean,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    return OK$1(input.data);
  }
};
ZodBoolean$1.create = (params) => {
  return new ZodBoolean$1({
    typeName: ZodFirstPartyTypeKind$1.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams$1(params)
  });
};
let ZodDate$1 = class ZodDate10 extends ZodType$1 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx2, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.date,
        received: ctx2.parsedType
      });
      return INVALID$1;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx2, {
        code: ZodIssueCode$1.invalid_date
      });
      return INVALID$1;
    }
    const status = new ParseStatus$1();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$1.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate10({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil$1.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil$1.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate$1.create = (params) => {
  return new ZodDate$1({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind$1.ZodDate,
    ...processCreateParams$1(params)
  });
};
let ZodSymbol$1 = class ZodSymbol10 extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.symbol,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    return OK$1(input.data);
  }
};
ZodSymbol$1.create = (params) => {
  return new ZodSymbol$1({
    typeName: ZodFirstPartyTypeKind$1.ZodSymbol,
    ...processCreateParams$1(params)
  });
};
let ZodUndefined$1 = class ZodUndefined10 extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.undefined,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    return OK$1(input.data);
  }
};
ZodUndefined$1.create = (params) => {
  return new ZodUndefined$1({
    typeName: ZodFirstPartyTypeKind$1.ZodUndefined,
    ...processCreateParams$1(params)
  });
};
let ZodNull$1 = class ZodNull10 extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.null,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    return OK$1(input.data);
  }
};
ZodNull$1.create = (params) => {
  return new ZodNull$1({
    typeName: ZodFirstPartyTypeKind$1.ZodNull,
    ...processCreateParams$1(params)
  });
};
let ZodAny$1 = class ZodAny10 extends ZodType$1 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$1(input.data);
  }
};
ZodAny$1.create = (params) => {
  return new ZodAny$1({
    typeName: ZodFirstPartyTypeKind$1.ZodAny,
    ...processCreateParams$1(params)
  });
};
let ZodUnknown$1 = class ZodUnknown10 extends ZodType$1 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$1(input.data);
  }
};
ZodUnknown$1.create = (params) => {
  return new ZodUnknown$1({
    typeName: ZodFirstPartyTypeKind$1.ZodUnknown,
    ...processCreateParams$1(params)
  });
};
let ZodNever$1 = class ZodNever10 extends ZodType$1 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext$1(ctx, {
      code: ZodIssueCode$1.invalid_type,
      expected: ZodParsedType$1.never,
      received: ctx.parsedType
    });
    return INVALID$1;
  }
};
ZodNever$1.create = (params) => {
  return new ZodNever$1({
    typeName: ZodFirstPartyTypeKind$1.ZodNever,
    ...processCreateParams$1(params)
  });
};
let ZodVoid$1 = class ZodVoid10 extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.void,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    return OK$1(input.data);
  }
};
ZodVoid$1.create = (params) => {
  return new ZodVoid$1({
    typeName: ZodFirstPartyTypeKind$1.ZodVoid,
    ...processCreateParams$1(params)
  });
};
let ZodArray$1 = class ZodArray10 extends ZodType$1 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def2 = this._def;
    if (ctx.parsedType !== ZodParsedType$1.array) {
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.array,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    if (def2.exactLength !== null) {
      const tooBig = ctx.data.length > def2.exactLength.value;
      const tooSmall = ctx.data.length < def2.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext$1(ctx, {
          code: tooBig ? ZodIssueCode$1.too_big : ZodIssueCode$1.too_small,
          minimum: tooSmall ? def2.exactLength.value : void 0,
          maximum: tooBig ? def2.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def2.exactLength.message
        });
        status.dirty();
      }
    }
    if (def2.minLength !== null) {
      if (ctx.data.length < def2.minLength.value) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.too_small,
          minimum: def2.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.minLength.message
        });
        status.dirty();
      }
    }
    if (def2.maxLength !== null) {
      if (ctx.data.length > def2.maxLength.value) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.too_big,
          maximum: def2.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def2.type._parseAsync(new ParseInputLazyPath$1(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus$1.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def2.type._parseSync(new ParseInputLazyPath$1(ctx, item, ctx.path, i));
    });
    return ParseStatus$1.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray10({
      ...this._def,
      minLength: { value: minLength, message: errorUtil$1.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray10({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil$1.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray10({
      ...this._def,
      exactLength: { value: len, message: errorUtil$1.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$1.create = (schema, params) => {
  return new ZodArray$1({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind$1.ZodArray,
    ...processCreateParams$1(params)
  });
};
function deepPartialify$1(schema) {
  if (schema instanceof ZodObject$1) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$1.create(deepPartialify$1(fieldSchema));
    }
    return new ZodObject$1({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$1) {
    return new ZodArray$1({
      ...schema._def,
      type: deepPartialify$1(schema.element)
    });
  } else if (schema instanceof ZodOptional$1) {
    return ZodOptional$1.create(deepPartialify$1(schema.unwrap()));
  } else if (schema instanceof ZodNullable$1) {
    return ZodNullable$1.create(deepPartialify$1(schema.unwrap()));
  } else if (schema instanceof ZodTuple$1) {
    return ZodTuple$1.create(schema.items.map((item) => deepPartialify$1(item)));
  } else {
    return schema;
  }
}
let ZodObject$1 = class ZodObject10 extends ZodType$1 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$1.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx2, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.object,
        received: ctx2.parsedType
      });
      return INVALID$1;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$1 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath$1(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$1) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath$1(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus$1.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus$1.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil$1.errToObj;
    return new ZodObject10({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil$1.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject10({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject10({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject10({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject10({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$1.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject10({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util$1.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject10({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util$1.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject10({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$1(this);
  }
  partial(mask) {
    const newShape = {};
    util$1.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject10({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util$1.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$1) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject10({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum$1(util$1.objectKeys(this.shape));
  }
};
ZodObject$1.create = (shape, params) => {
  return new ZodObject$1({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$1.create(),
    typeName: ZodFirstPartyTypeKind$1.ZodObject,
    ...processCreateParams$1(params)
  });
};
ZodObject$1.strictCreate = (shape, params) => {
  return new ZodObject$1({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$1.create(),
    typeName: ZodFirstPartyTypeKind$1.ZodObject,
    ...processCreateParams$1(params)
  });
};
ZodObject$1.lazycreate = (shape, params) => {
  return new ZodObject$1({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$1.create(),
    typeName: ZodFirstPartyTypeKind$1.ZodObject,
    ...processCreateParams$1(params)
  });
};
let ZodUnion$1 = class ZodUnion10 extends ZodType$1 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError$1(result.ctx.common.issues));
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_union,
        unionErrors
      });
      return INVALID$1;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError$1(issues2));
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_union,
        unionErrors
      });
      return INVALID$1;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$1.create = (types, params) => {
  return new ZodUnion$1({
    options: types,
    typeName: ZodFirstPartyTypeKind$1.ZodUnion,
    ...processCreateParams$1(params)
  });
};
const getDiscriminator$1 = (type) => {
  if (type instanceof ZodLazy$1) {
    return getDiscriminator$1(type.schema);
  } else if (type instanceof ZodEffects$1) {
    return getDiscriminator$1(type.innerType());
  } else if (type instanceof ZodLiteral$1) {
    return [type.value];
  } else if (type instanceof ZodEnum$1) {
    return type.options;
  } else if (type instanceof ZodNativeEnum$1) {
    return util$1.objectValues(type.enum);
  } else if (type instanceof ZodDefault$1) {
    return getDiscriminator$1(type._def.innerType);
  } else if (type instanceof ZodUndefined$1) {
    return [void 0];
  } else if (type instanceof ZodNull$1) {
    return [null];
  } else if (type instanceof ZodOptional$1) {
    return [void 0, ...getDiscriminator$1(type.unwrap())];
  } else if (type instanceof ZodNullable$1) {
    return [null, ...getDiscriminator$1(type.unwrap())];
  } else if (type instanceof ZodBranded$1) {
    return getDiscriminator$1(type.unwrap());
  } else if (type instanceof ZodReadonly$1) {
    return getDiscriminator$1(type.unwrap());
  } else if (type instanceof ZodCatch$1) {
    return getDiscriminator$1(type._def.innerType);
  } else {
    return [];
  }
};
let ZodDiscriminatedUnion$1 = class ZodDiscriminatedUnion10 extends ZodType$1 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$1.object) {
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.object,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID$1;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator$1(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion10({
      typeName: ZodFirstPartyTypeKind$1.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams$1(params)
    });
  }
};
function mergeValues$1(a, b) {
  const aType = getParsedType$1(a);
  const bType = getParsedType$1(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType$1.object && bType === ZodParsedType$1.object) {
    const bKeys = util$1.objectKeys(b);
    const sharedKeys = util$1.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$1(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType$1.array && bType === ZodParsedType$1.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$1(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType$1.date && bType === ZodParsedType$1.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$1 = class ZodIntersection10 extends ZodType$1 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted$1(parsedLeft) || isAborted$1(parsedRight)) {
        return INVALID$1;
      }
      const merged = mergeValues$1(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_intersection_types
        });
        return INVALID$1;
      }
      if (isDirty$1(parsedLeft) || isDirty$1(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$1.create = (left, right, params) => {
  return new ZodIntersection$1({
    left,
    right,
    typeName: ZodFirstPartyTypeKind$1.ZodIntersection,
    ...processCreateParams$1(params)
  });
};
let ZodTuple$1 = class ZodTuple10 extends ZodType$1 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$1.array) {
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.array,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID$1;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath$1(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus$1.mergeArray(status, results);
      });
    } else {
      return ParseStatus$1.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple10({
      ...this._def,
      rest
    });
  }
};
ZodTuple$1.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple$1({
    items: schemas,
    typeName: ZodFirstPartyTypeKind$1.ZodTuple,
    rest: null,
    ...processCreateParams$1(params)
  });
};
let ZodRecord$1 = class ZodRecord10 extends ZodType$1 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$1.object) {
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.object,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath$1(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath$1(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus$1.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus$1.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType$1) {
      return new ZodRecord10({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind$1.ZodRecord,
        ...processCreateParams$1(third)
      });
    }
    return new ZodRecord10({
      keyType: ZodString$1.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind$1.ZodRecord,
      ...processCreateParams$1(second)
    });
  }
};
let ZodMap$1 = class ZodMap10 extends ZodType$1 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$1.map) {
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.map,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath$1(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath$1(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$1;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID$1;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap$1.create = (keyType, valueType, params) => {
  return new ZodMap$1({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind$1.ZodMap,
    ...processCreateParams$1(params)
  });
};
let ZodSet$1 = class ZodSet10 extends ZodType$1 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$1.set) {
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.set,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    const def2 = this._def;
    if (def2.minSize !== null) {
      if (ctx.data.size < def2.minSize.value) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.too_small,
          minimum: def2.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.minSize.message
        });
        status.dirty();
      }
    }
    if (def2.maxSize !== null) {
      if (ctx.data.size > def2.maxSize.value) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.too_big,
          maximum: def2.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements3) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements3) {
        if (element.status === "aborted")
          return INVALID$1;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements2 = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath$1(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements2).then((elements3) => finalizeSet(elements3));
    } else {
      return finalizeSet(elements2);
    }
  }
  min(minSize, message) {
    return new ZodSet10({
      ...this._def,
      minSize: { value: minSize, message: errorUtil$1.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet10({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil$1.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet$1.create = (valueType, params) => {
  return new ZodSet$1({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind$1.ZodSet,
    ...processCreateParams$1(params)
  });
};
let ZodFunction$1 = class ZodFunction10 extends ZodType$1 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$1.function) {
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.function,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    function makeArgsIssue(args, error) {
      return makeIssue$1({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$1(),
          errorMap$1
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$1.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue$1({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap$1(),
          errorMap$1
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode$1.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise$1) {
      const me = this;
      return OK$1(async function(...args) {
        const error = new ZodError$1([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK$1(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError$1([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError$1([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction10({
      ...this._def,
      args: ZodTuple$1.create(items).rest(ZodUnknown$1.create())
    });
  }
  returns(returnType) {
    return new ZodFunction10({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction10({
      args: args ? args : ZodTuple$1.create([]).rest(ZodUnknown$1.create()),
      returns: returns || ZodUnknown$1.create(),
      typeName: ZodFirstPartyTypeKind$1.ZodFunction,
      ...processCreateParams$1(params)
    });
  }
};
let ZodLazy$1 = class ZodLazy10 extends ZodType$1 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy$1.create = (getter, params) => {
  return new ZodLazy$1({
    getter,
    typeName: ZodFirstPartyTypeKind$1.ZodLazy,
    ...processCreateParams$1(params)
  });
};
let ZodLiteral$1 = class ZodLiteral10 extends ZodType$1 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx, {
        received: ctx.data,
        code: ZodIssueCode$1.invalid_literal,
        expected: this._def.value
      });
      return INVALID$1;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$1.create = (value, params) => {
  return new ZodLiteral$1({
    value,
    typeName: ZodFirstPartyTypeKind$1.ZodLiteral,
    ...processCreateParams$1(params)
  });
};
function createZodEnum$1(values, params) {
  return new ZodEnum$1({
    values,
    typeName: ZodFirstPartyTypeKind$1.ZodEnum,
    ...processCreateParams$1(params)
  });
}
let ZodEnum$1 = class ZodEnum10 extends ZodType$1 {
  constructor() {
    super(...arguments);
    _ZodEnum_cache$1.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$1(ctx, {
        expected: util$1.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$1.invalid_type
      });
      return INVALID$1;
    }
    if (!__classPrivateFieldGet$1(this, _ZodEnum_cache$1)) {
      __classPrivateFieldSet$1(this, _ZodEnum_cache$1, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet$1(this, _ZodEnum_cache$1).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext$1(ctx, {
        received: ctx.data,
        code: ZodIssueCode$1.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$1;
    }
    return OK$1(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum10.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum10.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache$1 = /* @__PURE__ */ new WeakMap();
ZodEnum$1.create = createZodEnum$1;
let ZodNativeEnum$1 = class ZodNativeEnum10 extends ZodType$1 {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache$1.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util$1.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType$1.string && ctx.parsedType !== ZodParsedType$1.number) {
      const expectedValues = util$1.objectValues(nativeEnumValues);
      addIssueToContext$1(ctx, {
        expected: util$1.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode$1.invalid_type
      });
      return INVALID$1;
    }
    if (!__classPrivateFieldGet$1(this, _ZodNativeEnum_cache$1)) {
      __classPrivateFieldSet$1(this, _ZodNativeEnum_cache$1, new Set(util$1.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet$1(this, _ZodNativeEnum_cache$1).has(input.data)) {
      const expectedValues = util$1.objectValues(nativeEnumValues);
      addIssueToContext$1(ctx, {
        received: ctx.data,
        code: ZodIssueCode$1.invalid_enum_value,
        options: expectedValues
      });
      return INVALID$1;
    }
    return OK$1(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache$1 = /* @__PURE__ */ new WeakMap();
ZodNativeEnum$1.create = (values, params) => {
  return new ZodNativeEnum$1({
    values,
    typeName: ZodFirstPartyTypeKind$1.ZodNativeEnum,
    ...processCreateParams$1(params)
  });
};
let ZodPromise$1 = class ZodPromise10 extends ZodType$1 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType$1.promise && ctx.common.async === false) {
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.promise,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    const promisified = ctx.parsedType === ZodParsedType$1.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$1(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise$1.create = (schema, params) => {
  return new ZodPromise$1({
    type: schema,
    typeName: ZodFirstPartyTypeKind$1.ZodPromise,
    ...processCreateParams$1(params)
  });
};
let ZodEffects$1 = class ZodEffects10 extends ZodType$1 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$1.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext$1(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID$1;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$1;
          if (result.status === "dirty")
            return DIRTY$1(result.value);
          if (status.value === "dirty")
            return DIRTY$1(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID$1;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID$1;
        if (result.status === "dirty")
          return DIRTY$1(result.value);
        if (status.value === "dirty")
          return DIRTY$1(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID$1;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID$1;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid$1(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid$1(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util$1.assertNever(effect);
  }
};
ZodEffects$1.create = (schema, effect, params) => {
  return new ZodEffects$1({
    schema,
    typeName: ZodFirstPartyTypeKind$1.ZodEffects,
    effect,
    ...processCreateParams$1(params)
  });
};
ZodEffects$1.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects$1({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind$1.ZodEffects,
    ...processCreateParams$1(params)
  });
};
let ZodOptional$1 = class ZodOptional10 extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$1.undefined) {
      return OK$1(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$1.create = (type, params) => {
  return new ZodOptional$1({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$1.ZodOptional,
    ...processCreateParams$1(params)
  });
};
let ZodNullable$1 = class ZodNullable10 extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType$1.null) {
      return OK$1(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$1.create = (type, params) => {
  return new ZodNullable$1({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$1.ZodNullable,
    ...processCreateParams$1(params)
  });
};
let ZodDefault$1 = class ZodDefault10 extends ZodType$1 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType$1.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$1.create = (type, params) => {
  return new ZodDefault$1({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$1.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams$1(params)
  });
};
let ZodCatch$1 = class ZodCatch10 extends ZodType$1 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync$1(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError$1(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError$1(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$1.create = (type, params) => {
  return new ZodCatch$1({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$1.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams$1(params)
  });
};
let ZodNaN$1 = class ZodNaN10 extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType$1.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.nan,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN$1.create = (params) => {
  return new ZodNaN$1({
    typeName: ZodFirstPartyTypeKind$1.ZodNaN,
    ...processCreateParams$1(params)
  });
};
const BRAND$1 = Symbol("zod_brand");
let ZodBranded$1 = class ZodBranded10 extends ZodType$1 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
let ZodPipeline$1 = class ZodPipeline10 extends ZodType$1 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$1;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY$1(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID$1;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline10({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind$1.ZodPipeline
    });
  }
};
let ZodReadonly$1 = class ZodReadonly10 extends ZodType$1 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid$1(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync$1(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$1.create = (type, params) => {
  return new ZodReadonly$1({
    innerType: type,
    typeName: ZodFirstPartyTypeKind$1.ZodReadonly,
    ...processCreateParams$1(params)
  });
};
function cleanParams$1(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom$1(check, _params = {}, fatal) {
  if (check)
    return ZodAny$1.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams$1(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams$1(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny$1.create();
}
const late$1 = {
  object: ZodObject$1.lazycreate
};
var ZodFirstPartyTypeKind$1;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$1 || (ZodFirstPartyTypeKind$1 = {}));
const instanceOfType$1 = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom$1((data) => data instanceof cls, params);
const stringType$1 = ZodString$1.create;
const numberType$1 = ZodNumber$1.create;
const nanType$1 = ZodNaN$1.create;
const bigIntType$1 = ZodBigInt$1.create;
const booleanType$1 = ZodBoolean$1.create;
const dateType$1 = ZodDate$1.create;
const symbolType$1 = ZodSymbol$1.create;
const undefinedType$1 = ZodUndefined$1.create;
const nullType$1 = ZodNull$1.create;
const anyType$1 = ZodAny$1.create;
const unknownType$1 = ZodUnknown$1.create;
const neverType$1 = ZodNever$1.create;
const voidType$1 = ZodVoid$1.create;
const arrayType$1 = ZodArray$1.create;
const objectType$1 = ZodObject$1.create;
const strictObjectType$1 = ZodObject$1.strictCreate;
const unionType$1 = ZodUnion$1.create;
const discriminatedUnionType$1 = ZodDiscriminatedUnion$1.create;
const intersectionType$1 = ZodIntersection$1.create;
const tupleType$1 = ZodTuple$1.create;
const recordType$1 = ZodRecord$1.create;
const mapType$1 = ZodMap$1.create;
const setType$1 = ZodSet$1.create;
const functionType$1 = ZodFunction$1.create;
const lazyType$1 = ZodLazy$1.create;
const literalType$1 = ZodLiteral$1.create;
const enumType$1 = ZodEnum$1.create;
const nativeEnumType$1 = ZodNativeEnum$1.create;
const promiseType$1 = ZodPromise$1.create;
const effectsType$1 = ZodEffects$1.create;
const optionalType$1 = ZodOptional$1.create;
const nullableType$1 = ZodNullable$1.create;
const preprocessType$1 = ZodEffects$1.createWithPreprocess;
const pipelineType$1 = ZodPipeline$1.create;
const ostring$1 = () => stringType$1().optional();
const onumber$1 = () => numberType$1().optional();
const oboolean$1 = () => booleanType$1().optional();
const coerce$1 = {
  string: (arg) => ZodString$1.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber$1.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean$1.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt$1.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate$1.create({ ...arg, coerce: true })
};
const NEVER$1 = INVALID$1;
var z$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap$1,
  setErrorMap: setErrorMap$1,
  getErrorMap: getErrorMap$1,
  makeIssue: makeIssue$1,
  EMPTY_PATH: EMPTY_PATH$1,
  addIssueToContext: addIssueToContext$1,
  ParseStatus: ParseStatus$1,
  INVALID: INVALID$1,
  DIRTY: DIRTY$1,
  OK: OK$1,
  isAborted: isAborted$1,
  isDirty: isDirty$1,
  isValid: isValid$1,
  isAsync: isAsync$1,
  get util() {
    return util$1;
  },
  get objectUtil() {
    return objectUtil$1;
  },
  ZodParsedType: ZodParsedType$1,
  getParsedType: getParsedType$1,
  ZodType: ZodType$1,
  datetimeRegex: datetimeRegex$1,
  ZodString: ZodString$1,
  ZodNumber: ZodNumber$1,
  ZodBigInt: ZodBigInt$1,
  ZodBoolean: ZodBoolean$1,
  ZodDate: ZodDate$1,
  ZodSymbol: ZodSymbol$1,
  ZodUndefined: ZodUndefined$1,
  ZodNull: ZodNull$1,
  ZodAny: ZodAny$1,
  ZodUnknown: ZodUnknown$1,
  ZodNever: ZodNever$1,
  ZodVoid: ZodVoid$1,
  ZodArray: ZodArray$1,
  ZodObject: ZodObject$1,
  ZodUnion: ZodUnion$1,
  ZodDiscriminatedUnion: ZodDiscriminatedUnion$1,
  ZodIntersection: ZodIntersection$1,
  ZodTuple: ZodTuple$1,
  ZodRecord: ZodRecord$1,
  ZodMap: ZodMap$1,
  ZodSet: ZodSet$1,
  ZodFunction: ZodFunction$1,
  ZodLazy: ZodLazy$1,
  ZodLiteral: ZodLiteral$1,
  ZodEnum: ZodEnum$1,
  ZodNativeEnum: ZodNativeEnum$1,
  ZodPromise: ZodPromise$1,
  ZodEffects: ZodEffects$1,
  ZodTransformer: ZodEffects$1,
  ZodOptional: ZodOptional$1,
  ZodNullable: ZodNullable$1,
  ZodDefault: ZodDefault$1,
  ZodCatch: ZodCatch$1,
  ZodNaN: ZodNaN$1,
  BRAND: BRAND$1,
  ZodBranded: ZodBranded$1,
  ZodPipeline: ZodPipeline$1,
  ZodReadonly: ZodReadonly$1,
  custom: custom$1,
  Schema: ZodType$1,
  ZodSchema: ZodType$1,
  late: late$1,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind$1;
  },
  coerce: coerce$1,
  any: anyType$1,
  array: arrayType$1,
  bigint: bigIntType$1,
  boolean: booleanType$1,
  date: dateType$1,
  discriminatedUnion: discriminatedUnionType$1,
  effect: effectsType$1,
  "enum": enumType$1,
  "function": functionType$1,
  "instanceof": instanceOfType$1,
  intersection: intersectionType$1,
  lazy: lazyType$1,
  literal: literalType$1,
  map: mapType$1,
  nan: nanType$1,
  nativeEnum: nativeEnumType$1,
  never: neverType$1,
  "null": nullType$1,
  nullable: nullableType$1,
  number: numberType$1,
  object: objectType$1,
  oboolean: oboolean$1,
  onumber: onumber$1,
  optional: optionalType$1,
  ostring: ostring$1,
  pipeline: pipelineType$1,
  preprocess: preprocessType$1,
  promise: promiseType$1,
  record: recordType$1,
  set: setType$1,
  strictObject: strictObjectType$1,
  string: stringType$1,
  symbol: symbolType$1,
  transformer: effectsType$1,
  tuple: tupleType$1,
  "undefined": undefinedType$1,
  union: unionType$1,
  unknown: unknownType$1,
  "void": voidType$1,
  NEVER: NEVER$1,
  ZodIssueCode: ZodIssueCode$1,
  quotelessJson: quotelessJson$1,
  ZodError: ZodError$1
});
const BasePropsShape = ColumnsContainerPropsSchema$1.shape.props.unwrap().unwrap().shape;
const ColumnsContainerPropsSchema = z$1.object({
  style: ColumnsContainerPropsSchema$1.shape.style,
  props: z$1.object({
    ...BasePropsShape,
    columns: z$1.tuple([
      z$1.object({ childrenIds: z$1.array(z$1.string()) }),
      z$1.object({ childrenIds: z$1.array(z$1.string()) }),
      z$1.object({ childrenIds: z$1.array(z$1.string()) })
    ])
  }).optional().nullable()
});
/**
 *  Copyright 2025 AntonyDev
 *  @license MIT
**/
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError11 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError11)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError11.create = (issues) => {
  const error = new ZodError11(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus11 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus11.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath11 {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError11(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType11 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus11(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects11({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def2) {
    this.spa = this.safeParseAsync;
    this._def = def2;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional11.create(this, this._def);
  }
  nullable() {
    return ZodNullable11.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray11.create(this);
  }
  promise() {
    return ZodPromise11.create(this, this._def);
  }
  or(option) {
    return ZodUnion11.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection11.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects11({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def2) {
    const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodDefault11({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded11({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def2) {
    const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodCatch11({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline11.create(this, target);
  }
  readonly() {
    return ZodReadonly11.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString11 extends ZodType11 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus11();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString11({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString11({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString11({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString11({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString11.create = (params) => {
  var _a;
  return new ZodString11({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber11 extends ZodType11 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus11();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber11({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber11({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber11.create = (params) => {
  return new ZodNumber11({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt11 extends ZodType11 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus11();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt11({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt11({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt11.create = (params) => {
  var _a;
  return new ZodBigInt11({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean11 extends ZodType11 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean11.create = (params) => {
  return new ZodBoolean11({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate11 extends ZodType11 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus11();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate11({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate11.create = (params) => {
  return new ZodDate11({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol11 extends ZodType11 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol11.create = (params) => {
  return new ZodSymbol11({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined11 extends ZodType11 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined11.create = (params) => {
  return new ZodUndefined11({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull11 extends ZodType11 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull11.create = (params) => {
  return new ZodNull11({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny11 extends ZodType11 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny11.create = (params) => {
  return new ZodAny11({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown11 extends ZodType11 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown11.create = (params) => {
  return new ZodUnknown11({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever11 extends ZodType11 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever11.create = (params) => {
  return new ZodNever11({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid11 extends ZodType11 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid11.create = (params) => {
  return new ZodVoid11({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray11 extends ZodType11 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def2 = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def2.exactLength !== null) {
      const tooBig = ctx.data.length > def2.exactLength.value;
      const tooSmall = ctx.data.length < def2.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def2.exactLength.value : void 0,
          maximum: tooBig ? def2.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def2.exactLength.message
        });
        status.dirty();
      }
    }
    if (def2.minLength !== null) {
      if (ctx.data.length < def2.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def2.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.minLength.message
        });
        status.dirty();
      }
    }
    if (def2.maxLength !== null) {
      if (ctx.data.length > def2.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def2.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def2.type._parseAsync(new ParseInputLazyPath11(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus11.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def2.type._parseSync(new ParseInputLazyPath11(ctx, item, ctx.path, i));
    });
    return ParseStatus11.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray11({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray11({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray11({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray11.create = (schema, params) => {
  return new ZodArray11({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject11) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional11.create(deepPartialify(fieldSchema));
    }
    return new ZodObject11({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray11) {
    return new ZodArray11({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional11) {
    return ZodOptional11.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable11) {
    return ZodNullable11.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple11) {
    return ZodTuple11.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject11 extends ZodType11 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever11 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath11(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever11) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath11(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus11.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus11.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject11({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject11({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject11({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject11({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject11({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject11({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject11({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject11({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject11({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional11) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject11({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject11.create = (shape, params) => {
  return new ZodObject11({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever11.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject11.strictCreate = (shape, params) => {
  return new ZodObject11({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever11.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject11.lazycreate = (shape, params) => {
  return new ZodObject11({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever11.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion11 extends ZodType11 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError11(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError11(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion11.create = (types, params) => {
  return new ZodUnion11({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type) => {
  if (type instanceof ZodLazy11) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects11) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral11) {
    return [type.value];
  } else if (type instanceof ZodEnum11) {
    return type.options;
  } else if (type instanceof ZodNativeEnum11) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault11) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined11) {
    return [void 0];
  } else if (type instanceof ZodNull11) {
    return [null];
  } else if (type instanceof ZodOptional11) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable11) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded11) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly11) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch11) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
class ZodDiscriminatedUnion11 extends ZodType11 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion11({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
class ZodIntersection11 extends ZodType11 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection11.create = (left, right, params) => {
  return new ZodIntersection11({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple11 extends ZodType11 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath11(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus11.mergeArray(status, results);
      });
    } else {
      return ParseStatus11.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple11({
      ...this._def,
      rest
    });
  }
}
ZodTuple11.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple11({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord11 extends ZodType11 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath11(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath11(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus11.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus11.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType11) {
      return new ZodRecord11({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord11({
      keyType: ZodString11.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap11 extends ZodType11 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath11(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath11(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap11.create = (keyType, valueType, params) => {
  return new ZodMap11({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet11 extends ZodType11 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def2 = this._def;
    if (def2.minSize !== null) {
      if (ctx.data.size < def2.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def2.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.minSize.message
        });
        status.dirty();
      }
    }
    if (def2.maxSize !== null) {
      if (ctx.data.size > def2.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def2.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements22) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements22) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements2 = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath11(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements2).then((elements22) => finalizeSet(elements22));
    } else {
      return finalizeSet(elements2);
    }
  }
  min(minSize, message) {
    return new ZodSet11({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet11({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet11.create = (valueType, params) => {
  return new ZodSet11({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction11 extends ZodType11 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise11) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError11([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError11([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError11([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction11({
      ...this._def,
      args: ZodTuple11.create(items).rest(ZodUnknown11.create())
    });
  }
  returns(returnType) {
    return new ZodFunction11({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction11({
      args: args ? args : ZodTuple11.create([]).rest(ZodUnknown11.create()),
      returns: returns || ZodUnknown11.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy11 extends ZodType11 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy11.create = (getter, params) => {
  return new ZodLazy11({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral11 extends ZodType11 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral11.create = (value, params) => {
  return new ZodLiteral11({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum11({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum11 extends ZodType11 {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache)) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum11.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum11.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum11.create = createZodEnum;
class ZodNativeEnum11 extends ZodType11 {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache)) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum11.create = (values, params) => {
  return new ZodNativeEnum11({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise11 extends ZodType11 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise11.create = (schema, params) => {
  return new ZodPromise11({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects11 extends ZodType11 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects11.create = (schema, effect, params) => {
  return new ZodEffects11({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects11.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects11({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional11 extends ZodType11 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional11.create = (type, params) => {
  return new ZodOptional11({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable11 extends ZodType11 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable11.create = (type, params) => {
  return new ZodNullable11({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault11 extends ZodType11 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault11.create = (type, params) => {
  return new ZodDefault11({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch11 extends ZodType11 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError11(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError11(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch11.create = (type, params) => {
  return new ZodCatch11({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN11 extends ZodType11 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN11.create = (params) => {
  return new ZodNaN11({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded11 extends ZodType11 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline11 extends ZodType11 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline11({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly11 extends ZodType11 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly11.create = (type, params) => {
  return new ZodReadonly11({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny11.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny11.create();
}
const late = {
  object: ZodObject11.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString11.create;
const numberType = ZodNumber11.create;
const nanType = ZodNaN11.create;
const bigIntType = ZodBigInt11.create;
const booleanType = ZodBoolean11.create;
const dateType = ZodDate11.create;
const symbolType = ZodSymbol11.create;
const undefinedType = ZodUndefined11.create;
const nullType = ZodNull11.create;
const anyType = ZodAny11.create;
const unknownType = ZodUnknown11.create;
const neverType = ZodNever11.create;
const voidType = ZodVoid11.create;
const arrayType = ZodArray11.create;
const objectType = ZodObject11.create;
const strictObjectType = ZodObject11.strictCreate;
const unionType = ZodUnion11.create;
const discriminatedUnionType = ZodDiscriminatedUnion11.create;
const intersectionType = ZodIntersection11.create;
const tupleType = ZodTuple11.create;
const recordType = ZodRecord11.create;
const mapType = ZodMap11.create;
const setType = ZodSet11.create;
const functionType = ZodFunction11.create;
const lazyType = ZodLazy11.create;
const literalType = ZodLiteral11.create;
const enumType = ZodEnum11.create;
const nativeEnumType = ZodNativeEnum11.create;
const promiseType = ZodPromise11.create;
const effectsType = ZodEffects11.create;
const optionalType = ZodOptional11.create;
const nullableType = ZodNullable11.create;
const preprocessType = ZodEffects11.createWithPreprocess;
const pipelineType = ZodPipeline11.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
  string: (arg) => ZodString11.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber11.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean11.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt11.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate11.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus: ParseStatus11,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType: ZodType11,
  datetimeRegex,
  ZodString: ZodString11,
  ZodNumber: ZodNumber11,
  ZodBigInt: ZodBigInt11,
  ZodBoolean: ZodBoolean11,
  ZodDate: ZodDate11,
  ZodSymbol: ZodSymbol11,
  ZodUndefined: ZodUndefined11,
  ZodNull: ZodNull11,
  ZodAny: ZodAny11,
  ZodUnknown: ZodUnknown11,
  ZodNever: ZodNever11,
  ZodVoid: ZodVoid11,
  ZodArray: ZodArray11,
  ZodObject: ZodObject11,
  ZodUnion: ZodUnion11,
  ZodDiscriminatedUnion: ZodDiscriminatedUnion11,
  ZodIntersection: ZodIntersection11,
  ZodTuple: ZodTuple11,
  ZodRecord: ZodRecord11,
  ZodMap: ZodMap11,
  ZodSet: ZodSet11,
  ZodFunction: ZodFunction11,
  ZodLazy: ZodLazy11,
  ZodLiteral: ZodLiteral11,
  ZodEnum: ZodEnum11,
  ZodNativeEnum: ZodNativeEnum11,
  ZodPromise: ZodPromise11,
  ZodEffects: ZodEffects11,
  ZodTransformer: ZodEffects11,
  ZodOptional: ZodOptional11,
  ZodNullable: ZodNullable11,
  ZodDefault: ZodDefault11,
  ZodCatch: ZodCatch11,
  ZodNaN: ZodNaN11,
  BRAND,
  ZodBranded: ZodBranded11,
  ZodPipeline: ZodPipeline11,
  ZodReadonly: ZodReadonly11,
  custom,
  Schema: ZodType11,
  ZodSchema: ZodType11,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError: ZodError11
});
const FONT_FAMILY_NAMES$1 = [
  "MODERN_SANS",
  "BOOK_SANS",
  "ORGANIC_SANS",
  "GEOMETRIC_SANS",
  "HEAVY_SANS",
  "ROUNDED_SANS",
  "MODERN_SERIF",
  "BOOK_SERIF",
  "MONOSPACE"
];
const PADDING_SCHEMA = z.object({
  top: z.number(),
  bottom: z.number(),
  right: z.number(),
  left: z.number()
}).optional().nullable();
const COLOR_SCHEMA$1 = z.string().regex(/^#[0-9a-fA-F]{6}$/).nullable().optional();
z.enum(FONT_FAMILY_NAMES$1).nullable().optional();
const getPadding = (padding) => padding ? `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px` : void 0;
const ContainerPropsSchema$1 = z.object({
  style: z.object({
    backgroundColor: COLOR_SCHEMA$1,
    borderColor: COLOR_SCHEMA$1,
    borderRadius: z.number().optional().nullable(),
    padding: PADDING_SCHEMA,
    width: z.string().optional().nullable(),
    maxWidth: z.string().optional().nullable(),
  }).optional().nullable()
});
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    style: {}
  },
  setup(__props) {
    const props = __props;
    const wStyle = computed(() => {
      var _a, _b, _c;
      return {
        backgroundColor: ((_a = props.style) == null ? void 0 : _a.backgroundColor) ?? void 0,
        border: getBorder(props.style),
        borderRadius: ((_b = props.style) == null ? void 0 : _b.borderRadius) ? props.style.borderRadius + "px" : void 0,
        padding: getPadding((_c = props.style) == null ? void 0 : _c.padding)
      };
    });
    function getBorder(style) {
      if (!style || !style.borderColor) {
        return void 0;
      }
      return `1px solid ${style.borderColor}`;
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        style: normalizeStyle(wStyle.value)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 4);
    };
  }
});
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "ContainerReader",
  props: {
    style: {},
    document: {},
    props: {}
  },
  setup(__props) {
    var _a;
    const props = __props;
    const childrenIds = ((_a = props.props) == null ? void 0 : _a.childrenIds) ?? [];
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$3), {
        style: normalizeStyle(_ctx.style)
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(childrenIds), (childId) => {
            return openBlock(), createBlock(_sfc_main$1, {
              key: childId,
              id: childId,
              document: _ctx.document
            }, null, 8, ["id", "document"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["style"]);
    };
  }
});
const ContainerPropsSchema = z$1.object({
  style: ContainerPropsSchema$1.shape.style,
  props: z$1.object({
    childrenIds: z$1.array(z$1.string()).optional().nullable()
  }).optional().nullable()
});
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "ReaderBlock",
  props: {
    document: {},
    id: {}
  },
  setup(__props) {
    const props = __props;
    const instance = computed(() => {
      const block2 = props.document[props.id];
      if (!block2) return void 0;
      return READER_DICTIONARY[block2.type].Component;
    });
    const data = computed(() => {
      const block2 = props.document[props.id];
      if (!block2) return void 0;
      return block2.data;
    });
    const READER_DICTIONARY = {
      ColumnsContainer: {
        schema: ColumnsContainerPropsSchema,
        Component: _sfc_main$4
      },
      Container: {
        schema: ContainerPropsSchema,
        Component: _sfc_main$2
      },
      EmailLayout: {
        schema: EmailLayoutPropsSchema,
        Component: _sfc_main
      },
      Avatar: {
        schema: AvatarPropsSchema,
        Component: _sfc_main$e
      },
      Button: {
        schema: ButtonPropsSchema,
        Component: _sfc_main$d
      },
      Divider: {
        schema: DividerPropsSchema,
        Component: _sfc_main$c
      },
      Heading: {
        schema: HeadingPropsSchema,
        Component: _sfc_main$b
      },
      Html: {
        schema: HtmlPropsSchema,
        Component: _sfc_main$a
      },
      Image: {
        schema: ImagePropsSchema,
        Component: _sfc_main$9
      },
      Spacer: {
        schema: SpacerPropsSchema,
        Component: _sfc_main$8
      },
      Text: {
        schema: TextPropsSchema,
        Component: _sfc_main$7
      }
    };
    return (_ctx, _cache) => {
      return instance.value ? (openBlock(), createBlock(resolveDynamicComponent(instance.value), normalizeProps(mergeProps({ key: 0 }, { ...data.value, document: _ctx.document })), null, 16)) : createCommentVNode("", true);
    };
  }
});
const _hoisted_1 = { style: { "width": "100%" } };
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "EmailLayoutReader",
  props: {
    document: {},
    backdropColor: {},
    borderColor: {},
    borderRadius: {},
    canvasColor: {},
    textColor: {},
    fontFamily: {},
    childrenIds: {}
  },
  setup(__props) {
    const props = __props;
    function getFontFamily2(fontFamily) {
      const f = fontFamily ?? "MODERN_SANS";
      switch (f) {
        case "MODERN_SANS":
          return '"Helvetica Neue", "Arial Nova", "Nimbus Sans", Arial, sans-serif';
        case "BOOK_SANS":
          return 'Optima, Candara, "Noto Sans", source-sans-pro, sans-serif';
        case "ORGANIC_SANS":
          return 'Seravek, "Gill Sans Nova", Ubuntu, Calibri, "DejaVu Sans", source-sans-pro, sans-serif';
        case "GEOMETRIC_SANS":
          return 'Avenir, "Avenir Next LT Pro", Montserrat, Corbel, "URW Gothic", source-sans-pro, sans-serif';
        case "HEAVY_SANS":
          return 'Bahnschrift, "DIN Alternate", "Franklin Gothic Medium", "Nimbus Sans Narrow", sans-serif-condensed, sans-serif';
        case "ROUNDED_SANS":
          return 'ui-rounded, "Hiragino Maru Gothic ProN", Quicksand, Comfortaa, Manjari, "Arial Rounded MT Bold", Calibri, source-sans-pro, sans-serif';
        case "MODERN_SERIF":
          return 'Charter, "Bitstream Charter", "Sitka Text", Cambria, serif';
        case "BOOK_SERIF":
          return '"Iowan Old Style", "Palatino Linotype", "URW Palladio L", P052, serif';
        case "MONOSPACE":
          return '"Nimbus Mono PS", "Courier New", "Cutive Mono", monospace';
      }
    }
    function getBorder({ borderColor }) {
      if (!borderColor) {
        return void 0;
      }
      return `1px solid ${borderColor}`;
    }
    const containerStyle = computed(() => ({
      backgroundColor: props.backdropColor ?? "#F5F5F5",
      color: props.textColor ?? "#262626",
      fontFamily: getFontFamily2(props.fontFamily),
      fontSize: "16px",
      fontWeight: "400",
      letterSpacing: "0.15008px",
      lineHeight: "1.5",
      margin: "0",
      padding: "32px 0",
      minHeight: "100%",
      width: "100%"
    }));
    const tableStyle = computed(() => ({
      margin: "0 auto",
      maxWidth: "600px",
      backgroundColor: props.canvasColor ?? "#FFFFFF",
      borderRadius: props.borderRadius ?? void 0,
      border: getBorder(props)
    }));
    const childrenIds = computed(() => props.childrenIds ?? []);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        style: normalizeStyle(containerStyle.value)
      }, [
        createElementVNode("table", {
          align: "center",
          width: "100%",
          role: "presentation",
          cellspacing: "0",
          cellpadding: "0",
          border: "0",
          style: normalizeStyle(tableStyle.value)
        }, [
          createElementVNode("tbody", null, [
            createElementVNode("tr", _hoisted_1, [
              createElementVNode("td", null, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(childrenIds.value, (childId) => {
                  return openBlock(), createBlock(_sfc_main$1, {
                    key: childId,
                    document: _ctx.document,
                    id: childId
                  }, null, 8, ["document", "id"]);
                }), 128))
              ])
            ])
          ])
        ], 4)
      ], 4);
    };
  }
});
const FONT_FAMILY_NAMES = [
  "MODERN_SANS",
  "BOOK_SANS",
  "ORGANIC_SANS",
  "GEOMETRIC_SANS",
  "HEAVY_SANS",
  "ROUNDED_SANS",
  "MODERN_SERIF",
  "BOOK_SERIF",
  "MONOSPACE"
];
z$1.object({
  top: z$1.number(),
  bottom: z$1.number(),
  right: z$1.number(),
  left: z$1.number()
}).optional().nullable();
const COLOR_SCHEMA = z$1.string().regex(/^#[0-9a-fA-F]{6}$/).nullable().optional();
const FONT_FAMILY_SCHEMA = z$1.enum(FONT_FAMILY_NAMES).nullable().optional();
const EmailLayoutPropsSchema = z$1.object({
  backdropColor: COLOR_SCHEMA,
  borderColor: COLOR_SCHEMA,
  borderRadius: z$1.number().optional().nullable(),
  canvasColor: COLOR_SCHEMA,
  textColor: COLOR_SCHEMA,
  fontFamily: FONT_FAMILY_SCHEMA,
  childrenIds: z$1.array(z$1.string()).optional().nullable()
});
export {
  AvatarPropsSchema as A,
  ButtonPropsSchema as B,
  ContainerPropsSchema as C,
  DividerPropsSchema as D,
  EmailLayoutPropsSchema as E,
  HtmlPropsSchema as H,
  ImagePropsSchema as I,
  SpacerPropsSchema as S,
  TextPropsSchema as T,
  _sfc_main$7 as _,
  _sfc_main$8 as a,
  _sfc_main$9 as b,
  _sfc_main$a as c,
  _sfc_main$b as d,
  HeadingPropsSchema as e,
  _sfc_main$c as f,
  _sfc_main$d as g,
  _sfc_main$e as h,
  _sfc_main as i,
  _sfc_main$2 as j,
  _sfc_main$4 as k,
  ColumnsContainerPropsSchema as l
};
